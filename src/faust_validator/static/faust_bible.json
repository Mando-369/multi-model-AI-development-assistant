{
  "version": "1.0",
  "source": "/Users/thomasmandolini/Dev/Local Coding Assistant/faustlibraries",
  "libraries": {
    "aanl": {
      "file": "aanl.lib",
      "prefix": "aa",
      "function_count": 41
    },
    "all": {
      "file": "all.lib",
      "prefix": null,
      "function_count": 0
    },
    "analyzers": {
      "file": "analyzers.lib",
      "prefix": "an",
      "function_count": 25
    },
    "basics": {
      "file": "basics.lib",
      "prefix": "ba",
      "function_count": 87
    },
    "compressors": {
      "file": "compressors.lib",
      "prefix": "co",
      "function_count": 29
    },
    "delays": {
      "file": "delays.lib",
      "prefix": "de",
      "function_count": 7
    },
    "demos": {
      "file": "demos.lib",
      "prefix": "dm",
      "function_count": 41
    },
    "doc": {
      "file": "doc.lib",
      "prefix": null,
      "function_count": 0
    },
    "envelopes": {
      "file": "envelopes.lib",
      "prefix": "en",
      "function_count": 14
    },
    "fds": {
      "file": "fds.lib",
      "prefix": "fd",
      "function_count": 16
    },
    "filters": {
      "file": "filters.lib",
      "prefix": "fi",
      "function_count": 111
    },
    "hoa": {
      "file": "hoa.lib",
      "prefix": "ho",
      "function_count": 29
    },
    "instruments": {
      "file": "instruments.lib",
      "prefix": null,
      "function_count": 0
    },
    "interpolators": {
      "file": "interpolators.lib",
      "prefix": "it",
      "function_count": 16
    },
    "linearalgebra": {
      "file": "linearalgebra.lib",
      "prefix": "la",
      "function_count": 7
    },
    "maths": {
      "file": "maths.lib",
      "prefix": "ma",
      "function_count": 54
    },
    "maxmsp": {
      "file": "maxmsp.lib",
      "prefix": null,
      "function_count": 0
    },
    "mi": {
      "file": "mi.lib",
      "prefix": "mi",
      "function_count": 15
    },
    "misceffects": {
      "file": "misceffects.lib",
      "prefix": "ef",
      "function_count": 25
    },
    "motion": {
      "file": "motion.lib",
      "prefix": "mo",
      "function_count": 22
    },
    "noises": {
      "file": "noises.lib",
      "prefix": "no",
      "function_count": 17
    },
    "oscillators": {
      "file": "oscillators.lib",
      "prefix": "os",
      "function_count": 72
    },
    "phaflangers": {
      "file": "phaflangers.lib",
      "prefix": "pf",
      "function_count": 4
    },
    "physmodels": {
      "file": "physmodels.lib",
      "prefix": "pm",
      "function_count": 150
    },
    "platform": {
      "file": "platform.lib",
      "prefix": "pl",
      "function_count": 3
    },
    "quantizers": {
      "file": "quantizers.lib",
      "prefix": "qu",
      "function_count": 15
    },
    "reducemaps": {
      "file": "reducemaps.lib",
      "prefix": null,
      "function_count": 5
    },
    "reverbs": {
      "file": "reverbs.lib",
      "prefix": "re",
      "function_count": 15
    },
    "routes": {
      "file": "routes.lib",
      "prefix": "ro",
      "function_count": 10
    },
    "sf": {
      "file": "sf.lib",
      "prefix": null,
      "function_count": 0
    },
    "signals": {
      "file": "signals.lib",
      "prefix": "si",
      "function_count": 20
    },
    "soundfiles": {
      "file": "soundfiles.lib",
      "prefix": "so",
      "function_count": 3
    },
    "spats": {
      "file": "spats.lib",
      "prefix": "sp",
      "function_count": 6
    },
    "stdfaust": {
      "file": "stdfaust.lib",
      "prefix": null,
      "function_count": 0
    },
    "synths": {
      "file": "synths.lib",
      "prefix": "sy",
      "function_count": 9
    },
    "tonestacks": {
      "file": "tonestacks.lib",
      "prefix": null,
      "function_count": 0
    },
    "tubes": {
      "file": "tubes.lib",
      "prefix": null,
      "function_count": 0
    },
    "vaeffects": {
      "file": "vaeffects.lib",
      "prefix": "ve",
      "function_count": 30
    },
    "version": {
      "file": "version.lib",
      "prefix": "vl",
      "function_count": 1
    },
    "wdmodels": {
      "file": "wdmodels.lib",
      "prefix": "wd",
      "function_count": 44
    },
    "webaudio": {
      "file": "webaudio.lib",
      "prefix": "wa",
      "function_count": 8
    }
  },
  "functions": {
    "aa.clip": {
      "prefix": "aa",
      "name": "clip",
      "full_name": "aa.clip",
      "args": [
        "l",
        "h",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Clipping function."
    },
    "aa.Rsqrt": {
      "prefix": "aa",
      "name": "Rsqrt",
      "full_name": "aa.Rsqrt",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued sqrt()."
    },
    "aa.Rlog": {
      "prefix": "aa",
      "name": "Rlog",
      "full_name": "aa.Rlog",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued log()."
    },
    "aa.Rtan": {
      "prefix": "aa",
      "name": "Rtan",
      "full_name": "aa.Rtan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued tan()."
    },
    "aa.Racos": {
      "prefix": "aa",
      "name": "Racos",
      "full_name": "aa.Racos",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued acos()."
    },
    "aa.Rasin": {
      "prefix": "aa",
      "name": "Rasin",
      "full_name": "aa.Rasin",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued asin()."
    },
    "aa.Racosh": {
      "prefix": "aa",
      "name": "Racosh",
      "full_name": "aa.Racosh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued acosh()"
    },
    "aa.Rcosh": {
      "prefix": "aa",
      "name": "Rcosh",
      "full_name": "aa.Rcosh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued cosh()."
    },
    "aa.Rsinh": {
      "prefix": "aa",
      "name": "Rsinh",
      "full_name": "aa.Rsinh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued sinh()."
    },
    "aa.Ratanh": {
      "prefix": "aa",
      "name": "Ratanh",
      "full_name": "aa.Ratanh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued atanh()."
    },
    "aa.ADAA1": {
      "prefix": "aa",
      "name": "ADAA1",
      "full_name": "aa.ADAA1",
      "args": [
        "EPS",
        "f",
        "F1"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Generalised first-order Antiderivative Anti-Aliasing (ADAA) function."
    },
    "aa.ADAA2": {
      "prefix": "aa",
      "name": "ADAA2",
      "full_name": "aa.ADAA2",
      "args": [
        "EPS",
        "f",
        "F1",
        "F2"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Generalised second-order Antiderivative Anti-Aliasing (ADAA) function."
    },
    "aa.hardclip": {
      "prefix": "aa",
      "name": "hardclip",
      "full_name": "aa.hardclip",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA hard-clip."
    },
    "aa.hardclip2": {
      "prefix": "aa",
      "name": "hardclip2",
      "full_name": "aa.hardclip2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA hard-clip."
    },
    "aa.cubic1": {
      "prefix": "aa",
      "name": "cubic1",
      "full_name": "aa.cubic1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA cubic saturator."
    },
    "aa.parabolic": {
      "prefix": "aa",
      "name": "parabolic",
      "full_name": "aa.parabolic",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA parabolic saturator."
    },
    "aa.parabolic2": {
      "prefix": "aa",
      "name": "parabolic2",
      "full_name": "aa.parabolic2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA parabolic saturator."
    },
    "aa.hyperbolic": {
      "prefix": "aa",
      "name": "hyperbolic",
      "full_name": "aa.hyperbolic",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA hyperbolic saturator."
    },
    "aa.hyperbolic2": {
      "prefix": "aa",
      "name": "hyperbolic2",
      "full_name": "aa.hyperbolic2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA hyperbolic saturator."
    },
    "aa.sinarctan": {
      "prefix": "aa",
      "name": "sinarctan",
      "full_name": "aa.sinarctan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA sin(atan()) saturator."
    },
    "aa.sinarctan2": {
      "prefix": "aa",
      "name": "sinarctan2",
      "full_name": "aa.sinarctan2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA sin(atan()) saturator."
    },
    "aa.softclipQuadratic1": {
      "prefix": "aa",
      "name": "softclipQuadratic1",
      "full_name": "aa.softclipQuadratic1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA quadratic softclip."
    },
    "aa.softclipQuadratic2": {
      "prefix": "aa",
      "name": "softclipQuadratic2",
      "full_name": "aa.softclipQuadratic2",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA quadratic softclip."
    },
    "aa.tanh1": {
      "prefix": "aa",
      "name": "tanh1",
      "full_name": "aa.tanh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA tanh() saturator."
    },
    "aa.arctan": {
      "prefix": "aa",
      "name": "arctan",
      "full_name": "aa.arctan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA atan()."
    },
    "aa.arctan2": {
      "prefix": "aa",
      "name": "arctan2",
      "full_name": "aa.arctan2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA atan()."
    },
    "aa.asinh1": {
      "prefix": "aa",
      "name": "asinh1",
      "full_name": "aa.asinh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA asinh() saturator (unbounded)."
    },
    "aa.asinh2": {
      "prefix": "aa",
      "name": "asinh2",
      "full_name": "aa.asinh2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA asinh() saturator (unbounded)."
    },
    "aa.cosine1": {
      "prefix": "aa",
      "name": "cosine1",
      "full_name": "aa.cosine1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA cos()."
    },
    "aa.cosine2": {
      "prefix": "aa",
      "name": "cosine2",
      "full_name": "aa.cosine2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA cos()."
    },
    "aa.arccos": {
      "prefix": "aa",
      "name": "arccos",
      "full_name": "aa.arccos",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA acos()."
    },
    "aa.arccos2": {
      "prefix": "aa",
      "name": "arccos2",
      "full_name": "aa.arccos2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA acos()."
    },
    "aa.acosh1": {
      "prefix": "aa",
      "name": "acosh1",
      "full_name": "aa.acosh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA acosh()."
    },
    "aa.acosh2": {
      "prefix": "aa",
      "name": "acosh2",
      "full_name": "aa.acosh2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA acosh()."
    },
    "aa.sine": {
      "prefix": "aa",
      "name": "sine",
      "full_name": "aa.sine",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA sin()."
    },
    "aa.sine2": {
      "prefix": "aa",
      "name": "sine2",
      "full_name": "aa.sine2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA sin()."
    },
    "aa.arcsin": {
      "prefix": "aa",
      "name": "arcsin",
      "full_name": "aa.arcsin",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA asin()."
    },
    "aa.arcsin2": {
      "prefix": "aa",
      "name": "arcsin2",
      "full_name": "aa.arcsin2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA asin()."
    },
    "aa.tangent": {
      "prefix": "aa",
      "name": "tangent",
      "full_name": "aa.tangent",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA tan()."
    },
    "aa.atanh1": {
      "prefix": "aa",
      "name": "atanh1",
      "full_name": "aa.atanh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA atanh()."
    },
    "aa.atanh2": {
      "prefix": "aa",
      "name": "atanh2",
      "full_name": "aa.atanh2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA atanh()."
    },
    "an.abs_envelope_rect": {
      "prefix": "an",
      "name": "abs_envelope_rect",
      "full_name": "an.abs_envelope_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with moving-average algorithm."
    },
    "an.abs_envelope_tau": {
      "prefix": "an",
      "name": "abs_envelope_tau",
      "full_name": "an.abs_envelope_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with one-pole lowpass and tau response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.abs_envelope_t60": {
      "prefix": "an",
      "name": "abs_envelope_t60",
      "full_name": "an.abs_envelope_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with one-pole lowpass and t60 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.abs_envelope_t19": {
      "prefix": "an",
      "name": "abs_envelope_t19",
      "full_name": "an.abs_envelope_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with one-pole lowpass and t19 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.amp_follower": {
      "prefix": "an",
      "name": "amp_follower",
      "full_name": "an.amp_follower",
      "args": [
        "rel"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Classic analog audio envelope follower with infinitely fast rise and exponential decay.  The amplitude envelope instantaneously follows the absolute value going up, but then floats down exponentially."
    },
    "an.amp_follower_ud": {
      "prefix": "an",
      "name": "amp_follower_ud",
      "full_name": "an.amp_follower_ud",
      "args": [
        "att",
        "rel"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Envelope follower with different up and down time-constants (also called a \"peak detector\")."
    },
    "an.amp_follower_ar": {
      "prefix": "an",
      "name": "amp_follower_ar",
      "full_name": "an.amp_follower_ar",
      "args": [
        "att",
        "rel"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Envelope follower with independent attack and release times. The release can be shorter than the attack (unlike in `amp_follower_ud` above)."
    },
    "an.ms_envelope_rect": {
      "prefix": "an",
      "name": "ms_envelope_rect",
      "full_name": "an.ms_envelope_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square with moving-average algorithm."
    },
    "an.ms_envelope_tau": {
      "prefix": "an",
      "name": "ms_envelope_tau",
      "full_name": "an.ms_envelope_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square average with one-pole lowpass and tau response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.ms_envelope_t60": {
      "prefix": "an",
      "name": "ms_envelope_t60",
      "full_name": "an.ms_envelope_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square with one-pole lowpass and t60 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.ms_envelope_t19": {
      "prefix": "an",
      "name": "ms_envelope_t19",
      "full_name": "an.ms_envelope_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square with one-pole lowpass and t19 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.rms_envelope_rect": {
      "prefix": "an",
      "name": "rms_envelope_rect",
      "full_name": "an.rms_envelope_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with moving-average algorithm."
    },
    "an.rms_envelope_tau": {
      "prefix": "an",
      "name": "rms_envelope_tau",
      "full_name": "an.rms_envelope_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with one-pole lowpass and tau response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.rms_envelope_t60": {
      "prefix": "an",
      "name": "rms_envelope_t60",
      "full_name": "an.rms_envelope_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with one-pole lowpass and t60 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.rms_envelope_t19": {
      "prefix": "an",
      "name": "rms_envelope_t19",
      "full_name": "an.rms_envelope_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with one-pole lowpass and t19 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/))."
    },
    "an.zcr": {
      "prefix": "an",
      "name": "zcr",
      "full_name": "an.zcr",
      "args": [
        "tau"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Zero-crossing rate (ZCR) with one-pole lowpass averaging based on the tau constant. It outputs an index between 0 and 1 at a desired analysis frame. The ZCR of a signal correlates with the noisiness ["
    },
    "an.pitchTracker": {
      "prefix": "an",
      "name": "pitchTracker",
      "full_name": "an.pitchTracker",
      "args": [
        "N",
        "tau"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "This function implements a pitch-tracking algorithm by means of zero-crossing rate analysis and adaptive low-pass filtering. The design is based on the algorithm described in [this tutorial (section 2"
    },
    "an.spectralCentroid": {
      "prefix": "an",
      "name": "spectralCentroid",
      "full_name": "an.spectralCentroid",
      "args": [
        "nonlinearity",
        "tau"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "This function implements a time-domain spectral centroid by means of RMS measurements and adaptive crossover filtering. The weight difference of the upper and lower spectral powers are used to recursi"
    },
    "an.mth_octave_analyzer": {
      "prefix": "an",
      "name": "mth_octave_analyzer",
      "full_name": "an.mth_octave_analyzer",
      "args": [
        "O",
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Octave analyzer. `mth_octave_analyzer[N]` are standard Faust functions."
    },
    "an.mth_octave_spectral_level6e": {
      "prefix": "an",
      "name": "mth_octave_spectral_level6e",
      "full_name": "an.mth_octave_spectral_level6e",
      "args": [
        "M",
        "ftop",
        "NBands",
        "tau",
        "dB_offset"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Spectral level display."
    },
    "an.mth_octave_spectral_level_demo": {
      "prefix": "an",
      "name": "mth_octave_spectral_level_demo",
      "full_name": "an.mth_octave_spectral_level_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A bunch of special cases based on the different analyzer functions described above:"
    },
    "an.analyzer": {
      "prefix": "an",
      "name": "analyzer",
      "full_name": "an.analyzer",
      "args": [
        "O",
        "freqs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Analyzer."
    },
    "an.ifft": {
      "prefix": "an",
      "name": "ifft",
      "full_name": "an.ifft",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Inverse Fast Fourier Transform (IFFT)."
    },
    "an.logsweep": {
      "prefix": "an",
      "name": "logsweep",
      "full_name": "an.logsweep",
      "args": [
        "fs",
        "fe",
        "dur"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Logarithmic sine sweep generator."
    },
    "an.linsweep": {
      "prefix": "an",
      "name": "linsweep",
      "full_name": "an.linsweep",
      "args": [
        "fs",
        "fe",
        "dur"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear sine sweep generator."
    },
    "ba.samp2sec": {
      "prefix": "ba",
      "name": "samp2sec",
      "full_name": "ba.samp2sec",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a number of samples to a duration in seconds at the current sampling rate (see `ma.SR`). `samp2sec` is a standard Faust function."
    },
    "ba.sec2samp": {
      "prefix": "ba",
      "name": "sec2samp",
      "full_name": "ba.sec2samp",
      "args": [
        "d"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a duration in seconds to a number of samples at the current sampling rate (see `ma.SR`). `samp2sec` is a standard Faust function."
    },
    "ba.db2linear": {
      "prefix": "ba",
      "name": "db2linear",
      "full_name": "ba.db2linear",
      "args": [
        "l"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "dB-to-linear value converter. It can be used to convert an amplitude in dB to a linear gain ]0-N]. `db2linear` is a standard Faust function."
    },
    "ba.linear2db": {
      "prefix": "ba",
      "name": "linear2db",
      "full_name": "ba.linear2db",
      "args": [
        "g"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "linea-to-dB value converter. It can be used to convert a linear gain ]0-N] to an amplitude in dB. `linear2db` is a standard Faust function."
    },
    "ba.lin2LogGain": {
      "prefix": "ba",
      "name": "lin2LogGain",
      "full_name": "ba.lin2LogGain",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a linear gain (0-1) to a log gain (0-1)."
    },
    "ba.log2LinGain": {
      "prefix": "ba",
      "name": "log2LinGain",
      "full_name": "ba.log2LinGain",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a log gain (0-1) to a linear gain (0-1)."
    },
    "ba.tau2pole": {
      "prefix": "ba",
      "name": "tau2pole",
      "full_name": "ba.tau2pole",
      "args": [
        "tau2pole(tau"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Returns a real pole giving exponential decay. Note that t60 (time to decay 60 dB) is ~6.91 time constants. `tau2pole` is a standard Faust function."
    },
    "ba.pole2tau": {
      "prefix": "ba",
      "name": "pole2tau",
      "full_name": "ba.pole2tau",
      "args": [
        "pole"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Returns the time-constant, in seconds, corresponding to the given real, positive pole in (0-1). `pole2tau` is a standard Faust function."
    },
    "ba.midikey2hz": {
      "prefix": "ba",
      "name": "midikey2hz",
      "full_name": "ba.midikey2hz",
      "args": [
        "mk"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a MIDI key number to a frequency in Hz (MIDI key 69 = A440). `midikey2hz` is a standard Faust function."
    },
    "ba.hz2midikey": {
      "prefix": "ba",
      "name": "hz2midikey",
      "full_name": "ba.hz2midikey",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency in Hz to a MIDI key number (MIDI key 69 = A440). `hz2midikey` is a standard Faust function."
    },
    "ba.semi2ratio": {
      "prefix": "ba",
      "name": "semi2ratio",
      "full_name": "ba.semi2ratio",
      "args": [
        "semi"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts semitones in a frequency multiplicative ratio. `semi2ratio` is a standard Faust function."
    },
    "ba.ratio2semi": {
      "prefix": "ba",
      "name": "ratio2semi",
      "full_name": "ba.ratio2semi",
      "args": [
        "ratio"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency multiplicative ratio in semitones. `ratio2semi` is a standard Faust function."
    },
    "ba.cent2ratio": {
      "prefix": "ba",
      "name": "cent2ratio",
      "full_name": "ba.cent2ratio",
      "args": [
        "cent"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts cents in a frequency multiplicative ratio."
    },
    "ba.ratio2cent": {
      "prefix": "ba",
      "name": "ratio2cent",
      "full_name": "ba.ratio2cent",
      "args": [
        "ratio"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency multiplicative ratio in cents."
    },
    "ba.pianokey2hz": {
      "prefix": "ba",
      "name": "pianokey2hz",
      "full_name": "ba.pianokey2hz",
      "args": [
        "pk"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a piano key number to a frequency in Hz (piano key 49 = A440)."
    },
    "ba.hz2pianokey": {
      "prefix": "ba",
      "name": "hz2pianokey",
      "full_name": "ba.hz2pianokey",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency in Hz to a piano key number (piano key 49 = A440)."
    },
    "ba.counter": {
      "prefix": "ba",
      "name": "counter",
      "full_name": "ba.counter",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Starts counting 0, 1, 2, 3..., and raise the current integer value at each upfront of the trigger."
    },
    "ba.countdown": {
      "prefix": "ba",
      "name": "countdown",
      "full_name": "ba.countdown",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Starts counting down from n included to 0. While trig is 1 the output is n. The countdown starts with the transition of trig from 1 to 0. At the end of the countdown the output value will remain at 0 "
    },
    "ba.countup": {
      "prefix": "ba",
      "name": "countup",
      "full_name": "ba.countup",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Starts counting up from 0 to n included. While trig is 1 the output is 0. The countup starts with the transition of trig from 1 to 0. At the end of the countup the output value will remain at n until "
    },
    "ba.sweep": {
      "prefix": "ba",
      "name": "sweep",
      "full_name": "ba.sweep",
      "args": [
        "period",
        "run"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Counts from 0 to `period-1` repeatedly, generating a sawtooth waveform, like `os.lf_rawsaw`, starting at 1 when `run` transitions from 0 to 1."
    },
    "ba.time": {
      "prefix": "ba",
      "name": "time",
      "full_name": "ba.time",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple counter that produces the sequence of 0,1,2...N integer values. `time` is a standard Faust function."
    },
    "ba.ramp": {
      "prefix": "ba",
      "name": "ramp",
      "full_name": "ba.ramp",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A linear ramp with a slope of '(+/-)1/n' samples to reach the next target value."
    },
    "ba.line": {
      "prefix": "ba",
      "name": "line",
      "full_name": "ba.line",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A ramp interpolator that generates a linear transition to reach a target value:"
    },
    "ba.tempo": {
      "prefix": "ba",
      "name": "tempo",
      "full_name": "ba.tempo",
      "args": [
        "t"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a tempo in BPM into a number of samples."
    },
    "ba.period": {
      "prefix": "ba",
      "name": "period",
      "full_name": "ba.period",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Basic sawtooth wave of period `p`."
    },
    "ba.spulse": {
      "prefix": "ba",
      "name": "spulse",
      "full_name": "ba.spulse",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Produces a single pulse of n samples when trig goes from 0 to 1."
    },
    "ba.pulse": {
      "prefix": "ba",
      "name": "pulse",
      "full_name": "ba.pulse",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Pulses (like 10000) generated at period `p`."
    },
    "ba.pulsen": {
      "prefix": "ba",
      "name": "pulsen",
      "full_name": "ba.pulsen",
      "args": [
        "n",
        "p"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Pulses (like 11110000) of length `n` generated at period `p`."
    },
    "ba.cycle": {
      "prefix": "ba",
      "name": "cycle",
      "full_name": "ba.cycle",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Split nonzero input values into `n` cycles."
    },
    "ba.beat": {
      "prefix": "ba",
      "name": "beat",
      "full_name": "ba.beat",
      "args": [
        "t"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Pulses at tempo `t` in BPM. `beat` is a standard Faust function."
    },
    "ba.pulse_countup": {
      "prefix": "ba",
      "name": "pulse_countup",
      "full_name": "ba.pulse_countup",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting up pulses. While trig is 1 the output is counting up, while trig is 0 the counter is reset to 0."
    },
    "ba.pulse_countdown": {
      "prefix": "ba",
      "name": "pulse_countdown",
      "full_name": "ba.pulse_countdown",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting down pulses. While trig is 1 the output is counting down, while trig is 0 the counter is reset to 0."
    },
    "ba.pulse_countup_loop": {
      "prefix": "ba",
      "name": "pulse_countup_loop",
      "full_name": "ba.pulse_countup_loop",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting up pulses from 0 to n included. While trig is 1 the output is counting up, while trig is 0 the counter is reset to 0. At the end of the countup (n) the output value will be reset to 0."
    },
    "ba.pulse_countdown_loop": {
      "prefix": "ba",
      "name": "pulse_countdown_loop",
      "full_name": "ba.pulse_countdown_loop",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting down pulses from 0 to n included. While trig is 1 the output is counting down, while trig is 0 the counter is reset to 0. At the end of the countdown (n) the output value will be reset"
    },
    "ba.resetCtr": {
      "prefix": "ba",
      "name": "resetCtr",
      "full_name": "ba.resetCtr",
      "args": [
        "n",
        "m"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Function that lets through the mth impulse out of each consecutive group of `n` impulses."
    },
    "ba.count": {
      "prefix": "ba",
      "name": "count",
      "full_name": "ba.count",
      "args": [
        "l"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Count the number of elements of list l. `count` is a standard Faust function."
    },
    "ba.take": {
      "prefix": "ba",
      "name": "take",
      "full_name": "ba.take",
      "args": [
        "P",
        "l"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Take an element from a list. `take` is a standard Faust function."
    },
    "ba.pick": {
      "prefix": "ba",
      "name": "pick",
      "full_name": "ba.pick",
      "args": [
        "l",
        "n"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Pick the nth element from a list. Similar to `ba.take(n+1,l)` but faster and more powerful."
    },
    "ba.pickN": {
      "prefix": "ba",
      "name": "pickN",
      "full_name": "ba.pickN",
      "args": [
        "N",
        "O"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Select the inputs listed in `O` among `N` at compile time."
    },
    "ba.subseq": {
      "prefix": "ba",
      "name": "subseq",
      "full_name": "ba.subseq",
      "args": [
        "l",
        "P",
        "N"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Extract a part of a list."
    },
    "ba.tabulate": {
      "prefix": "ba",
      "name": "tabulate",
      "full_name": "ba.tabulate",
      "args": [
        "C",
        "FX",
        "S",
        "r0",
        "r1",
        "x"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Tabulate a 1D function over the range [r0, r1] for access via nearest-value, linear, cubic interpolation. In other words, the uniformly tabulated function can be evaluated using interpolation of order"
    },
    "ba.tabulate_chebychev": {
      "prefix": "ba",
      "name": "tabulate_chebychev",
      "full_name": "ba.tabulate_chebychev",
      "args": [
        "C",
        "FX",
        "NX",
        "CD",
        "r0",
        "r1"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Tabulate a 1D function over the range [r0, r1] for access via Chebyshev polynomial approximation. In contrast to `(ba.)tabulate`, which interpolates only between tabulated samples, `(ba.)tabulate_cheb"
    },
    "ba.tabulateNd": {
      "prefix": "ba",
      "name": "tabulateNd",
      "full_name": "ba.tabulateNd",
      "args": [
        "C",
        "function",
        "(parameters"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Tabulate an nD function for access via nearest-value or linear or cubic interpolation. In other words, the tabulated function can be evaluated using interpolation of order 0 (none), 1 (linear), or 3 ("
    },
    "ba.if": {
      "prefix": "ba",
      "name": "if",
      "full_name": "ba.if",
      "args": [
        "cond",
        "then",
        "else"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "if-then-else implemented with a select2. WARNING: since `select2` is strict (always evaluating both branches), the resulting if does not have the usual \"lazy\" semantic of the C if form, and thus canno"
    },
    "ba.ifNc": {
      "prefix": "ba",
      "name": "ifNc",
      "full_name": "ba.ifNc",
      "args": [
        "cond1",
        "then1",
        "cond2",
        "then2",
        "... condN",
        "thenN",
        "else"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "if-then-elseif-then-...elsif-then-else implemented on top of `ba.if`."
    },
    "ba.ifNcNo": {
      "prefix": "ba",
      "name": "ifNcNo",
      "full_name": "ba.ifNcNo",
      "args": [
        "Nc",
        "No",
        "cond1",
        "then1",
        "cond2",
        "then2",
        "... condN",
        "thenN",
        "else"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "`ifNcNo(Nc,No)` is similar to `ifNc(Nc)` above but then/else branches have `No` outputs."
    },
    "ba.selector": {
      "prefix": "ba",
      "name": "selector",
      "full_name": "ba.selector",
      "args": [
        "I",
        "N"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Selects the ith input among n at compile time."
    },
    "ba.select2stereo": {
      "prefix": "ba",
      "name": "select2stereo",
      "full_name": "ba.select2stereo",
      "args": [
        "bpc"
      ],
      "arg_count": 1,
      "inputs": 4,
      "outputs": 2,
      "description": "Select between 2 stereo signals."
    },
    "ba.selectn": {
      "prefix": "ba",
      "name": "selectn",
      "full_name": "ba.selectn",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Selects the ith input among N at run time."
    },
    "ba.selectbus": {
      "prefix": "ba",
      "name": "selectbus",
      "full_name": "ba.selectbus",
      "args": [
        "BUS_SIZE",
        "NUM_BUSES",
        "id"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Select a bus among `NUM_BUSES` buses, where each bus has `BUS_SIZE` outputs. The order of the signal inputs should be the signals of the first bus, the signals of the second bus, and so on."
    },
    "ba.selectxbus": {
      "prefix": "ba",
      "name": "selectxbus",
      "full_name": "ba.selectxbus",
      "args": [
        "BUS_SIZE",
        "NUM_BUSES",
        "fade",
        "id"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Like `ba.selectbus`, but with a cross-fade when selecting the bus using the same technique than `ba.selectmulti`."
    },
    "ba.selectmulti": {
      "prefix": "ba",
      "name": "selectmulti",
      "full_name": "ba.selectmulti",
      "args": [
        "n",
        "lgen",
        "id"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Selects the ith circuit among N at run time (all should have the same number of inputs and outputs) with a crossfade."
    },
    "ba.selectoutn": {
      "prefix": "ba",
      "name": "selectoutn",
      "full_name": "ba.selectoutn",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Route input to the output among N at run time."
    },
    "ba.latch": {
      "prefix": "ba",
      "name": "latch",
      "full_name": "ba.latch",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Latch input on the rising edge of trig. Captures (\"records\") the input x whenever trig crosses from \u22640 to >0, and holds the last captured value at all other times."
    },
    "ba.sAndH": {
      "prefix": "ba",
      "name": "sAndH",
      "full_name": "ba.sAndH",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sample And Hold: \"records\" the input when trig is 1, outputs a frozen value when trig is 0. `sAndH` is a standard Faust function."
    },
    "ba.tAndH": {
      "prefix": "ba",
      "name": "tAndH",
      "full_name": "ba.tAndH",
      "args": [
        "pred"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Test And Hold: \"records\" the input when pred(input) is true, outputs a frozen value otherwise."
    },
    "ba.downSample": {
      "prefix": "ba",
      "name": "downSample",
      "full_name": "ba.downSample",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Down sample a signal. WARNING: this function doesn't change the rate of a signal, it just holds samples... `downSample` is a standard Faust function."
    },
    "ba.downSampleCV": {
      "prefix": "ba",
      "name": "downSampleCV",
      "full_name": "ba.downSampleCV",
      "args": [
        "amount"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A version of `ba.downSample` where the frequency parameter has been replaced by an `amount` parameter that is in the range zero to one. WARNING: this function doesn't change the rate of a"
    },
    "ba.peakhold": {
      "prefix": "ba",
      "name": "peakhold",
      "full_name": "ba.peakhold",
      "args": [
        "mode"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Outputs current max value above zero."
    },
    "ba.peakholder": {
      "prefix": "ba",
      "name": "peakholder",
      "full_name": "ba.peakholder",
      "args": [
        "holdTime"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "While peak-holder functions are scarcely discussed in the literature (please do send me an email if you know otherwise), common sense tells that the expected behaviour should be as follows: the absolu"
    },
    "ba.kr2ar": {
      "prefix": "ba",
      "name": "kr2ar",
      "full_name": "ba.kr2ar",
      "args": [
        "\"freq\"",
        "200",
        "200",
        "2000",
        "0.1"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Force a control rate signal to be used as an audio rate signal."
    },
    "ba.impulsify": {
      "prefix": "ba",
      "name": "impulsify",
      "full_name": "ba.impulsify",
      "args": [
        "\"gate\""
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Turns a signal into an impulse with the value of the current sample (0.3,0.2,0.1 becomes 0.3,0.0,0.0). This function is typically used with a `button` to turn its output into an impulse. `impulsify` i"
    },
    "ba.automat": {
      "prefix": "ba",
      "name": "automat",
      "full_name": "ba.automat",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Record and replay in a loop the successives values of the input signal."
    },
    "ba.bpf": {
      "prefix": "ba",
      "name": "bpf",
      "full_name": "ba.bpf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "bpf is an environment (a group of related definitions) that can be used to create break-point functions. It contains three functions:"
    },
    "ba.listInterp": {
      "prefix": "ba",
      "name": "listInterp",
      "full_name": "ba.listInterp",
      "args": [
        "v"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Linearly interpolates between the elements of a list."
    },
    "ba.bypass1": {
      "prefix": "ba",
      "name": "bypass1",
      "full_name": "ba.bypass1",
      "args": [
        "bpc",
        "e"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Takes a mono input signal, route it to `e` and bypass it if `bpc = 1`. When bypassed, `e` is feed with zeros so that its state is cleanup up. `bypass1` is a standard Faust function."
    },
    "ba.bypass2": {
      "prefix": "ba",
      "name": "bypass2",
      "full_name": "ba.bypass2",
      "args": [
        "bpc",
        "e"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Takes a stereo input signal, route it to `e` and bypass it if `bpc = 1`. When bypassed, `e` is feed with zeros so that its state is cleanup up. `bypass2` is a standard Faust function."
    },
    "ba.bypass1to2": {
      "prefix": "ba",
      "name": "bypass1to2",
      "full_name": "ba.bypass1to2",
      "args": [
        "bpc",
        "e"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 2,
      "description": "Bypass switch for effect `e` having mono input signal and stereo output. Effect `e` is bypassed if `bpc = 1`.When bypassed, `e` is feed with zeros so that its state is cleanup up."
    },
    "ba.bypass_fade": {
      "prefix": "ba",
      "name": "bypass_fade",
      "full_name": "ba.bypass_fade",
      "args": [
        "n",
        "b",
        "e"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Bypass an arbitrary (N x N) circuit with 'n' samples crossfade. Inputs and outputs signals are faded out when 'e' is bypassed, so that 'e' state is cleanup up."
    },
    "ba.toggle": {
      "prefix": "ba",
      "name": "toggle",
      "full_name": "ba.toggle",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Triggered by the change of 0 to 1, it toggles the output value between 0 and 1."
    },
    "ba.on_and_off": {
      "prefix": "ba",
      "name": "on_and_off",
      "full_name": "ba.on_and_off",
      "args": [
        "a",
        "b"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "The first channel set the output to 1, the second channel to 0."
    },
    "ba.bitcrusher": {
      "prefix": "ba",
      "name": "bitcrusher",
      "full_name": "ba.bitcrusher",
      "args": [
        "nbits"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Produce distortion by reduction of the signal resolution."
    },
    "ba.mulaw_bitcrusher": {
      "prefix": "ba",
      "name": "mulaw_bitcrusher",
      "full_name": "ba.mulaw_bitcrusher",
      "args": [
        "mu",
        "nbits"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Produce distortion by reducing the signal resolution using \u03bc-law compression."
    },
    "ba.slidingReduce": {
      "prefix": "ba",
      "name": "slidingReduce",
      "full_name": "ba.slidingReduce",
      "args": [
        "op",
        "n",
        "maxN",
        "disabledVal"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Fold-like high order function. Apply a commutative binary operation `op` to the last `n` consecutive samples of a signal `x`. For example : `slidingReduce(max,128,128,0-(ma.MAX))` will compute the max"
    },
    "ba.slidingSum": {
      "prefix": "ba",
      "name": "slidingSum",
      "full_name": "ba.slidingSum",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding sum of the last n input samples."
    },
    "ba.slidingSump": {
      "prefix": "ba",
      "name": "slidingSump",
      "full_name": "ba.slidingSump",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding sum of the last n input samples."
    },
    "ba.slidingMax": {
      "prefix": "ba",
      "name": "slidingMax",
      "full_name": "ba.slidingMax",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding maximum of the last n input samples."
    },
    "ba.slidingMin": {
      "prefix": "ba",
      "name": "slidingMin",
      "full_name": "ba.slidingMin",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding minimum of the last n input samples."
    },
    "ba.slidingMean": {
      "prefix": "ba",
      "name": "slidingMean",
      "full_name": "ba.slidingMean",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding mean of the last n input samples."
    },
    "ba.slidingMeanp": {
      "prefix": "ba",
      "name": "slidingMeanp",
      "full_name": "ba.slidingMeanp",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding mean of the last n input samples."
    },
    "ba.slidingRMS": {
      "prefix": "ba",
      "name": "slidingRMS",
      "full_name": "ba.slidingRMS",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The root mean square of the last n input samples."
    },
    "ba.slidingRMSp": {
      "prefix": "ba",
      "name": "slidingRMSp",
      "full_name": "ba.slidingRMSp",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The root mean square of the last n input samples."
    },
    "ba.parallelOp": {
      "prefix": "ba",
      "name": "parallelOp",
      "full_name": "ba.parallelOp",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Apply a commutative binary operation `op` to N parallel inputs."
    },
    "ba.parallelMax": {
      "prefix": "ba",
      "name": "parallelMax",
      "full_name": "ba.parallelMax",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The maximum of N parallel inputs."
    },
    "ba.parallelMin": {
      "prefix": "ba",
      "name": "parallelMin",
      "full_name": "ba.parallelMin",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The minimum of N parallel inputs."
    },
    "ba.parallelMean": {
      "prefix": "ba",
      "name": "parallelMean",
      "full_name": "ba.parallelMean",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The mean of N parallel inputs."
    },
    "ba.parallelRMS": {
      "prefix": "ba",
      "name": "parallelRMS",
      "full_name": "ba.parallelRMS",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The RMS of N parallel inputs."
    },
    "co.ratio": {
      "prefix": "co",
      "name": "ratio",
      "full_name": "co.ratio",
      "args": [
        "ratio"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "This utility converts a ratio to a strength."
    },
    "co.strength": {
      "prefix": "co",
      "name": "strength",
      "full_name": "co.strength",
      "args": [
        "strength"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "This utility converts a strength to a ratio."
    },
    "co.peak_compression_gain_mono_db": {
      "prefix": "co",
      "name": "peak_compression_gain_mono_db",
      "full_name": "co.peak_compression_gain_mono_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressor gain computer with dB output. `peak_compression_gain_mono_db` is a standard Faust function."
    },
    "co.peak_compression_gain_N_chan_db": {
      "prefix": "co",
      "name": "peak_compression_gain_N_chan_db",
      "full_name": "co.peak_compression_gain_N_chan_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 5,
      "description": "N channels dynamic range compressor gain computer with dB output. `peak_compression_gain_N_chan_db` is a standard Faust function."
    },
    "co.FFcompressor_N_chan": {
      "prefix": "co",
      "name": "FFcompressor_N_chan",
      "full_name": "co.FFcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "N"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward N channels dynamic range compressor. `FFcompressor_N_chan` is a standard Faust function."
    },
    "co.FBcompressor_N_chan": {
      "prefix": "co",
      "name": "FBcompressor_N_chan",
      "full_name": "co.FBcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "N"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed back N channels dynamic range compressor. `FBcompressor_N_chan` is a standard Faust function."
    },
    "co.FBFFcompressor_N_chan": {
      "prefix": "co",
      "name": "FBFFcompressor_N_chan",
      "full_name": "co.FBFFcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "FBFF",
        "meter",
        "N"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward / feed back N channels dynamic range compressor. The feedback part has a much higher strength, so they end up sounding similar. `FBFFcompressor_N_chan` is a standard Faust function."
    },
    "co.RMS_compression_gain_mono_db": {
      "prefix": "co",
      "name": "RMS_compression_gain_mono_db",
      "full_name": "co.RMS_compression_gain_mono_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono RMS dynamic range compressor gain computer with dB output. `RMS_compression_gain_mono_db` is a standard Faust function."
    },
    "co.RMS_compression_gain_N_chan_db": {
      "prefix": "co",
      "name": "RMS_compression_gain_N_chan_db",
      "full_name": "co.RMS_compression_gain_N_chan_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 5,
      "description": "RMS N channels dynamic range compressor gain computer with dB output. `RMS_compression_gain_N_chan_db` is a standard Faust function."
    },
    "co.RMS_FBFFcompressor_N_chan": {
      "prefix": "co",
      "name": "RMS_FBFFcompressor_N_chan",
      "full_name": "co.RMS_FBFFcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "FBFF",
        "meter",
        "N"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 3,
      "description": "RMS feed forward / feed back N channels dynamic range compressor. The feedback part has a much higher strength, so they end up sounding similar. `RMS_FBFFcompressor_N_chan` is a standard Faust functio"
    },
    "co.RMS_FBcompressor_peak_limiter_N_chan": {
      "prefix": "co",
      "name": "RMS_FBcompressor_peak_limiter_N_chan",
      "full_name": "co.RMS_FBcompressor_peak_limiter_N_chan",
      "args": [
        "strength",
        "thresh",
        "threshLim",
        "att",
        "rel",
        "knee",
        "link",
        "meter",
        "meterLim",
        "N"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 5,
      "description": "N channel RMS feed back compressor into peak limiter feeding back into the FB compressor. By combining them this way, they complement each other optimally: the RMS compressor doesn't have to deal with"
    },
    "co.peak_compression_gain_mono": {
      "prefix": "co",
      "name": "peak_compression_gain_mono",
      "full_name": "co.peak_compression_gain_mono",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressor gain computer with linear output. `peak_compression_gain_mono` is a standard Faust function."
    },
    "co.peak_compression_gain_N_chan": {
      "prefix": "co",
      "name": "peak_compression_gain_N_chan",
      "full_name": "co.peak_compression_gain_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 4,
      "description": "N channels dynamic range compressor gain computer with linear output. `peak_compression_gain_N_chan` is a standard Faust function."
    },
    "co.RMS_compression_gain_mono": {
      "prefix": "co",
      "name": "RMS_compression_gain_mono",
      "full_name": "co.RMS_compression_gain_mono",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono RMS dynamic range compressor gain computer with linear output. `RMS_compression_gain_mono` is a standard Faust function."
    },
    "co.RMS_compression_gain_N_chan": {
      "prefix": "co",
      "name": "RMS_compression_gain_N_chan",
      "full_name": "co.RMS_compression_gain_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 4,
      "description": "RMS N channels dynamic range compressor gain computer with linear output. `RMS_compression_gain_N_chan` is a standard Faust function."
    },
    "co.compressor_lad_mono": {
      "prefix": "co",
      "name": "compressor_lad_mono",
      "full_name": "co.compressor_lad_mono",
      "args": [
        "lad",
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressor with lookahead delay. `compressor_lad_mono` is a standard Faust function."
    },
    "co.compressor_mono": {
      "prefix": "co",
      "name": "compressor_mono",
      "full_name": "co.compressor_mono",
      "args": [
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressors. `compressor_mono` is a standard Faust function."
    },
    "co.compressor_stereo": {
      "prefix": "co",
      "name": "compressor_stereo",
      "full_name": "co.compressor_stereo",
      "args": [
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo dynamic range compressors."
    },
    "co.compression_gain_mono": {
      "prefix": "co",
      "name": "compression_gain_mono",
      "full_name": "co.compression_gain_mono",
      "args": [
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Compression-gain calculation for dynamic range compressors."
    },
    "co.limiter_1176_R4_mono": {
      "prefix": "co",
      "name": "limiter_1176_R4_mono",
      "full_name": "co.limiter_1176_R4_mono",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "A limiter guards against hard-clipping.  It can be implemented as a compressor having a high threshold (near the clipping level), fast attack, and high ratio.  Since"
    },
    "co.limiter_1176_R4_stereo": {
      "prefix": "co",
      "name": "limiter_1176_R4_stereo",
      "full_name": "co.limiter_1176_R4_stereo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "A limiter guards against hard-clipping.  It can be implemented as a compressor having a high threshold (near the clipping level), fast attack and release, and high ratio.  Since"
    },
    "co.peak_expansion_gain_N_chan_db": {
      "prefix": "co",
      "name": "peak_expansion_gain_N_chan_db",
      "full_name": "co.peak_expansion_gain_N_chan_db",
      "args": [
        "strength",
        "thresh",
        "range",
        "att",
        "hold",
        "rel",
        "knee",
        "prePost",
        "link",
        "maxHold",
        "N"
      ],
      "arg_count": 11,
      "inputs": 0,
      "outputs": 5,
      "description": "N channels dynamic range expander gain computer. `peak_expansion_gain_N_chan_db` is a standard Faust function."
    },
    "co.expander_N_chan": {
      "prefix": "co",
      "name": "expander_N_chan",
      "full_name": "co.expander_N_chan",
      "args": [
        "strength",
        "thresh",
        "range",
        "att",
        "hold",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "maxHold",
        "N"
      ],
      "arg_count": 12,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward N channels dynamic range expander. `expander_N_chan` is a standard Faust function."
    },
    "co.expanderSC_N_chan": {
      "prefix": "co",
      "name": "expanderSC_N_chan",
      "full_name": "co.expanderSC_N_chan",
      "args": [
        "strength",
        "thresh",
        "range",
        "att",
        "hold",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "maxHold",
        "N",
        "SCfunction",
        "SCswitch",
        "SCsignal"
      ],
      "arg_count": 15,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward N channels dynamic range expander with sidechain. `expanderSC_N_chan` is a standard Faust function."
    },
    "co.limiter_lad_N": {
      "prefix": "co",
      "name": "limiter_lad_N",
      "full_name": "co.limiter_lad_N",
      "args": [
        "N",
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 2,
      "description": "N-channels lookahead limiter inspired by IOhannes Zm\u00f6lnig's post, which is in turn based on the thesis by Peter Falkner \"Entwicklung eines digitalen Stereo-Limiters mit Hilfe des Signalprozessors DSP5"
    },
    "co.limiter_lad_mono": {
      "prefix": "co",
      "name": "limiter_lad_mono",
      "full_name": "co.limiter_lad_mono",
      "args": [
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Specialised case of `limiter_lad_N` mono limiter."
    },
    "co.limiter_lad_stereo": {
      "prefix": "co",
      "name": "limiter_lad_stereo",
      "full_name": "co.limiter_lad_stereo",
      "args": [
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 5,
      "inputs": 2,
      "outputs": 2,
      "description": "Specialised case of `limiter_lad_N` stereo limiter."
    },
    "co.limiter_lad_quad": {
      "prefix": "co",
      "name": "limiter_lad_quad",
      "full_name": "co.limiter_lad_quad",
      "args": [
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 2,
      "description": "Specialised case of `limiter_lad_N` quadraphonic limiter."
    },
    "co.limiter_lad_bw": {
      "prefix": "co",
      "name": "limiter_lad_bw",
      "full_name": "co.limiter_lad_bw",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Specialised case of `limiter_lad_N` and ready-to-use unit-amplitude mono limiting function. This implementation, in particular, uses `2PI*tau` time constant filters for attack and release smoothing wi"
    },
    "de.delay": {
      "prefix": "de",
      "name": "delay",
      "full_name": "de.delay",
      "args": [
        "n",
        "d"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple `d` samples delay where `n` is the maximum delay length as a number of samples. Unlike the `@` delay operator, here the delay signal `d` is explicitly bounded to the interval [0..n]. The conseq"
    },
    "de.fdelay": {
      "prefix": "de",
      "name": "fdelay",
      "full_name": "de.fdelay",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Delay lines interpolated using Thiran allpass interpolation."
    },
    "de.sdelay": {
      "prefix": "de",
      "name": "sdelay",
      "full_name": "de.sdelay",
      "args": [
        "n",
        "it",
        "d"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "s(mooth)delay: a mono delay that doesn't click and doesn't transpose when the delay time is changed."
    },
    "de.prime_power_delays": {
      "prefix": "de",
      "name": "prime_power_delays",
      "full_name": "de.prime_power_delays",
      "args": [
        "N",
        "pathmin",
        "pathmax"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 2,
      "description": "Prime Power Delay Line Lengths."
    },
    "de.fdelaylti": {
      "prefix": "de",
      "name": "fdelaylti",
      "full_name": "de.fdelaylti",
      "args": [
        "N",
        "n",
        "d",
        "x"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Fractional delay line using Lagrange interpolation."
    },
    "de.fdelay1": {
      "prefix": "de",
      "name": "fdelay1",
      "full_name": "de.fdelay1",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "For convenience, `fdelay1`, `fdelay2`, `fdelay3`, `fdelay4`, `fdelay5` are also available where `N` is the order of the interpolation, built using `fdelayltv`. Thiran Allpass Interpolation."
    },
    "de.multiTapSincDelay": {
      "prefix": "de",
      "name": "multiTapSincDelay",
      "full_name": "de.multiTapSincDelay",
      "args": [
        "K",
        "MaxDelay",
        "tau1",
        "tau2",
        "alpha"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Variable delay line using multi-tap sinc interpolation."
    },
    "dm.mth_octave_spectral_level_demo": {
      "prefix": "dm",
      "name": "mth_octave_spectral_level_demo",
      "full_name": "dm.mth_octave_spectral_level_demo",
      "args": [
        "BandsPerOctave"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Demonstrate mth_octave_spectral_level in a standalone GUI."
    },
    "dm.parametric_eq_demo": {
      "prefix": "dm",
      "name": "parametric_eq_demo",
      "full_name": "dm.parametric_eq_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "A parametric equalizer application."
    },
    "dm.spectral_tilt_demo": {
      "prefix": "dm",
      "name": "spectral_tilt_demo",
      "full_name": "dm.spectral_tilt_demo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A spectral tilt application."
    },
    "dm.mth_octave_filterbank_demo": {
      "prefix": "dm",
      "name": "mth_octave_filterbank_demo",
      "full_name": "dm.mth_octave_filterbank_demo",
      "args": [
        "M"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Graphic Equalizer: each filter-bank output signal routes through a fader."
    },
    "dm.cubicnl_demo": {
      "prefix": "dm",
      "name": "cubicnl_demo",
      "full_name": "dm.cubicnl_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Distortion demo application."
    },
    "dm.gate_demo": {
      "prefix": "dm",
      "name": "gate_demo",
      "full_name": "dm.gate_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Gate demo application."
    },
    "dm.compressor_demo": {
      "prefix": "dm",
      "name": "compressor_demo",
      "full_name": "dm.compressor_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Compressor demo application."
    },
    "dm.moog_vcf_demo": {
      "prefix": "dm",
      "name": "moog_vcf_demo",
      "full_name": "dm.moog_vcf_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Illustrate and compare all three Moog VCF implementations above."
    },
    "dm.wah4_demo": {
      "prefix": "dm",
      "name": "wah4_demo",
      "full_name": "dm.wah4_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Wah pedal application."
    },
    "dm.crybaby_demo": {
      "prefix": "dm",
      "name": "crybaby_demo",
      "full_name": "dm.crybaby_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Crybaby effect application."
    },
    "dm.flanger_demo": {
      "prefix": "dm",
      "name": "flanger_demo",
      "full_name": "dm.flanger_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Flanger effect application."
    },
    "dm.phaser2_demo": {
      "prefix": "dm",
      "name": "phaser2_demo",
      "full_name": "dm.phaser2_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Phaser effect demo application."
    },
    "dm.tapeStop_demo": {
      "prefix": "dm",
      "name": "tapeStop_demo",
      "full_name": "dm.tapeStop_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo tape-stop effect."
    },
    "dm.freeverb_demo": {
      "prefix": "dm",
      "name": "freeverb_demo",
      "full_name": "dm.freeverb_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Freeverb demo application."
    },
    "dm.springreverb_demo": {
      "prefix": "dm",
      "name": "springreverb_demo",
      "full_name": "dm.springreverb_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono spring-inspired reverb demo using `re.springreverb`."
    },
    "dm.stereo_reverb_tester": {
      "prefix": "dm",
      "name": "stereo_reverb_tester",
      "full_name": "dm.stereo_reverb_tester",
      "args": [
        "gui_group"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Handy test inputs for reverberator demos below."
    },
    "dm.fdnrev0_demo": {
      "prefix": "dm",
      "name": "fdnrev0_demo",
      "full_name": "dm.fdnrev0_demo",
      "args": [
        "N",
        "NB",
        "BBSO"
      ],
      "arg_count": 3,
      "inputs": 4,
      "outputs": 2,
      "description": "A reverb application using `fdnrev0`."
    },
    "dm.zita_rev_fdn_demo": {
      "prefix": "dm",
      "name": "zita_rev_fdn_demo",
      "full_name": "dm.zita_rev_fdn_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 3,
      "description": "Reverb demo application based on `zita_rev_fdn`."
    },
    "dm.zita_light": {
      "prefix": "dm",
      "name": "zita_light",
      "full_name": "dm.zita_light",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Light version of `dm.zita_rev1` with only 2 UI elements."
    },
    "dm.zita_rev1": {
      "prefix": "dm",
      "name": "zita_rev1",
      "full_name": "dm.zita_rev1",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `zita_rev1_stereo` (mostly following the Linux `zita-rev1` GUI)."
    },
    "dm.vital_rev_demo": {
      "prefix": "dm",
      "name": "vital_rev_demo",
      "full_name": "dm.vital_rev_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `vital_rev` with all parameters exposed."
    },
    "dm.reverbTank_demo": {
      "prefix": "dm",
      "name": "reverbTank_demo",
      "full_name": "dm.reverbTank_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "This is a stereo reverb following the \"ReverbTank\" example in [1], although some parameter ranges and scaling have been adjusted. It is an unofficial version of the Spin Semiconductor\u00ae Reverb."
    },
    "dm.kb_rom_rev1_demo": {
      "prefix": "dm",
      "name": "kb_rom_rev1_demo",
      "full_name": "dm.kb_rom_rev1_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Keith Barr reverb effect rom_rev1 demo application."
    },
    "dm.dattorro_rev_demo": {
      "prefix": "dm",
      "name": "dattorro_rev_demo",
      "full_name": "dm.dattorro_rev_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `dattorro_rev` with all parameters exposed and additional dry/wet and output gain control."
    },
    "dm.jprev_demo": {
      "prefix": "dm",
      "name": "jprev_demo",
      "full_name": "dm.jprev_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `jprev` with all parameters exposed."
    },
    "dm.greyhole_demo": {
      "prefix": "dm",
      "name": "greyhole_demo",
      "full_name": "dm.greyhole_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `greyhole` with all parameters exposed."
    },
    "dm.sawtooth_demo": {
      "prefix": "dm",
      "name": "sawtooth_demo",
      "full_name": "dm.sawtooth_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "An application demonstrating the different sawtooth oscillators of Faust."
    },
    "dm.virtual_analog_oscillator_demo": {
      "prefix": "dm",
      "name": "virtual_analog_oscillator_demo",
      "full_name": "dm.virtual_analog_oscillator_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Virtual analog oscillator demo application."
    },
    "dm.velvet_noise_demo": {
      "prefix": "dm",
      "name": "velvet_noise_demo",
      "full_name": "dm.velvet_noise_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Listen to velvet_noise!"
    },
    "dm.latch_demo": {
      "prefix": "dm",
      "name": "latch_demo",
      "full_name": "dm.latch_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Illustrate latch operation."
    },
    "dm.envelopes_demo": {
      "prefix": "dm",
      "name": "envelopes_demo",
      "full_name": "dm.envelopes_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Illustrate various envelopes overlaid, including their gate * 1.1."
    },
    "dm.fft_spectral_level_demo": {
      "prefix": "dm",
      "name": "fft_spectral_level_demo",
      "full_name": "dm.fft_spectral_level_demo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 3,
      "description": "Make a real-time spectrum analyzer using FFT from analyzers.lib."
    },
    "dm.pospass_demo": {
      "prefix": "dm",
      "name": "pospass_demo",
      "full_name": "dm.pospass_demo",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Use Positive-Pass Filter pospass() to frequency-shift a sine tone. First, a real sinusoid is converted to its analytic-signal form using pospass() to filter out its negative frequency component."
    },
    "dm.exciter": {
      "prefix": "dm",
      "name": "exciter",
      "full_name": "dm.exciter",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Psychoacoustic harmonic exciter, with GUI."
    },
    "dm.vocoder_demo": {
      "prefix": "dm",
      "name": "vocoder_demo",
      "full_name": "dm.vocoder_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Use example of the vocoder function where an impulse train is used as excitation."
    },
    "dm.colored_noise_demo": {
      "prefix": "dm",
      "name": "colored_noise_demo",
      "full_name": "dm.colored_noise_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A coloured noise signal generator."
    },
    "dm.shock_trigger_demo": {
      "prefix": "dm",
      "name": "shock_trigger_demo",
      "full_name": "dm.shock_trigger_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Debounced shock trigger driving a tone. UI:"
    },
    "dm.projected_gravity_demo": {
      "prefix": "dm",
      "name": "projected_gravity_demo",
      "full_name": "dm.projected_gravity_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Gravity projection mapped to a low-pass filter sweep. UI:"
    },
    "dm.total_accel_demo": {
      "prefix": "dm",
      "name": "total_accel_demo",
      "full_name": "dm.total_accel_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Total acceleration envelope mapped to noise amplitude. UI:"
    },
    "dm.orientation6_demo": {
      "prefix": "dm",
      "name": "orientation6_demo",
      "full_name": "dm.orientation6_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 6,
      "description": "Six-axis orientation weights mapped to six tonal channels. UI:"
    },
    "dm.motion_wrapper_demo": {
      "prefix": "dm",
      "name": "motion_wrapper_demo",
      "full_name": "dm.motion_wrapper_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "End-to-end motion feature monitor built on motion.lib:"
    },
    "en.ar": {
      "prefix": "en",
      "name": "ar",
      "full_name": "en.ar",
      "args": [
        "at",
        "rt",
        "t"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "AR (Attack, Release) envelope generator (useful to create percussion envelopes). `ar` is a standard Faust function."
    },
    "en.asr": {
      "prefix": "en",
      "name": "asr",
      "full_name": "en.asr",
      "args": [
        "at",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "ASR (Attack, Sustain, Release) envelope generator. `asr` is a standard Faust function."
    },
    "en.adsr": {
      "prefix": "en",
      "name": "adsr",
      "full_name": "en.adsr",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSR (Attack, Decay, Sustain, Release) envelope generator. `adsr` is a standard Faust function."
    },
    "en.adsrf_bias": {
      "prefix": "en",
      "name": "adsrf_bias",
      "full_name": "en.adsrf_bias",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "final",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSR (Attack, Decay, Sustain, Release, Final) envelope generator with control over bias on each segment, and toggle for legato."
    },
    "en.adsr_bias": {
      "prefix": "en",
      "name": "adsr_bias",
      "full_name": "en.adsr_bias",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSR (Attack, Decay, Sustain, Release) envelope generator with control over bias on each segment, and toggle for legato."
    },
    "en.ahdsrf_bias": {
      "prefix": "en",
      "name": "ahdsrf_bias",
      "full_name": "en.ahdsrf_bias",
      "args": [
        "at",
        "ht",
        "dt",
        "sl",
        "rt",
        "final",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 11,
      "inputs": 0,
      "outputs": 1,
      "description": "AHDSR (Attack, Hold, Decay, Sustain, Release, Final) envelope generator with control over bias on each segment, and toggle for legato."
    },
    "en.ahdsr_bias": {
      "prefix": "en",
      "name": "ahdsr_bias",
      "full_name": "en.ahdsr_bias",
      "args": [
        "at",
        "ht",
        "dt",
        "sl",
        "rt",
        "final",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 11,
      "inputs": 0,
      "outputs": 1,
      "description": "AHDSR (Attack, Hold, Decay, Sustain, Release) envelope generator with control over bias on each segment, and toggle for legato."
    },
    "en.smoothEnvelope": {
      "prefix": "en",
      "name": "smoothEnvelope",
      "full_name": "en.smoothEnvelope",
      "args": [
        "ar",
        "t"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "An envelope with an exponential attack and release. `smoothEnvelope` is a standard Faust function."
    },
    "en.arfe": {
      "prefix": "en",
      "name": "arfe",
      "full_name": "en.arfe",
      "args": [
        "at",
        "rt",
        "fl",
        "t"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "ARFE (Attack and Release-to-Final-value Exponentially) envelope generator. Approximately equal to `smoothEnvelope(Attack/6.91)` when Attack == Release."
    },
    "en.are": {
      "prefix": "en",
      "name": "are",
      "full_name": "en.are",
      "args": [
        "at",
        "rt",
        "t"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "ARE (Attack, Release) envelope generator with Exponential segments. Approximately equal to `smoothEnvelope(Attack/6.91)` when Attack == Release."
    },
    "en.asre": {
      "prefix": "en",
      "name": "asre",
      "full_name": "en.asre",
      "args": [
        "at",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "ASRE (Attack, Sustain, Release) envelope generator with Exponential segments."
    },
    "en.adsre": {
      "prefix": "en",
      "name": "adsre",
      "full_name": "en.adsre",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSRE (Attack, Decay, Sustain, Release) envelope generator with Exponential segments."
    },
    "en.ahdsre": {
      "prefix": "en",
      "name": "ahdsre",
      "full_name": "en.ahdsre",
      "args": [
        "at",
        "ht",
        "dt",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "AHDSRE (Attack, Hold, Decay, Sustain, Release) envelope generator with Exponential segments."
    },
    "en.dx7envelope": {
      "prefix": "en",
      "name": "dx7envelope",
      "full_name": "en.dx7envelope",
      "args": [
        "R1",
        "R2",
        "R3",
        "R4",
        "L1",
        "L2",
        "L3",
        "L4",
        "t"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "DX7 operator envelope generator with 4 independent rates and levels. It is essentially a 4 points BPF."
    },
    "fd.model1D": {
      "prefix": "fd",
      "name": "model1D",
      "full_name": "fd.model1D",
      "args": [
        "points",
        "R",
        "T",
        "scheme"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "This function can be used to obtain a physical model in 1 dimension. Takes a force input signal for each point and outputs the state of each point."
    },
    "fd.model2D": {
      "prefix": "fd",
      "name": "model2D",
      "full_name": "fd.model2D",
      "args": [
        "pointsX",
        "pointsY",
        "R",
        "T",
        "scheme"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "This function can be used to obtain a physical model in 2 dimension. Takes a force input signal for each point and outputs the state of each point."
    },
    "fd.stairsInterp1D": {
      "prefix": "fd",
      "name": "stairsInterp1D",
      "full_name": "fd.stairsInterp1D",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Stairs interpolator in 1 dimension. Takes a number of signals and outputs the same number of signals, where each one is multiplied by zero except the one specified by the argument. This can vary at ru"
    },
    "fd.stairsInterp2D": {
      "prefix": "fd",
      "name": "stairsInterp2D",
      "full_name": "fd.stairsInterp2D",
      "args": [
        "pointsX",
        "pointsY",
        "pointX",
        "pointY"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Stairs interpolator in 2 dimensions. Similar to the 1-D version."
    },
    "fd.linInterp1D": {
      "prefix": "fd",
      "name": "linInterp1D",
      "full_name": "fd.linInterp1D",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 1 dimension. Takes a number of signals and outputs the same number of signals, where each one is multiplied by zero except two signals around a floating point index. This is ess"
    },
    "fd.linInterp2D": {
      "prefix": "fd",
      "name": "linInterp2D",
      "full_name": "fd.linInterp2D",
      "args": [
        "pointsX",
        "pointsY",
        "pointX",
        "pointY"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 2 dimensions. Similar to the 1 D version."
    },
    "fd.stairsInterp1DOut": {
      "prefix": "fd",
      "name": "stairsInterp1DOut",
      "full_name": "fd.stairsInterp1DOut",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Stairs interpolator in 1 dimension. Similar to `stairsInterp1D`, except it outputs only the desired signal."
    },
    "fd.stairsInterp2DOut": {
      "prefix": "fd",
      "name": "stairsInterp2DOut",
      "full_name": "fd.stairsInterp2DOut",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 2 dimensions which outputs only one signal."
    },
    "fd.linInterp1DOut": {
      "prefix": "fd",
      "name": "linInterp1DOut",
      "full_name": "fd.linInterp1DOut",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 1 dimension. Similar to `stairsInterp1D`, except it sums each output signal and provides only one output value."
    },
    "fd.route1D": {
      "prefix": "fd",
      "name": "route1D",
      "full_name": "fd.route1D",
      "args": [
        "points",
        "R",
        "T"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Routing function for 1 dimensional schemes."
    },
    "fd.route2D": {
      "prefix": "fd",
      "name": "route2D",
      "full_name": "fd.route2D",
      "args": [
        "pointsX",
        "pointsY",
        "R",
        "T"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Routing function for 2 dimensional schemes."
    },
    "fd.schemePoint": {
      "prefix": "fd",
      "name": "schemePoint",
      "full_name": "fd.schemePoint",
      "args": [
        "R",
        "T",
        "D"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "This function calculates the next state for each mesh point, in order to form a scheme, several of these blocks need to be stacked in parallel. This function takes in input, in order, the force, the c"
    },
    "fd.buildScheme1D": {
      "prefix": "fd",
      "name": "buildScheme1D",
      "full_name": "fd.buildScheme1D",
      "args": [
        "points",
        "R",
        "T"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "This function is used to stack in parallel several schemePoint functions in 1 dimension, according to the number of points."
    },
    "fd.buildScheme2D": {
      "prefix": "fd",
      "name": "buildScheme2D",
      "full_name": "fd.buildScheme2D",
      "args": [
        "pointsX",
        "pointsY",
        "R",
        "T"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "This function is used to stack in parallel several schemePoint functions in 2 dimensions, according to the number of points in the X and Y directions."
    },
    "fd.hammer": {
      "prefix": "fd",
      "name": "hammer",
      "full_name": "fd.hammer",
      "args": [
        "coeff",
        "omega0Sqr",
        "sigma0",
        "kH",
        "alpha",
        "k",
        "offset",
        "fIn"
      ],
      "arg_count": 8,
      "inputs": 1,
      "outputs": 1,
      "description": "Implementation of a nonlinear collision model. The hammer is essentially a finite difference scheme of a linear damped oscillator, which is coupled with the mesh through the collision model (see Stefa"
    },
    "fd.bow": {
      "prefix": "fd",
      "name": "bow",
      "full_name": "fd.bow",
      "args": [
        "coeff",
        "alpha",
        "k",
        "vb"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Implementation of a nonlinear friction based interaction model that induces Helmholtz motion. (see Stefan Bilbao's book, Numerical Sound Synthesis)."
    },
    "fi.zero": {
      "prefix": "fi",
      "name": "zero",
      "full_name": "fi.zero",
      "args": [
        "z"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One zero filter. Difference equation: \\(y(n) = x(n) - zx(n-1)\\)."
    },
    "fi.pole": {
      "prefix": "fi",
      "name": "pole",
      "full_name": "fi.pole",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One pole filter. Could also be called a \"leaky integrator\". Difference equation: \\(y(n) = x(n) + py(n-1)\\)."
    },
    "fi.integrator": {
      "prefix": "fi",
      "name": "integrator",
      "full_name": "fi.integrator",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Same as `pole(1)` [implemented separately for block-diagram clarity]."
    },
    "fi.dcblockerat": {
      "prefix": "fi",
      "name": "dcblockerat",
      "full_name": "fi.dcblockerat",
      "args": [
        "fb"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "DC blocker with configurable \"break frequency\". The amplitude response is substantially flat above `fb`, and sloped at about +6 dB/octave below `fb`."
    },
    "fi.dcblocker": {
      "prefix": "fi",
      "name": "dcblocker",
      "full_name": "fi.dcblocker",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "DC blocker. Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz) and high-frequency gain near 1.0025 (due to no scaling). `dcblocker` is as standard Faust function."
    },
    "fi.lptN": {
      "prefix": "fi",
      "name": "lptN",
      "full_name": "fi.lptN",
      "args": [
        "N",
        "tN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass filter with arbitrary dis/charging factors set in dB and times set in seconds."
    },
    "fi.lptau": {
      "prefix": "fi",
      "name": "lptau",
      "full_name": "fi.lptau",
      "args": [
        "tN"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass with a tau time constant (1/e attenuation after `tN` seconds)."
    },
    "fi.lpt60": {
      "prefix": "fi",
      "name": "lpt60",
      "full_name": "fi.lpt60",
      "args": [
        "tN"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass with a T60 time constant (60 dB attenuation after `tN` seconds)."
    },
    "fi.lpt19": {
      "prefix": "fi",
      "name": "lpt19",
      "full_name": "fi.lpt19",
      "args": [
        "tN"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass with a T19 time constant (approx. 19 dB attenuation after `tN` seconds)."
    },
    "fi.ff_comb": {
      "prefix": "fi",
      "name": "ff_comb",
      "full_name": "fi.ff_comb",
      "args": [
        "maxdel",
        "intdel",
        "b0",
        "bM"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Forward Comb Filter. Note that `ff_comb` requires integer delays (uses `delay`  internally). `ff_comb` is a standard Faust function."
    },
    "fi.ff_fcomb": {
      "prefix": "fi",
      "name": "ff_fcomb",
      "full_name": "fi.ff_fcomb",
      "args": [
        "maxdel",
        "del",
        "b0",
        "bM"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Forward Comb Filter. Note that `ff_fcomb` takes floating-point delays (uses `fdelay` internally). `ff_fcomb` is a standard Faust function."
    },
    "fi.ffcombfilter": {
      "prefix": "fi",
      "name": "ffcombfilter",
      "full_name": "fi.ffcombfilter",
      "args": [
        "maxdel",
        "del",
        "g"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Typical special case of `ff_comb()` where: `b0 = 1`."
    },
    "fi.fb_comb_common": {
      "prefix": "fi",
      "name": "fb_comb_common",
      "full_name": "fi.fb_comb_common",
      "args": [
        "dop",
        "N",
        "b0",
        "aN"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "A generic feedback comb filter."
    },
    "fi.fb_comb": {
      "prefix": "fi",
      "name": "fb_comb",
      "full_name": "fi.fb_comb",
      "args": [
        "maxdel",
        "del",
        "b0",
        "aN"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Back Comb Filter (integer delay)."
    },
    "fi.fb_fcomb": {
      "prefix": "fi",
      "name": "fb_fcomb",
      "full_name": "fi.fb_fcomb",
      "args": [
        "maxdel",
        "del",
        "b0",
        "aN"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Back Comb Filter (floating point delay)."
    },
    "fi.rev1": {
      "prefix": "fi",
      "name": "rev1",
      "full_name": "fi.rev1",
      "args": [
        "maxdel",
        "N",
        "g"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Special case of `fb_comb` (`rev1(maxdel,N,g)`). The \"rev1 section\" dates back to the 1960s in computer-music reverberation. See the `jcrev` and `brassrev` in `reverbs.lib` for usage examples."
    },
    "fi.fbcombfilter": {
      "prefix": "fi",
      "name": "fbcombfilter",
      "full_name": "fi.fbcombfilter",
      "args": [
        "maxdel",
        "intdel",
        "g"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Other special cases of Feed-Back Comb Filter."
    },
    "fi.allpass_comb": {
      "prefix": "fi",
      "name": "allpass_comb",
      "full_name": "fi.allpass_comb",
      "args": [
        "maxdel",
        "intdel",
        "aN"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Schroeder Allpass Comb Filter. Note that:"
    },
    "fi.allpass_fcomb": {
      "prefix": "fi",
      "name": "allpass_fcomb",
      "full_name": "fi.allpass_fcomb",
      "args": [
        "maxdel",
        "intdel",
        "aN"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Schroeder Allpass Comb Filter. Note that:"
    },
    "fi.rev2": {
      "prefix": "fi",
      "name": "rev2",
      "full_name": "fi.rev2",
      "args": [
        "maxlen",
        "len",
        "g"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Special case of `allpass_comb` (`rev2(maxlen,len,g)`). The \"rev2 section\" dates back to the 1960s in computer-music reverberation. See the `jcrev` and `brassrev` in `reverbs.lib` for usage examples."
    },
    "fi.allpass_fcomb5": {
      "prefix": "fi",
      "name": "allpass_fcomb5",
      "full_name": "fi.allpass_fcomb5",
      "args": [
        "maxdel",
        "N",
        "aN"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as `allpass_fcomb` but use `fdelay5` and `fdelay1a` internally (Interpolation helps - look at an fft of faust2octave on: `1-1' <: allpass_fcomb(1024,10.5,0.95), allpass_fcomb5(1024,10.5,0.95);`)"
    },
    "fi.iir": {
      "prefix": "fi",
      "name": "iir",
      "full_name": "fi.iir",
      "args": [
        "bcoeffs",
        "acoeffs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Nth-order Infinite-Impulse-Response (IIR) digital filter, implemented in terms of the Transfer-Function (TF) coefficients. Such filter structures are termed \"direct form\"."
    },
    "fi.fir": {
      "prefix": "fi",
      "name": "fir",
      "full_name": "fi.fir",
      "args": [
        "bv"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "FIR filter (convolution of FIR filter coefficients with a signal). `fir` is standard Faust function."
    },
    "fi.conv": {
      "prefix": "fi",
      "name": "conv",
      "full_name": "fi.conv",
      "args": [
        "N",
        "(k1",
        "k2",
        "k3",
        "..."
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Convolution of input signal with given coefficients."
    },
    "fi.tf1": {
      "prefix": "fi",
      "name": "tf1",
      "full_name": "fi.tf1",
      "args": [
        "b0",
        "b1",
        "a1"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "tfN = N'th-order direct-form digital filter."
    },
    "fi.notchw": {
      "prefix": "fi",
      "name": "notchw",
      "full_name": "fi.notchw",
      "args": [
        "width",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple notch filter based on a biquad (`tf2`). `notchw` is a standard Faust function."
    },
    "fi.tf21": {
      "prefix": "fi",
      "name": "tf21",
      "full_name": "fi.tf21",
      "args": [
        "b0",
        "b1",
        "b2",
        "a1",
        "a2"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "tfN = N'th-order direct-form digital filter where:"
    },
    "fi.av2sv": {
      "prefix": "fi",
      "name": "av2sv",
      "full_name": "fi.av2sv",
      "args": [
        "av"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Compute reflection coefficients sv from transfer-function denominator av."
    },
    "fi.bvav2nuv": {
      "prefix": "fi",
      "name": "bvav2nuv",
      "full_name": "fi.bvav2nuv",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Compute lattice tap coefficients from transfer-function coefficients."
    },
    "fi.iir_lat2": {
      "prefix": "fi",
      "name": "iir_lat2",
      "full_name": "fi.iir_lat2",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-multiply lattice IIR filter of arbitrary order."
    },
    "fi.allpassnt": {
      "prefix": "fi",
      "name": "allpassnt",
      "full_name": "fi.allpassnt",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-multiply lattice allpass (nested order-1 direct-form-ii allpasses), with taps."
    },
    "fi.iir_kl": {
      "prefix": "fi",
      "name": "iir_kl",
      "full_name": "fi.iir_kl",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Kelly-Lochbaum ladder IIR filter of arbitrary order."
    },
    "fi.allpassnklt": {
      "prefix": "fi",
      "name": "allpassnklt",
      "full_name": "fi.allpassnklt",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Kelly-Lochbaum ladder allpass."
    },
    "fi.iir_lat1": {
      "prefix": "fi",
      "name": "iir_lat1",
      "full_name": "fi.iir_lat1",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-multiply lattice IIR filter of arbitrary order."
    },
    "fi.allpassn1mt": {
      "prefix": "fi",
      "name": "allpassn1mt",
      "full_name": "fi.allpassn1mt",
      "args": [
        "N",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-multiply lattice allpass with tap lines."
    },
    "fi.iir_nl": {
      "prefix": "fi",
      "name": "iir_nl",
      "full_name": "fi.iir_nl",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Normalized ladder filter of arbitrary order."
    },
    "fi.allpassnnlt": {
      "prefix": "fi",
      "name": "allpassnnlt",
      "full_name": "fi.allpassnnlt",
      "args": [
        "N",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Normalized ladder allpass filter of arbitrary order."
    },
    "fi.tf2np": {
      "prefix": "fi",
      "name": "tf2np",
      "full_name": "fi.tf2np",
      "args": [
        "b0",
        "b1",
        "b2",
        "a1",
        "a2"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Biquad based on a stable second-order Normalized Ladder Filter (more robust to modulation than `tf2` and protected against instability)."
    },
    "fi.wgr": {
      "prefix": "fi",
      "name": "wgr",
      "full_name": "fi.wgr",
      "args": [
        "f",
        "r"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order transformer-normalized digital waveguide resonator."
    },
    "fi.nlf2": {
      "prefix": "fi",
      "name": "nlf2",
      "full_name": "fi.nlf2",
      "args": [
        "f",
        "r"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Second order normalized digital waveguide resonator."
    },
    "fi.apnl": {
      "prefix": "fi",
      "name": "apnl",
      "full_name": "fi.apnl",
      "args": [
        "a1",
        "a2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Passive Nonlinear Allpass based on Pierce switching springs idea. Switch between allpass coefficient `a1` and `a2` at signal zero crossings."
    },
    "fi.scatN": {
      "prefix": "fi",
      "name": "scatN",
      "full_name": "fi.scatN",
      "args": [
        "N",
        "av",
        "filter"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "N-port scattering junction."
    },
    "fi.scat": {
      "prefix": "fi",
      "name": "scat",
      "full_name": "fi.scat",
      "args": [
        "s",
        "r"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Scatter off of reflectance r with reflection coefficient s."
    },
    "fi.allpassn": {
      "prefix": "fi",
      "name": "allpassn",
      "full_name": "fi.allpassn",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-multiply lattice filter."
    },
    "fi.allpassnn": {
      "prefix": "fi",
      "name": "allpassnn",
      "full_name": "fi.allpassnn",
      "args": [
        "n",
        "tv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Normalized form - four multiplies and two adds per section, but coefficients can be time varying and nonlinear without \"parametric amplification\" (modulation of signal energy)."
    },
    "fi.allpassnkl": {
      "prefix": "fi",
      "name": "allpassnkl",
      "full_name": "fi.allpassnkl",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Kelly-Lochbaum form - four multiplies and two adds per section, but all signals have an immediate physical interpretation as traveling pressure waves, etc."
    },
    "fi.allpass1m": {
      "prefix": "fi",
      "name": "allpass1m",
      "full_name": "fi.allpass1m",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-multiply form - one multiply and three adds per section. Normally the most efficient in special-purpose hardware."
    },
    "fi.tf2s": {
      "prefix": "fi",
      "name": "tf2s",
      "full_name": "fi.tf2s",
      "args": [
        "b2",
        "b1",
        "b0",
        "a1",
        "a0",
        "w1"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order direct-form digital filter, specified by ANALOG transfer-function polynomials B(s)/A(s), and a frequency-scaling parameter. Digitization via the"
    },
    "fi.tf1snp": {
      "prefix": "fi",
      "name": "tf1snp",
      "full_name": "fi.tf1snp",
      "args": [
        "b1",
        "b0",
        "a0"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order special case of tf2snp above."
    },
    "fi.tf3slf": {
      "prefix": "fi",
      "name": "tf3slf",
      "full_name": "fi.tf3slf",
      "args": [
        "b3",
        "b2",
        "b1",
        "b0",
        "a3",
        "a2",
        "a1",
        "a0"
      ],
      "arg_count": 8,
      "inputs": 1,
      "outputs": 1,
      "description": "Analogous to `tf2s` above, but third order, and using the typical low-frequency-matching bilinear-transform constant 2/T (\"lf\" series) instead of the specific-frequency-matching value used in `tf2s` a"
    },
    "fi.tf1s": {
      "prefix": "fi",
      "name": "tf1s",
      "full_name": "fi.tf1s",
      "args": [
        "b1",
        "b0",
        "a0",
        "w1"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order direct-form digital filter, specified by ANALOG transfer-function polynomials B(s)/A(s), and a frequency-scaling parameter."
    },
    "fi.tf2sb": {
      "prefix": "fi",
      "name": "tf2sb",
      "full_name": "fi.tf2sb",
      "args": [
        "b2",
        "b1",
        "b0",
        "a1",
        "a0",
        "w1",
        "wc"
      ],
      "arg_count": 7,
      "inputs": 1,
      "outputs": 1,
      "description": "Bandpass mapping of `tf2s`: In addition to a frequency-scaling parameter `w1` (set to HALF the desired passband width in rad/sec), there is a desired center-frequency parameter wc (also in rad/s)."
    },
    "fi.tf1sb": {
      "prefix": "fi",
      "name": "tf1sb",
      "full_name": "fi.tf1sb",
      "args": [
        "b1",
        "b0",
        "a0",
        "w1",
        "wc"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "First-to-second-order lowpass-to-bandpass section mapping, analogous to tf2sb above."
    },
    "fi.resonlp": {
      "prefix": "fi",
      "name": "resonlp",
      "full_name": "fi.resonlp",
      "args": [
        "fc",
        "Q",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple resonant lowpass filter based on `tf2s` (virtual analog). `resonlp` is a standard Faust function."
    },
    "fi.resonhp": {
      "prefix": "fi",
      "name": "resonhp",
      "full_name": "fi.resonhp",
      "args": [
        "fc",
        "Q",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple resonant highpass filters based on `tf2s` (virtual analog). `resonhp` is a standard Faust function."
    },
    "fi.resonbp": {
      "prefix": "fi",
      "name": "resonbp",
      "full_name": "fi.resonbp",
      "args": [
        "fc",
        "Q",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple resonant bandpass filters based on `tf2s` (virtual analog). `resonbp` is a standard Faust function."
    },
    "fi.lowpass": {
      "prefix": "fi",
      "name": "lowpass",
      "full_name": "fi.lowpass",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Nth-order Butterworth lowpass filter. `lowpass` is a standard Faust function."
    },
    "fi.highpass": {
      "prefix": "fi",
      "name": "highpass",
      "full_name": "fi.highpass",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Nth-order Butterworth highpass filter. `highpass` is a standard Faust function."
    },
    "fi.lowpass0_highpass1": {
      "prefix": "fi",
      "name": "lowpass0_highpass1",
      "full_name": "fi.lowpass0_highpass1",
      "args": [
        "s",
        "N",
        "fc"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.highpass_plus_lowpass": {
      "prefix": "fi",
      "name": "highpass_plus_lowpass",
      "full_name": "fi.highpass_plus_lowpass",
      "args": [
        "1",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.highpass_minus_lowpass": {
      "prefix": "fi",
      "name": "highpass_minus_lowpass",
      "full_name": "fi.highpass_minus_lowpass",
      "args": [
        "3",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.highpass_plus_lowpass_even": {
      "prefix": "fi",
      "name": "highpass_plus_lowpass_even",
      "full_name": "fi.highpass_plus_lowpass_even",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.highpass_minus_lowpass_odd": {
      "prefix": "fi",
      "name": "highpass_minus_lowpass_odd",
      "full_name": "fi.highpass_minus_lowpass_odd",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.lowpass3e": {
      "prefix": "fi",
      "name": "lowpass3e",
      "full_name": "fi.lowpass3e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Third-order Elliptic (Cauer) lowpass filter."
    },
    "fi.lowpass6e": {
      "prefix": "fi",
      "name": "lowpass6e",
      "full_name": "fi.lowpass6e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sixth-order Elliptic/Cauer lowpass filter."
    },
    "fi.highpass3e": {
      "prefix": "fi",
      "name": "highpass3e",
      "full_name": "fi.highpass3e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Third-order Elliptic (Cauer) highpass filter. Inversion of `lowpass3e` wrt unit circle in s plane (s <- 1/s)."
    },
    "fi.highpass6e": {
      "prefix": "fi",
      "name": "highpass6e",
      "full_name": "fi.highpass6e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sixth-order Elliptic/Cauer highpass filter. Inversion of `lowpass3e` wrt unit circle in s plane (s <- 1/s)."
    },
    "fi.bandpass": {
      "prefix": "fi",
      "name": "bandpass",
      "full_name": "fi.bandpass",
      "args": [
        "Nh",
        "fl",
        "fu"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Order 2*Nh Butterworth bandpass filter made using the transformation `s <- s + wc^2/s` on `lowpass(Nh)`, where `wc` is the desired bandpass center frequency.  The `lowpass(Nh)` cutoff `w1` is half the"
    },
    "fi.bandstop": {
      "prefix": "fi",
      "name": "bandstop",
      "full_name": "fi.bandstop",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.bandpass6e": {
      "prefix": "fi",
      "name": "bandpass6e",
      "full_name": "fi.bandpass6e",
      "args": [
        "fl",
        "fu"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Order 12 elliptic bandpass filter analogous to `bandpass(6)`."
    },
    "fi.bandpass12e": {
      "prefix": "fi",
      "name": "bandpass12e",
      "full_name": "fi.bandpass12e",
      "args": [
        "fl",
        "fu"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Order 24 elliptic bandpass filter analogous to `bandpass(6)`."
    },
    "fi.pospass": {
      "prefix": "fi",
      "name": "pospass",
      "full_name": "fi.pospass",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 2,
      "description": "Positive-Pass Filter (single-side-band filter)."
    },
    "fi.lowshelf": {
      "prefix": "fi",
      "name": "lowshelf",
      "full_name": "fi.lowshelf",
      "args": [
        "N",
        "L0",
        "fx"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order \"low shelf\" filter (gain boost|cut between dc and some frequency) `low_shelf` is a standard Faust function."
    },
    "fi.low_shelf": {
      "prefix": "fi",
      "name": "low_shelf",
      "full_name": "fi.low_shelf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.low_shelf1_l": {
      "prefix": "fi",
      "name": "low_shelf1_l",
      "full_name": "fi.low_shelf1_l",
      "args": [
        "G0",
        "fx",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.lowshelf_other_freq": {
      "prefix": "fi",
      "name": "lowshelf_other_freq",
      "full_name": "fi.lowshelf_other_freq",
      "args": [
        "N",
        "L0",
        "fx"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); lowshelf_other_freq_test = fi.lowshelf_other_freq(3, 6, 500);"
    },
    "fi.high_shelf": {
      "prefix": "fi",
      "name": "high_shelf",
      "full_name": "fi.high_shelf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.high_shelf1": {
      "prefix": "fi",
      "name": "high_shelf1",
      "full_name": "fi.high_shelf1",
      "args": [
        "Lpi",
        "fx",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.high_shelf1_l": {
      "prefix": "fi",
      "name": "high_shelf1_l",
      "full_name": "fi.high_shelf1_l",
      "args": [
        "Gpi",
        "fx",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.highshelf_other_freq": {
      "prefix": "fi",
      "name": "highshelf_other_freq",
      "full_name": "fi.highshelf_other_freq",
      "args": [
        "N",
        "Lpi",
        "fx"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); highshelf_other_freq_test = fi.highshelf_other_freq(3, 6, 2000);"
    },
    "fi.peak_eq": {
      "prefix": "fi",
      "name": "peak_eq",
      "full_name": "fi.peak_eq",
      "args": [
        "Lfx",
        "fx",
        "B"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Second order \"peaking equalizer\" section (gain boost or cut near some frequency) Also called a \"parametric equalizer\" section. `peak_eq` is a standard Faust function."
    },
    "fi.peak_eq_cq": {
      "prefix": "fi",
      "name": "peak_eq_cq",
      "full_name": "fi.peak_eq_cq",
      "args": [
        "Lfx",
        "fx",
        "Q"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Constant-Q second order peaking equalizer section."
    },
    "fi.peak_eq_rm": {
      "prefix": "fi",
      "name": "peak_eq_rm",
      "full_name": "fi.peak_eq_rm",
      "args": [
        "Lfx",
        "fx",
        "tanPiBT"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Regalia-Mitra second order peaking equalizer section."
    },
    "fi.spectral_tilt": {
      "prefix": "fi",
      "name": "spectral_tilt",
      "full_name": "fi.spectral_tilt",
      "args": [
        "N",
        "f0",
        "bw",
        "alpha"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Spectral tilt filter, providing an arbitrary spectral rolloff factor alpha in (-1,1), where -1 corresponds to one pole (-6 dB per octave), and"
    },
    "fi.levelfilter": {
      "prefix": "fi",
      "name": "levelfilter",
      "full_name": "fi.levelfilter",
      "args": [
        "L",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Dynamic level lowpass filter. `levelfilter` is a standard Faust function."
    },
    "fi.levelfilterN": {
      "prefix": "fi",
      "name": "levelfilterN",
      "full_name": "fi.levelfilterN",
      "args": [
        "N",
        "freq",
        "L"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Dynamic level lowpass filter."
    },
    "fi.O": {
      "prefix": "fi",
      "name": "O",
      "full_name": "fi.O",
      "args": [
        "O",
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Allpass-complementary filter banks based on Butterworth band-splitting. For Butterworth band-splits, the needed delay equalizer is easily found."
    },
    "fi.mth_octave_filterbank_alt": {
      "prefix": "fi",
      "name": "mth_octave_filterbank_alt",
      "full_name": "fi.mth_octave_filterbank_alt",
      "args": [
        "O",
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.mth_octave_filterbank3": {
      "prefix": "fi",
      "name": "mth_octave_filterbank3",
      "full_name": "fi.mth_octave_filterbank3",
      "args": [
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.mth_octave_filterbank5": {
      "prefix": "fi",
      "name": "mth_octave_filterbank5",
      "full_name": "fi.mth_octave_filterbank5",
      "args": [
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.mth_octave_filterbank_default": {
      "prefix": "fi",
      "name": "mth_octave_filterbank_default",
      "full_name": "fi.mth_octave_filterbank_default",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");"
    },
    "fi.filterbank": {
      "prefix": "fi",
      "name": "filterbank",
      "full_name": "fi.filterbank",
      "args": [
        "O",
        "freqs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Filter bank. `filterbank` is a standard Faust function."
    },
    "fi.filterbanki": {
      "prefix": "fi",
      "name": "filterbanki",
      "full_name": "fi.filterbanki",
      "args": [
        "O",
        "freqs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Inverted-dc filter bank."
    },
    "fi.svf": {
      "prefix": "fi",
      "name": "svf",
      "full_name": "fi.svf",
      "args": [
        "T",
        "F",
        "Q",
        "G"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "An environment with `lp`, `bp`, `hp`, `notch`, `peak`, `ap`, `bell`, `ls`, `hs` SVF based filters. All filters have `freq` and `Q` parameters, the `bell`, `ls`, `hs` ones also have a `gain` third para"
    },
    "fi.svf_morph": {
      "prefix": "fi",
      "name": "svf_morph",
      "full_name": "fi.svf_morph",
      "args": [
        "freq",
        "Q",
        "blend"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "An SVF-based filter that can smoothly morph between being lowpass, bandpass, and highpass."
    },
    "fi.svf_notch_morph": {
      "prefix": "fi",
      "name": "svf_notch_morph",
      "full_name": "fi.svf_notch_morph",
      "args": [
        "freq",
        "Q",
        "blend"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "An SVF-based notch-filter that can smoothly morph between being lowpass, notch, and highpass."
    },
    "fi.SVFTPT": {
      "prefix": "fi",
      "name": "SVFTPT",
      "full_name": "fi.SVFTPT",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Topology-preserving transform implementation following Zavalishin's method."
    },
    "fi.dynamicSmoothing": {
      "prefix": "fi",
      "name": "dynamicSmoothing",
      "full_name": "fi.dynamicSmoothing",
      "args": [
        "sensitivity",
        "baseCF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Adaptive smoother based on Andy Simper's paper."
    },
    "fi.oneEuro": {
      "prefix": "fi",
      "name": "oneEuro",
      "full_name": "fi.oneEuro",
      "args": [
        "derivativeCutoff",
        "beta",
        "minCutoff"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "The One Euro Filter (1\u20ac Filter) is an adaptive lowpass filter. This kind of filter is commonly used in object-tracking, not necessarily audio processing."
    },
    "fi.lowpassLR4": {
      "prefix": "fi",
      "name": "lowpassLR4",
      "full_name": "fi.lowpassLR4",
      "args": [
        "cf"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "4th-order Linkwitz-Riley lowpass."
    },
    "fi.highpassLR4": {
      "prefix": "fi",
      "name": "highpassLR4",
      "full_name": "fi.highpassLR4",
      "args": [
        "cf"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "4th-order Linkwitz-Riley highpass."
    },
    "fi.crossover2LR4": {
      "prefix": "fi",
      "name": "crossover2LR4",
      "full_name": "fi.crossover2LR4",
      "args": [
        "cf"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-way 4th-order Linkwitz-Riley crossover."
    },
    "fi.crossover3LR4": {
      "prefix": "fi",
      "name": "crossover3LR4",
      "full_name": "fi.crossover3LR4",
      "args": [
        "cf1",
        "cf2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Three-way 4th-order Linkwitz-Riley crossover."
    },
    "fi.crossover4LR4": {
      "prefix": "fi",
      "name": "crossover4LR4",
      "full_name": "fi.crossover4LR4",
      "args": [
        "cf1",
        "cf2",
        "cf3"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Four-way 4th-order Linkwitz-Riley crossover."
    },
    "fi.crossover8LR4": {
      "prefix": "fi",
      "name": "crossover8LR4",
      "full_name": "fi.crossover8LR4",
      "args": [
        "cf1",
        "cf2",
        "cf3",
        "cf4",
        "cf5",
        "cf6",
        "cf7"
      ],
      "arg_count": 7,
      "inputs": 1,
      "outputs": 1,
      "description": "Eight-way 4th-order Linkwitz-Riley crossover."
    },
    "fi.itu_r_bs_1770_4_kfilter": {
      "prefix": "fi",
      "name": "itu_r_bs_1770_4_kfilter",
      "full_name": "fi.itu_r_bs_1770_4_kfilter",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "The prefilter from Recommendation ITU-R BS.1770-4 for loudness measurement. Also known as \"K-filter\". The recommendation defines biquad filter coefficients for a fixed sample rate of 48kHz (page"
    },
    "fi.avg_rect": {
      "prefix": "fi",
      "name": "avg_rect",
      "full_name": "fi.avg_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Moving average."
    },
    "fi.avg_tau": {
      "prefix": "fi",
      "name": "avg_tau",
      "full_name": "fi.avg_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Averaging function based on a one-pole filter and the tau response time. Tau represents the effective length of the one-pole impulse response, that is, tau is the integral of the filter's impulse resp"
    },
    "fi.avg_t60": {
      "prefix": "fi",
      "name": "avg_t60",
      "full_name": "fi.avg_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Averaging function based on a one-pole filter and the t60 response time. This response is particularly useful when the system is required to reach the final value after about `period` seconds."
    },
    "fi.avg_t19": {
      "prefix": "fi",
      "name": "avg_t19",
      "full_name": "fi.avg_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Averaging function based on a one-pole filter and the t19 response time. This response is close to the moving-average algorithm as it roughly reaches the final value after `period` seconds and shows a"
    },
    "fi.kalman": {
      "prefix": "fi",
      "name": "kalman",
      "full_name": "fi.kalman",
      "args": [
        "N",
        "M",
        "B",
        "R",
        "H",
        "Q",
        "F",
        "reset",
        "u",
        "z"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "The Kalman filter. It returns the state (a bus of size `N`). Note that the only compile-time constant arguments are `N` and `M`. Other arguments are capitalized because they're matrices, and it makes"
    },
    "ho.encoder": {
      "prefix": "ho",
      "name": "encoder",
      "full_name": "ho.encoder",
      "args": [
        "N",
        "x",
        "a"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Ambisonic encoder. Encodes a signal in the circular harmonics domain depending on an order of decomposition and an angle."
    },
    "ho.rEncoder": {
      "prefix": "ho",
      "name": "rEncoder",
      "full_name": "ho.rEncoder",
      "args": [
        "N",
        "sp",
        "a",
        "it"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 2,
      "description": "Ambisonic encoder in 2D including source rotation. A mono signal is encoded at a certain ambisonic order with two possible modes: either rotation with an angular speed, or static with a fixed angle (w"
    },
    "ho.stereoEncoder": {
      "prefix": "ho",
      "name": "stereoEncoder",
      "full_name": "ho.stereoEncoder",
      "args": [
        "N",
        "a"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Encoding of a stereo pair of channels with symetric angles (a/2, -a/2)."
    },
    "ho.multiEncoder": {
      "prefix": "ho",
      "name": "multiEncoder",
      "full_name": "ho.multiEncoder",
      "args": [
        "N",
        "lspeed",
        "langle",
        "it"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Encoding of a set of P signals distributed on the unit circle according to a list of P speeds and P angles."
    },
    "ho.decoder": {
      "prefix": "ho",
      "name": "decoder",
      "full_name": "ho.decoder",
      "args": [
        "N",
        "P"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Decodes an ambisonics sound field for a circular array of loudspeakers."
    },
    "ho.decoderStereo": {
      "prefix": "ho",
      "name": "decoderStereo",
      "full_name": "ho.decoderStereo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Decodes an ambisonic sound field for stereophonic configuration. An \"home made\" ambisonic decoder for stereophonic restitution (30\u00b0 - 330\u00b0): Sound field lose energy around 180\u00b0. You should"
    },
    "ho.iBasicDecoder": {
      "prefix": "ho",
      "name": "iBasicDecoder",
      "full_name": "ho.iBasicDecoder",
      "args": [
        "N",
        "la",
        "direct",
        "shift"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "The irregular basic decoder is a simple decoder that projects the incoming ambisonic situation to the loudspeaker situation (P loudspeakers) whatever it is, without compensation. When there is a stron"
    },
    "ho.circularScaledVBAP": {
      "prefix": "ho",
      "name": "circularScaledVBAP",
      "full_name": "ho.circularScaledVBAP",
      "args": [
        "l",
        "t"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 2,
      "description": "The function provides a circular scaled VBAP with all loudspeakers and the virtual source on the unit-circle."
    },
    "ho.imlsDecoder": {
      "prefix": "ho",
      "name": "imlsDecoder",
      "full_name": "ho.imlsDecoder",
      "args": [
        "N",
        "la",
        "direct",
        "shift"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Irregular decoder in 2D for an irregular configuration of P loudspeakers using 2D VBAP for compensation."
    },
    "ho.iDecoder": {
      "prefix": "ho",
      "name": "iDecoder",
      "full_name": "ho.iDecoder",
      "args": [
        "N",
        "la",
        "direct",
        "st",
        "g"
      ],
      "arg_count": 5,
      "inputs": 2,
      "outputs": 2,
      "description": "General decoder in 2D enabling an irregular multi-loudspeaker configuration and to switch between multi-channel and stereo."
    },
    "ho.optimBasic": {
      "prefix": "ho",
      "name": "optimBasic",
      "full_name": "ho.optimBasic",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The basic optimization has no effect and should be used for a perfect circle of loudspeakers with one listener at the perfect center loudspeakers array."
    },
    "ho.optimMaxRe": {
      "prefix": "ho",
      "name": "optimMaxRe",
      "full_name": "ho.optimMaxRe",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The maxRe optimization optimizes energy vector. It should be used for an auditory confined in the center of the loudspeakers array."
    },
    "ho.optimInPhase": {
      "prefix": "ho",
      "name": "optimInPhase",
      "full_name": "ho.optimInPhase",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The inPhase optimization optimizes energy vector and put all loudspeakers signals in phase. It should be used for an auditory."
    },
    "ho.optim": {
      "prefix": "ho",
      "name": "optim",
      "full_name": "ho.optim",
      "args": [
        "N",
        "ot"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Ambisonic optimizer including the three elementary optimizers: `(ho).optimBasic`, `(ho).optimMaxRe` and `(ho.)optimInPhase`."
    },
    "ho.wider": {
      "prefix": "ho",
      "name": "wider",
      "full_name": "ho.wider",
      "args": [
        "N",
        "w"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Can be used to wide the diffusion of a localized sound. The order depending signals are weighted and appear in a logarithmic way to have linear changes."
    },
    "ho.mirror": {
      "prefix": "ho",
      "name": "mirror",
      "full_name": "ho.mirror",
      "args": [
        "N",
        "fa"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Mirroring effect on the sound field."
    },
    "ho.map": {
      "prefix": "ho",
      "name": "map",
      "full_name": "ho.map",
      "args": [
        "N",
        "x",
        "r",
        "a"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "It simulates the distance of the source by applying a gain on the signal and a wider processing on the soundfield."
    },
    "ho.rotate": {
      "prefix": "ho",
      "name": "rotate",
      "full_name": "ho.rotate",
      "args": [
        "N",
        "a"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Rotates the sound field."
    },
    "ho.scope": {
      "prefix": "ho",
      "name": "scope",
      "full_name": "ho.scope",
      "args": [
        "N",
        "rt"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Produces an XY pair of signals representing the ambisonic sound field."
    },
    "ho.fxDecorrelation": {
      "prefix": "ho",
      "name": "fxDecorrelation",
      "full_name": "ho.fxDecorrelation",
      "args": [
        "N",
        "d",
        "wf",
        "fa",
        "fd",
        "tf"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ambisonic decorrelation in fx mode."
    },
    "ho.synDecorrelation": {
      "prefix": "ho",
      "name": "synDecorrelation",
      "full_name": "ho.synDecorrelation",
      "args": [
        "N",
        "d",
        "wf",
        "fa",
        "fd",
        "tf"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ambisonic decorrelation in syn mode."
    },
    "ho.fxRingMod": {
      "prefix": "ho",
      "name": "fxRingMod",
      "full_name": "ho.fxRingMod",
      "args": [
        "N",
        "f0",
        "fa",
        "tf"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ring modulation in syn mode."
    },
    "ho.synRingMod": {
      "prefix": "ho",
      "name": "synRingMod",
      "full_name": "ho.synRingMod",
      "args": [
        "N",
        "f0",
        "fa",
        "tf"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ring modulation in syn mode."
    },
    "ho.encoder3D": {
      "prefix": "ho",
      "name": "encoder3D",
      "full_name": "ho.encoder3D",
      "args": [
        "N",
        "x",
        "a",
        "e"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Ambisonic encoder. Encodes a signal in the circular harmonics domain depending on an order of decomposition, an angle and an elevation."
    },
    "ho.rEncoder3D": {
      "prefix": "ho",
      "name": "rEncoder3D",
      "full_name": "ho.rEncoder3D",
      "args": [
        "N",
        "azsp",
        "elsp",
        "az",
        "el",
        "it"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 2,
      "description": "Ambisonic encoder in 3D including source rotation. A mono signal is encoded at at certain ambisonic order with two possible modes: either rotation with 2 angular speeds (azimuth and elevation), or sta"
    },
    "ho.optimBasic3D": {
      "prefix": "ho",
      "name": "optimBasic3D",
      "full_name": "ho.optimBasic3D",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The basic optimization has no effect and should be used for a perfect sphere of loudspeakers with one listener at the perfect center loudspeakers array."
    },
    "ho.optimMaxRe3D": {
      "prefix": "ho",
      "name": "optimMaxRe3D",
      "full_name": "ho.optimMaxRe3D",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The maxRe optimization optimize energy vector. It should be used for an auditory confined in the center of the loudspeakers array."
    },
    "ho.optimInPhase3D": {
      "prefix": "ho",
      "name": "optimInPhase3D",
      "full_name": "ho.optimInPhase3D",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The inPhase Optimization optimizes energy vector and put all loudspeakers signals in phase. It should be used for an auditory."
    },
    "ho.optim3D": {
      "prefix": "ho",
      "name": "optim3D",
      "full_name": "ho.optim3D",
      "args": [
        "N",
        "ot"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Ambisonic optimizer including the three elementary optimizers: `(ho).optimBasic3D`, `(ho).optimMaxRe3D` and `(ho.)optimInPhase3D`."
    },
    "it.interpolate_linear": {
      "prefix": "it",
      "name": "interpolate_linear",
      "full_name": "it.interpolate_linear",
      "args": [
        "dv",
        "v0",
        "v1"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolation between 2 values."
    },
    "it.interpolate_cosine": {
      "prefix": "it",
      "name": "interpolate_cosine",
      "full_name": "it.interpolate_cosine",
      "args": [
        "dv",
        "v0",
        "v1"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine interpolation between 2 values."
    },
    "it.interpolate_cubic": {
      "prefix": "it",
      "name": "interpolate_cubic",
      "full_name": "it.interpolate_cubic",
      "args": [
        "dv",
        "v0",
        "v1",
        "v2",
        "v3"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Cubic interpolation between 4 values."
    },
    "it.interpolator_two_points": {
      "prefix": "it",
      "name": "interpolator_two_points",
      "full_name": "it.interpolator_two_points",
      "args": [
        "gen",
        "idv",
        "interpolate_two_points"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic interpolator on two points (current and next index), assuming an increasing index."
    },
    "it.interpolator_linear": {
      "prefix": "it",
      "name": "interpolator_linear",
      "full_name": "it.interpolator_linear",
      "args": [
        "gen",
        "idv"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator for a 'gen' circuit triggered by an 'idv' input to generate values."
    },
    "it.interpolator_cosine": {
      "prefix": "it",
      "name": "interpolator_cosine",
      "full_name": "it.interpolator_cosine",
      "args": [
        "gen",
        "idv"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine interpolator for a 'gen' circuit triggered by an 'idv' input to generate values."
    },
    "it.interpolator_four_points": {
      "prefix": "it",
      "name": "interpolator_four_points",
      "full_name": "it.interpolator_four_points",
      "args": [
        "gen",
        "idv",
        "interpolate_four_points"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic interpolator on interpolator_four_points points (previous, current and two next indexes), assuming an increasing index."
    },
    "it.interpolator_cubic": {
      "prefix": "it",
      "name": "interpolator_cubic",
      "full_name": "it.interpolator_cubic",
      "args": [
        "gen",
        "idv"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cubic interpolator for a 'gen' circuit triggered by an 'idv' input to generate values."
    },
    "it.interpolator_select": {
      "prefix": "it",
      "name": "interpolator_select",
      "full_name": "it.interpolator_select",
      "args": [
        "gen",
        "idv",
        "sel"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic configurable interpolator (with selector between in [0..3]). The value 3 is used for no interpolation."
    },
    "it.lerp": {
      "prefix": "it",
      "name": "lerp",
      "full_name": "it.lerp",
      "args": [
        "x0",
        "x1",
        "y0",
        "y1",
        "x"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolation between two points."
    },
    "it.piecewise": {
      "prefix": "it",
      "name": "piecewise",
      "full_name": "it.piecewise",
      "args": [
        "xList",
        "yList",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear piecewise interpolation between N points."
    },
    "it.lagrangeCoeffs": {
      "prefix": "it",
      "name": "lagrangeCoeffs",
      "full_name": "it.lagrangeCoeffs",
      "args": [
        "N",
        "xCoordsList",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "This is a function to generate N + 1 coefficients for an Nth-order Lagrange basis polynomial with arbitrary spacing of the points."
    },
    "it.lagrangeInterpolation": {
      "prefix": "it",
      "name": "lagrangeInterpolation",
      "full_name": "it.lagrangeInterpolation",
      "args": [
        "N",
        "xCoordsList"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Nth-order Lagrange interpolator to interpolate between a set of arbitrarily spaced N + 1 points."
    },
    "it.frdtable": {
      "prefix": "it",
      "name": "frdtable",
      "full_name": "it.frdtable",
      "args": [
        "N",
        "S",
        "init",
        "idx"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Look-up circular table with Nth-order Lagrange interpolation for fractional indexes. The index is wrapped-around and the table is cycles for an index span of size S, which is the table size in samples"
    },
    "it.frwtable": {
      "prefix": "it",
      "name": "frwtable",
      "full_name": "it.frwtable",
      "args": [
        "N",
        "S",
        "init",
        "w_idx",
        "x",
        "r_idx"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Look-up updatable circular table with Nth-order Lagrange interpolation for fractional indexes. The index is wrapped-around and the table is circular indexes ranging from 0 to S, which is the table siz"
    },
    "it.remap": {
      "prefix": "it",
      "name": "remap",
      "full_name": "it.remap",
      "args": [
        "from1",
        "from2",
        "to1",
        "to2"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Linearly map from an input domain to an output range."
    },
    "la.determinant": {
      "prefix": "la",
      "name": "determinant",
      "full_name": "la.determinant",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Calculates the determinant of a bus that represents an `NxN` matrix."
    },
    "la.minor": {
      "prefix": "la",
      "name": "minor",
      "full_name": "la.minor",
      "args": [
        "N",
        "ROW",
        "COL"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "An utility for finding the matrix minor when inverting a matrix. It returns the determinant of the submatrix formed by deleting the row at index `ROW` and column at index `COL`."
    },
    "la.inverse": {
      "prefix": "la",
      "name": "inverse",
      "full_name": "la.inverse",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Inverts a matrix. The incoming bus represents an `NxN` matrix. Note, this is an unsafe operation since not all matrices are invertible."
    },
    "la.transpose2": {
      "prefix": "la",
      "name": "transpose2",
      "full_name": "la.transpose2",
      "args": [
        "N",
        "M"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Transposes an `NxM` matrix stored in row-major order, resulting in an `MxN` matrix stored in row-major order."
    },
    "la.matMul": {
      "prefix": "la",
      "name": "matMul",
      "full_name": "la.matMul",
      "args": [
        "J",
        "K",
        "L",
        "M",
        "si.bus(J*K"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Multiply a `JxK` matrix (mat1) and an `LxM` matrix (mat2) to produce a `JxM` matrix. Note that `K==L`. Both matrices should use row-major order."
    },
    "la.identity": {
      "prefix": "la",
      "name": "identity",
      "full_name": "la.identity",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates an `NxN` identity matrix."
    },
    "la.diag": {
      "prefix": "la",
      "name": "diag",
      "full_name": "la.diag",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a diagonal matrix of size `NxN` with specified values along the diagonal."
    },
    "ma.SR": {
      "prefix": "ma",
      "name": "SR",
      "full_name": "ma.SR",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current sampling rate given at init time. Constant during program execution."
    },
    "ma.T": {
      "prefix": "ma",
      "name": "T",
      "full_name": "ma.T",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current sample duration in seconds computed from the sampling rate given at init time. Constant during program execution."
    },
    "ma.BS": {
      "prefix": "ma",
      "name": "BS",
      "full_name": "ma.BS",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current block-size. Can change during the execution at each block."
    },
    "ma.PI": {
      "prefix": "ma",
      "name": "PI",
      "full_name": "ma.PI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant PI in double precision."
    },
    "ma.deg2rad": {
      "prefix": "ma",
      "name": "deg2rad",
      "full_name": "ma.deg2rad",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Convert degrees to radians."
    },
    "ma.rad2deg": {
      "prefix": "ma",
      "name": "rad2deg",
      "full_name": "ma.rad2deg",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Convert radians to degrees."
    },
    "ma.E": {
      "prefix": "ma",
      "name": "E",
      "full_name": "ma.E",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant e in double precision."
    },
    "ma.EPSILON": {
      "prefix": "ma",
      "name": "EPSILON",
      "full_name": "ma.EPSILON",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant EPSILON available in simple/double/quad precision, as defined in the [floating-point standard](https://en.wikipedia.org/wiki/IEEE_754) and [machine epsilon](https://en.wikipedia.org/wiki/Mach"
    },
    "ma.MIN": {
      "prefix": "ma",
      "name": "MIN",
      "full_name": "ma.MIN",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant MIN available in simple/double/quad precision (minimal positive value)."
    },
    "ma.MAX": {
      "prefix": "ma",
      "name": "MAX",
      "full_name": "ma.MAX",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant MAX available in simple/double/quad precision (maximal positive value)."
    },
    "ma.FTZ": {
      "prefix": "ma",
      "name": "FTZ",
      "full_name": "ma.FTZ",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Flush to zero: force samples under the \"maximum subnormal number\" to be zero. Usually not needed in C++ because the architecture file take care of this, but can be useful in JavaScript for instance."
    },
    "ma.copysign": {
      "prefix": "ma",
      "name": "copysign",
      "full_name": "ma.copysign",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Changes the sign of x (first input) to that of y (second input)."
    },
    "ma.neg": {
      "prefix": "ma",
      "name": "neg",
      "full_name": "ma.neg",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Invert the sign (-x) of a signal."
    },
    "ma.not": {
      "prefix": "ma",
      "name": "not",
      "full_name": "ma.not",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Bitwise `not` implemented with [xor](https://faustdoc.grame.fr/manual/syntax/#xor-primitive) as `not(x) = x xor -1;`. So working regardless of the size of the integer, assuming negative numbers in two"
    },
    "ma.x": {
      "prefix": "ma",
      "name": "x",
      "full_name": "ma.x",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Subtract `x` and `y`."
    },
    "ma.inv": {
      "prefix": "ma",
      "name": "inv",
      "full_name": "ma.inv",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Compute the inverse (1/x) of the input signal."
    },
    "ma.cbrt": {
      "prefix": "ma",
      "name": "cbrt",
      "full_name": "ma.cbrt",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the cube root of of the input signal."
    },
    "ma.hypot": {
      "prefix": "ma",
      "name": "hypot",
      "full_name": "ma.hypot",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Computes the euclidian distance of the two input signals sqrt(x*x+y*y) without undue overflow or underflow."
    },
    "ma.ldexp": {
      "prefix": "ma",
      "name": "ldexp",
      "full_name": "ma.ldexp",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Takes two input signals: x and n, and multiplies x by 2 to the power n."
    },
    "ma.scalb": {
      "prefix": "ma",
      "name": "scalb",
      "full_name": "ma.scalb",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Takes two input signals: x and n, and multiplies x by 2 to the power n."
    },
    "ma.log1p": {
      "prefix": "ma",
      "name": "log1p",
      "full_name": "ma.log1p",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes log(1 + x) without undue loss of accuracy when x is nearly zero."
    },
    "ma.logb": {
      "prefix": "ma",
      "name": "logb",
      "full_name": "ma.logb",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Return exponent of the input signal as a floating-point number."
    },
    "ma.ilogb": {
      "prefix": "ma",
      "name": "ilogb",
      "full_name": "ma.ilogb",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Return exponent of the input signal as an integer number."
    },
    "ma.log2": {
      "prefix": "ma",
      "name": "log2",
      "full_name": "ma.log2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Returns the base 2 logarithm of x."
    },
    "ma.expm1": {
      "prefix": "ma",
      "name": "expm1",
      "full_name": "ma.expm1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Return exponent of the input signal minus 1 with better precision."
    },
    "ma.acosh": {
      "prefix": "ma",
      "name": "acosh",
      "full_name": "ma.acosh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the principle value of the inverse hyperbolic cosine of the input signal."
    },
    "ma.asinh": {
      "prefix": "ma",
      "name": "asinh",
      "full_name": "ma.asinh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the inverse hyperbolic sine of the input signal."
    },
    "ma.atanh": {
      "prefix": "ma",
      "name": "atanh",
      "full_name": "ma.atanh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the inverse hyperbolic tangent of the input signal."
    },
    "ma.sinh": {
      "prefix": "ma",
      "name": "sinh",
      "full_name": "ma.sinh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the hyperbolic sine of the input signal."
    },
    "ma.cosh": {
      "prefix": "ma",
      "name": "cosh",
      "full_name": "ma.cosh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the hyperbolic cosine of the input signal."
    },
    "ma.tanh": {
      "prefix": "ma",
      "name": "tanh",
      "full_name": "ma.tanh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the hyperbolic tangent of the input signal."
    },
    "ma.erf": {
      "prefix": "ma",
      "name": "erf",
      "full_name": "ma.erf",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the error function of the input signal."
    },
    "ma.erfc": {
      "prefix": "ma",
      "name": "erfc",
      "full_name": "ma.erfc",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the complementary error function of the input signal."
    },
    "ma.gamma": {
      "prefix": "ma",
      "name": "gamma",
      "full_name": "ma.gamma",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the gamma function of the input signal."
    },
    "ma.lgamma": {
      "prefix": "ma",
      "name": "lgamma",
      "full_name": "ma.lgamma",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Calculates the natural logorithm of the absolute value of the gamma function of the input signal."
    },
    "ma.J0": {
      "prefix": "ma",
      "name": "J0",
      "full_name": "ma.J0",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the Bessel function of the first kind of order 0 of the input signal."
    },
    "ma.J1": {
      "prefix": "ma",
      "name": "J1",
      "full_name": "ma.J1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the Bessel function of the first kind of order 1 of the input signal."
    },
    "ma.Jn": {
      "prefix": "ma",
      "name": "Jn",
      "full_name": "ma.Jn",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Computes the Bessel function of the first kind of order n (first input signal) of the second input signal."
    },
    "ma.Y0": {
      "prefix": "ma",
      "name": "Y0",
      "full_name": "ma.Y0",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the linearly independent Bessel function of the second kind of order 0 of the input signal."
    },
    "ma.Y1": {
      "prefix": "ma",
      "name": "Y1",
      "full_name": "ma.Y1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the linearly independent Bessel function of the second kind of order 1 of the input signal."
    },
    "ma.Yn": {
      "prefix": "ma",
      "name": "Yn",
      "full_name": "ma.Yn",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Computes the linearly independent Bessel function of the second kind of order n (first input signal) of the second input signal."
    },
    "ma.fabs": {
      "prefix": "ma",
      "name": "fabs",
      "full_name": "ma.fabs",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Just for compatibility..."
    },
    "ma.np2": {
      "prefix": "ma",
      "name": "np2",
      "full_name": "ma.np2",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Gives the next power of 2 of x."
    },
    "ma.frac": {
      "prefix": "ma",
      "name": "frac",
      "full_name": "ma.frac",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Gives the fractional part of n."
    },
    "ma.modulo": {
      "prefix": "ma",
      "name": "modulo",
      "full_name": "ma.modulo",
      "args": [
        "x",
        "y"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Modulus operation using the `(x%y+y)%y` formula to ensures the result is always non-negative, even if `x` is negative."
    },
    "ma.isnan": {
      "prefix": "ma",
      "name": "isnan",
      "full_name": "ma.isnan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Return non-zero if x is a NaN."
    },
    "ma.isinf": {
      "prefix": "ma",
      "name": "isinf",
      "full_name": "ma.isinf",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Return non-zero if x is a positive or negative infinity."
    },
    "ma.chebychev": {
      "prefix": "ma",
      "name": "chebychev",
      "full_name": "ma.chebychev",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Chebychev transformation of order N."
    },
    "ma.chebychevpoly": {
      "prefix": "ma",
      "name": "chebychevpoly",
      "full_name": "ma.chebychevpoly",
      "args": [
        "c0",
        "c1",
        "...",
        "cn"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Linear combination of the first Chebyshev polynomials."
    },
    "ma.diffn": {
      "prefix": "ma",
      "name": "diffn",
      "full_name": "ma.diffn",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Negated first-order difference."
    },
    "ma.signum": {
      "prefix": "ma",
      "name": "signum",
      "full_name": "ma.signum",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The signum function signum(x) is defined as -1 for x<0, 0 for x==0, and 1 for x>0."
    },
    "ma.nextpow2": {
      "prefix": "ma",
      "name": "nextpow2",
      "full_name": "ma.nextpow2",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The nextpow2(x) returns the lowest integer m such that 2^m >= x."
    },
    "ma.zc": {
      "prefix": "ma",
      "name": "zc",
      "full_name": "ma.zc",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Indicator function for zero-crossing: it returns 1 if a zero-crossing occurs, 0 otherwise."
    },
    "ma.primes": {
      "prefix": "ma",
      "name": "primes",
      "full_name": "ma.primes",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Return the n-th prime using a waveform primitive. Note that primes(0) is 2, primes(1) is 3, and so on. The waveform is length 2048, so the largest precomputed prime is primes(2047) which is 17863."
    },
    "mi.initState": {
      "prefix": "mi",
      "name": "initState",
      "full_name": "mi.initState",
      "args": [
        "x0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Used to set initial delayed position values that must be initialised at step 0 of the physics simulation."
    },
    "mi.mass": {
      "prefix": "mi",
      "name": "mass",
      "full_name": "mi.mass",
      "args": [
        "m",
        "grav",
        "x0",
        "xr0"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 2,
      "description": "Implementation of a punctual mass element. Takes an input force and produces output position."
    },
    "mi.oscil": {
      "prefix": "mi",
      "name": "oscil",
      "full_name": "mi.oscil",
      "args": [
        "m",
        "k",
        "z",
        "grav",
        "x0",
        "xr0"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 2,
      "description": "Implementation of a simple linear harmonic oscillator. Takes an input force and produces output position."
    },
    "mi.ground": {
      "prefix": "mi",
      "name": "ground",
      "full_name": "mi.ground",
      "args": [
        "x0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Implementation of a fixed point element. The position output produced by this module never changes, however it still expects a force input signal (for compliance with connection"
    },
    "mi.posInput": {
      "prefix": "mi",
      "name": "posInput",
      "full_name": "mi.posInput",
      "args": [
        "x0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 3,
      "description": "Implementation of a position input module (driven by an outside signal). Takes two signal inputs: incoming force (which doesn't affect position) and the driving position signal."
    },
    "mi.spring": {
      "prefix": "mi",
      "name": "spring",
      "full_name": "mi.spring",
      "args": [
        "k",
        "x1r",
        "x2r"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a linear elastic spring interaction."
    },
    "mi.damper": {
      "prefix": "mi",
      "name": "damper",
      "full_name": "mi.damper",
      "args": [
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a linear damper interaction. Beware: in 32bit precision mode, damping forces can become truncated if position values are not centered around zero!"
    },
    "mi.springDamper": {
      "prefix": "mi",
      "name": "springDamper",
      "full_name": "mi.springDamper",
      "args": [
        "k",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a linear viscoelastic spring-damper interaction (a combination of the spring and damper modules)."
    },
    "mi.nlSpringDamper2": {
      "prefix": "mi",
      "name": "nlSpringDamper2",
      "full_name": "mi.nlSpringDamper2",
      "args": [
        "k",
        "q",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear viscoelastic spring-damper interaction containing a quadratic term (function of squared distance). Beware: at high displacements, this interaction will break numerical"
    },
    "mi.nlSpringDamper3": {
      "prefix": "mi",
      "name": "nlSpringDamper3",
      "full_name": "mi.nlSpringDamper3",
      "args": [
        "k",
        "q",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear viscoelastic spring-damper interaction containing a cubic term (function of distance^3). Beware: at high displacements, this interaction will break numerical"
    },
    "mi.nlSpringDamperClipped": {
      "prefix": "mi",
      "name": "nlSpringDamperClipped",
      "full_name": "mi.nlSpringDamperClipped",
      "args": [
        "s",
        "c",
        "k",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear viscoelastic spring-damper interaction containing a cubic term (function of distance^3), bound by an upper linear stiffness (hard-clipping)."
    },
    "mi.nlPluck": {
      "prefix": "mi",
      "name": "nlPluck",
      "full_name": "mi.nlPluck",
      "args": [
        "knl",
        "scale",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a piecewise linear plucking interaction. The symmetric function provides a repulsive viscoelastic interaction upon contact, until a tipping point is reached (when the plucking occurs"
    },
    "mi.nlBow": {
      "prefix": "mi",
      "name": "nlBow",
      "full_name": "mi.nlBow",
      "args": [
        "znl",
        "scale",
        "type",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear friction based interaction that allows for stick-slip bowing behaviour. Two versions are proposed : a piecewise linear function (very"
    },
    "mi.collision": {
      "prefix": "mi",
      "name": "collision",
      "full_name": "mi.collision",
      "args": [
        "k",
        "z",
        "thres",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a collision interaction, producing linear visco-elastic repulsion forces when two mass elements are interpenetrating."
    },
    "mi.nlCollisionClipped": {
      "prefix": "mi",
      "name": "nlCollisionClipped",
      "full_name": "mi.nlCollisionClipped",
      "args": [
        "s",
        "c",
        "k",
        "z",
        "thres",
        "x1r",
        "x2r"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a collision interaction, producing non-linear visco-elastic repulsion forces when two mass elements are interpenetrating. Bound by an upper stiffness value to maintain stability."
    },
    "ef.cubicnl": {
      "prefix": "ef",
      "name": "cubicnl",
      "full_name": "ef.cubicnl",
      "args": [
        "drive",
        "offset"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Cubic nonlinearity distortion. `cubicnl` is a standard Faust function."
    },
    "ef.gate_mono": {
      "prefix": "ef",
      "name": "gate_mono",
      "full_name": "ef.gate_mono",
      "args": [
        "thresh",
        "att",
        "hold",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono signal gate. `gate_mono` is a standard Faust function."
    },
    "ef.gate_stereo": {
      "prefix": "ef",
      "name": "gate_stereo",
      "full_name": "ef.gate_stereo",
      "args": [
        "thresh",
        "att",
        "hold",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo signal gates. `gate_stereo` is a standard Faust function."
    },
    "ef.fibonacci": {
      "prefix": "ef",
      "name": "fibonacci",
      "full_name": "ef.fibonacci",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Fibonacci system where the current output is the current input plus the sum of the previous N outputs."
    },
    "ef.fibonacciGeneral": {
      "prefix": "ef",
      "name": "fibonacciGeneral",
      "full_name": "ef.fibonacciGeneral",
      "args": [
        "wave"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Fibonacci system with customizable coefficients. The order of the system is inferred from the number of coefficients."
    },
    "ef.fibonacciSeq": {
      "prefix": "ef",
      "name": "fibonacciSeq",
      "full_name": "ef.fibonacciSeq",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "First N numbers of the Fibonacci sequence [1, 1, 2, 3, 5, 8, ...] as parallel channels."
    },
    "ef.speakerbp": {
      "prefix": "ef",
      "name": "speakerbp",
      "full_name": "ef.speakerbp",
      "args": [
        "f1",
        "f2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Dirt-simple speaker simulator (overall bandpass eq with observed roll-offs above and below the passband). `speakerbp` is a standard Faust function."
    },
    "ef.piano_dispersion_filter": {
      "prefix": "ef",
      "name": "piano_dispersion_filter",
      "full_name": "ef.piano_dispersion_filter",
      "args": [
        "M",
        "B",
        "f0"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Piano dispersion allpass filter in closed form."
    },
    "ef.stereo_width": {
      "prefix": "ef",
      "name": "stereo_width",
      "full_name": "ef.stereo_width",
      "args": [
        "w"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo Width effect using the Blumlein Shuffler technique. `stereo_width` is a standard Faust function."
    },
    "ef.mesh_square": {
      "prefix": "ef",
      "name": "mesh_square",
      "full_name": "ef.mesh_square",
      "args": [
        "4*N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Square Rectangular Digital Waveguide Mesh."
    },
    "ef.dryWetMixer": {
      "prefix": "ef",
      "name": "dryWetMixer",
      "full_name": "ef.dryWetMixer",
      "args": [
        "wetAmount",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear dry-wet mixer for a N inputs and N outputs effect."
    },
    "ef.dryWetMixerConstantPower": {
      "prefix": "ef",
      "name": "dryWetMixerConstantPower",
      "full_name": "ef.dryWetMixerConstantPower",
      "args": [
        "wetAmount",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant-power dry-wet mixer for a N inputs and N outputs effect."
    },
    "ef.weightsPowerLoop": {
      "prefix": "ef",
      "name": "weightsPowerLoop",
      "full_name": "ef.weightsPowerLoop",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "\"Fan out\" an index into N weights between 0 and 1. At any given moment, two weights may be non-zero. Suppose they are N_m and N_{m+1}. Then `cos(N_m)^2+sin(N_{m+1})^2==0.5`."
    },
    "ef.mixLinearClamp": {
      "prefix": "ef",
      "name": "mixLinearClamp",
      "full_name": "ef.mixLinearClamp",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear mixer for `N` buses, each with `C` channels. The output will be a sum of 2 buses determined by the mixing index `mix`. 0 produces the first bus, 1 produces the second, and so on. `mix` is clamp"
    },
    "ef.mixLinearLoop": {
      "prefix": "ef",
      "name": "mixLinearLoop",
      "full_name": "ef.mixLinearLoop",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear mixer for `N` buses, each with `C` channels. Refer to `mixLinearClamp`. `mix` will loop for multiples of `N`. For example, `mixLinearLoop(4, 1, 0)` has the same effect as `mixLinearLoop(4, 1, -"
    },
    "ef.mixPowerClamp": {
      "prefix": "ef",
      "name": "mixPowerClamp",
      "full_name": "ef.mixPowerClamp",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant-power mixer for `N` buses, each with `C` channels. The output will be a sum of 2 buses determined by the mixing index `mix`. 0 produces the first bus, 1 produces the second, and so on. `mix` "
    },
    "ef.mixPowerLoop": {
      "prefix": "ef",
      "name": "mixPowerLoop",
      "full_name": "ef.mixPowerLoop",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant-power mixer for `N` buses, each with `C` channels. Refer to `mixPowerClamp`. `mix` will loop for multiples of `N`. For example, `mixPowerLoop(4, 1, 0)` has the same effect as `mixPowerLoop(4,"
    },
    "ef.echo": {
      "prefix": "ef",
      "name": "echo",
      "full_name": "ef.echo",
      "args": [
        "maxDuration",
        "duration",
        "feedback"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "A simple echo effect. `echo` is a standard Faust function."
    },
    "ef.reverseEchoN": {
      "prefix": "ef",
      "name": "reverseEchoN",
      "full_name": "ef.reverseEchoN",
      "args": [
        "N",
        "delay"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Reverse echo effect."
    },
    "ef.reverseDelayRamped": {
      "prefix": "ef",
      "name": "reverseDelayRamped",
      "full_name": "ef.reverseDelayRamped",
      "args": [
        "delay",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Reverse delay with amplitude ramp."
    },
    "ef.uniformPanToStereo": {
      "prefix": "ef",
      "name": "uniformPanToStereo",
      "full_name": "ef.uniformPanToStereo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Pan nChans channels to the stereo field, spread uniformly left to right."
    },
    "ef.tapeStop": {
      "prefix": "ef",
      "name": "tapeStop",
      "full_name": "ef.tapeStop",
      "args": [
        "2",
        "LAGRANGE_ORDER",
        "MAX_TIME_SAMP",
        "//               crossfade",
        "gainAlpha",
        "stopAlpha",
        "stopTime",
        "stop"
      ],
      "arg_count": 8,
      "inputs": 2,
      "outputs": 3,
      "description": "A tape-stop effect, like putting a finger on a vinyl record player."
    },
    "ef.transpose": {
      "prefix": "ef",
      "name": "transpose",
      "full_name": "ef.transpose",
      "args": [
        "w",
        "x",
        "s"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "A simple pitch shifter based on 2 delay lines. `transpose` is a standard Faust function."
    },
    "ef.softclipQuadratic": {
      "prefix": "ef",
      "name": "softclipQuadratic",
      "full_name": "ef.softclipQuadratic",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Quadratic softclip nonlinearity."
    },
    "ef.wavefold": {
      "prefix": "ef",
      "name": "wavefold",
      "full_name": "ef.wavefold",
      "args": [
        "width"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Wavefolding nonlinearity."
    },
    "mo.shockTrigger": {
      "prefix": "mo",
      "name": "shockTrigger",
      "full_name": "mo.shockTrigger",
      "args": [
        "hpHz",
        "threshold",
        "debounceMs",
        "sig"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Debounced shock trigger from an accelerometer axis."
    },
    "mo.inclinometer": {
      "prefix": "mo",
      "name": "inclinometer",
      "full_name": "mo.inclinometer",
      "args": [
        "lpHz",
        "sig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Low-pass inclinometer for a single axis."
    },
    "mo.inclineBalance": {
      "prefix": "mo",
      "name": "inclineBalance",
      "full_name": "mo.inclineBalance",
      "args": [
        "lpHz",
        "posSig",
        "negSig"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Balance between positive and negative inclination on the same axis."
    },
    "mo.inclineSymmetric": {
      "prefix": "mo",
      "name": "inclineSymmetric",
      "full_name": "mo.inclineSymmetric",
      "args": [
        "lpHz",
        "posSig",
        "negSig"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Symmetric gravity comparison (0->1->0) from positive and negative axes."
    },
    "mo.projectedGravity": {
      "prefix": "mo",
      "name": "projectedGravity",
      "full_name": "mo.projectedGravity",
      "args": [
        "lpHz",
        "offset",
        "sig"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Projects an axis onto gravity with optional dead-zone offset."
    },
    "mo.motionEnvelope": {
      "prefix": "mo",
      "name": "motionEnvelope",
      "full_name": "mo.motionEnvelope",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Base thresholded AR envelope used by the accelerometer and gyroscope helpers."
    },
    "mo.envelopeAbs": {
      "prefix": "mo",
      "name": "envelopeAbs",
      "full_name": "mo.envelopeAbs",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope on the absolute value of a signal (responds to both polarities)."
    },
    "mo.envelopePos": {
      "prefix": "mo",
      "name": "envelopePos",
      "full_name": "mo.envelopePos",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope for the positive portion of a signal."
    },
    "mo.envelopeNeg": {
      "prefix": "mo",
      "name": "envelopeNeg",
      "full_name": "mo.envelopeNeg",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope for the negative portion of a signal (by flipping its polarity first)."
    },
    "mo.pita3": {
      "prefix": "mo",
      "name": "pita3",
      "full_name": "mo.pita3",
      "args": [
        "x",
        "y",
        "z"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "3D magnitude helper `sqrt(x^2 + y^2 + z^2)` used for total envelopes."
    },
    "mo.totalEnvelope": {
      "prefix": "mo",
      "name": "totalEnvelope",
      "full_name": "mo.totalEnvelope",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "x",
        "y",
        "z"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Magnitude-based envelope across three axes."
    },
    "mo.accelEnvelopeAbs": {
      "prefix": "mo",
      "name": "accelEnvelopeAbs",
      "full_name": "mo.accelEnvelopeAbs",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower on the absolute value of an accelerometer axis."
    },
    "mo.accelEnvelopePos": {
      "prefix": "mo",
      "name": "accelEnvelopePos",
      "full_name": "mo.accelEnvelopePos",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for positive acceleration on one axis."
    },
    "mo.accelEnvelopeNeg": {
      "prefix": "mo",
      "name": "accelEnvelopeNeg",
      "full_name": "mo.accelEnvelopeNeg",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for negative acceleration on one axis."
    },
    "mo.totalAccel": {
      "prefix": "mo",
      "name": "totalAccel",
      "full_name": "mo.totalAccel",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "ax",
        "ay",
        "az"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Total acceleration magnitude with thresholding and envelope."
    },
    "mo.gyroEnvelopeAbs": {
      "prefix": "mo",
      "name": "gyroEnvelopeAbs",
      "full_name": "mo.gyroEnvelopeAbs",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower on the absolute value of a gyroscope axis."
    },
    "mo.gyroEnvelopePos": {
      "prefix": "mo",
      "name": "gyroEnvelopePos",
      "full_name": "mo.gyroEnvelopePos",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for positive gyroscope rotation on one axis."
    },
    "mo.gyroEnvelopeNeg": {
      "prefix": "mo",
      "name": "gyroEnvelopeNeg",
      "full_name": "mo.gyroEnvelopeNeg",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for negative gyroscope rotation on one axis."
    },
    "mo.totalGyro": {
      "prefix": "mo",
      "name": "totalGyro",
      "full_name": "mo.totalGyro",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "gx",
        "gy",
        "gz"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Total gyroscope magnitude with thresholding and envelope."
    },
    "mo.orientationWeight": {
      "prefix": "mo",
      "name": "orientationWeight",
      "full_name": "mo.orientationWeight",
      "args": [
        "targetX",
        "targetY",
        "targetZ",
        "shape",
        "xs",
        "ys",
        "zs",
        "smoothMs"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 1,
      "description": "Weighting of a 3D vector toward a target axis with shape and smoothing."
    },
    "mo.orientation6": {
      "prefix": "mo",
      "name": "orientation6",
      "full_name": "mo.orientation6",
      "args": [
        "xs",
        "ys",
        "zs",
        "//              shapeCour",
        "shapeRear",
        "shapeJardin",
        "shapeFront",
        "shapeDown",
        "shapeUp",
        "//              smoothMs"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "Weights toward the six device axes (Cour/stage left -X, Rear -Y, Jardin/stage right +X, Front +Y, Down -Z, Up +Z)."
    },
    "mo.scale": {
      "prefix": "mo",
      "name": "scale",
      "full_name": "mo.scale",
      "args": [
        "ilow",
        "ihigh",
        "olow",
        "ohigh"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Normalized scaler with input dead-zone and bounded output range."
    },
    "no.noise": {
      "prefix": "no",
      "name": "noise",
      "full_name": "no.noise",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "White noise generator (outputs random number between -1 and 1). `noise` is a standard Faust function."
    },
    "no.multirandom": {
      "prefix": "no",
      "name": "multirandom",
      "full_name": "no.multirandom",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated random numbers in parallel."
    },
    "no.multinoise": {
      "prefix": "no",
      "name": "multinoise",
      "full_name": "no.multinoise",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated noises in parallel."
    },
    "no.noises": {
      "prefix": "no",
      "name": "noises",
      "full_name": "no.noises",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A convenient wrapper around multinoise."
    },
    "no.dnoise": {
      "prefix": "no",
      "name": "dnoise",
      "full_name": "no.dnoise",
      "args": [
        "t",
        "sx"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A deterministic noise burst with a dynamically adjustable seed, enabling consistent recall. Useful for noise variation sensitive applications like replicable/recallable percussion sounds and waveguide"
    },
    "no.randomseed": {
      "prefix": "no",
      "name": "randomseed",
      "full_name": "no.randomseed",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A random seed based on the foreign function `arc4random` (see man arc4random). Used in `rnoise`, `rmultirandom`, etc. to avoid having the same pseudo random sequence at each run."
    },
    "no.rnoise": {
      "prefix": "no",
      "name": "rnoise",
      "full_name": "no.rnoise",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A randomized white noise generator (outputs random number between -1 and 1)."
    },
    "no.rmultirandom": {
      "prefix": "no",
      "name": "rmultirandom",
      "full_name": "no.rmultirandom",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated random numbers in parallel."
    },
    "no.rmultinoise": {
      "prefix": "no",
      "name": "rmultinoise",
      "full_name": "no.rmultinoise",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated noises in parallel."
    },
    "no.rnoises": {
      "prefix": "no",
      "name": "rnoises",
      "full_name": "no.rnoises",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A convenient wrapper around rmultinoise."
    },
    "no.pink_noise": {
      "prefix": "no",
      "name": "pink_noise",
      "full_name": "no.pink_noise",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Pink noise (1/f noise) generator (third-order approximation covering the audio band well). `pink_noise` is a standard Faust function."
    },
    "no.pink_noise_vm": {
      "prefix": "no",
      "name": "pink_noise_vm",
      "full_name": "no.pink_noise_vm",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Multi pink noise generator."
    },
    "no.lfnoise": {
      "prefix": "no",
      "name": "lfnoise",
      "full_name": "no.lfnoise",
      "args": [
        "rate"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Low-frequency noise generators (Butterworth-filtered downsampled white noise)."
    },
    "no.sparse_noise": {
      "prefix": "no",
      "name": "sparse_noise",
      "full_name": "no.sparse_noise",
      "args": [
        "f0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sparse noise generator."
    },
    "no.velvet_noise_vm": {
      "prefix": "no",
      "name": "velvet_noise_vm",
      "full_name": "no.velvet_noise_vm",
      "args": [
        "amp",
        "f0"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Velvet noise generator."
    },
    "no.gnoise": {
      "prefix": "no",
      "name": "gnoise",
      "full_name": "no.gnoise",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Approximate zero-mean, unit-variance Gaussian white noise generator."
    },
    "no.colored_noise": {
      "prefix": "no",
      "name": "colored_noise",
      "full_name": "no.colored_noise",
      "args": [
        "N",
        "alpha"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates a colored noise signal with an arbitrary spectral roll-off factor (alpha) over the entire audible frequency range (20-20000 Hz). The output is normalized so that an equal RMS"
    },
    "os.sinwaveform": {
      "prefix": "os",
      "name": "sinwaveform",
      "full_name": "os.sinwaveform",
      "args": [
        "tablesize"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine waveform ready to use with a `rdtable`."
    },
    "os.coswaveform": {
      "prefix": "os",
      "name": "coswaveform",
      "full_name": "os.coswaveform",
      "args": [
        "tablesize"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine waveform ready to use with a `rdtable`."
    },
    "os.phasor": {
      "prefix": "os",
      "name": "phasor",
      "full_name": "os.phasor",
      "args": [
        "tablesize",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple phasor to be used with a `rdtable`. `phasor` is a standard Faust function."
    },
    "os.hs_phasor": {
      "prefix": "os",
      "name": "hs_phasor",
      "full_name": "os.hs_phasor",
      "args": [
        "tablesize",
        "freq",
        "reset"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Hardsyncing phasor to be used with a `rdtable`."
    },
    "os.hsp_phasor": {
      "prefix": "os",
      "name": "hsp_phasor",
      "full_name": "os.hsp_phasor",
      "args": [
        "tablesize",
        "freq",
        "reset",
        "phase"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Hardsyncing phasor with selectable phase to be used with a `rdtable`."
    },
    "os.oscsin": {
      "prefix": "os",
      "name": "oscsin",
      "full_name": "os.oscsin",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine wave oscillator. `oscsin` is a standard Faust function."
    },
    "os.hs_oscsin": {
      "prefix": "os",
      "name": "hs_oscsin",
      "full_name": "os.hs_oscsin",
      "args": [
        "freq",
        "reset"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Sin lookup table with hardsyncing phase."
    },
    "os.osccos": {
      "prefix": "os",
      "name": "osccos",
      "full_name": "os.osccos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine wave oscillator."
    },
    "os.hs_osccos": {
      "prefix": "os",
      "name": "hs_osccos",
      "full_name": "os.hs_osccos",
      "args": [
        "freq",
        "reset"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cos lookup table with hardsyncing phase."
    },
    "os.oscp": {
      "prefix": "os",
      "name": "oscp",
      "full_name": "os.oscp",
      "args": [
        "freq",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A sine wave generator with controllable phase."
    },
    "os.osci": {
      "prefix": "os",
      "name": "osci",
      "full_name": "os.osci",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Interpolated phase sine wave oscillator."
    },
    "os.osc": {
      "prefix": "os",
      "name": "osc",
      "full_name": "os.osc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Default sine wave oscillator (same as [oscsin](#oscsin)). `osc` is a standard Faust function."
    },
    "os.m_oscsin": {
      "prefix": "os",
      "name": "m_oscsin",
      "full_name": "os.m_oscsin",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine wave oscillator based on the `sin` mathematical function."
    },
    "os.m_osccos": {
      "prefix": "os",
      "name": "m_osccos",
      "full_name": "os.m_osccos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine wave oscillator based on the `cos` mathematical function."
    },
    "os.lf_imptrain": {
      "prefix": "os",
      "name": "lf_imptrain",
      "full_name": "os.lf_imptrain",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unit-amplitude low-frequency impulse train. `lf_imptrain` is a standard Faust function."
    },
    "os.lf_pulsetrainpos": {
      "prefix": "os",
      "name": "lf_pulsetrainpos",
      "full_name": "os.lf_pulsetrainpos",
      "args": [
        "freq",
        "duty"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unit-amplitude nonnegative LF pulse train, duty cycle between 0 and 1."
    },
    "os.lf_pulsetrain": {
      "prefix": "os",
      "name": "lf_pulsetrain",
      "full_name": "os.lf_pulsetrain",
      "args": [
        "freq",
        "duty"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unit-amplitude zero-mean LF pulse train, duty cycle between 0 and 1."
    },
    "os.lf_squarewavepos": {
      "prefix": "os",
      "name": "lf_squarewavepos",
      "full_name": "os.lf_squarewavepos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Positive LF square wave in [0,1]"
    },
    "os.lf_squarewave": {
      "prefix": "os",
      "name": "lf_squarewave",
      "full_name": "os.lf_squarewave",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Zero-mean unit-amplitude LF square wave. `lf_squarewave` is a standard Faust function."
    },
    "os.lf_trianglepos": {
      "prefix": "os",
      "name": "lf_trianglepos",
      "full_name": "os.lf_trianglepos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Positive unit-amplitude LF positive triangle wave."
    },
    "os.lf_triangle": {
      "prefix": "os",
      "name": "lf_triangle",
      "full_name": "os.lf_triangle",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Zero-mean unit-amplitude LF triangle wave. `lf_triangle` is a standard Faust function."
    },
    "os.lf_rawsaw": {
      "prefix": "os",
      "name": "lf_rawsaw",
      "full_name": "os.lf_rawsaw",
      "args": [
        "periodsamps"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and period in samples."
    },
    "os.lf_sawpos": {
      "prefix": "os",
      "name": "lf_sawpos",
      "full_name": "os.lf_sawpos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1."
    },
    "os.lf_sawpos_phase": {
      "prefix": "os",
      "name": "lf_sawpos_phase",
      "full_name": "os.lf_sawpos_phase",
      "args": [
        "freq",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1 with phase control."
    },
    "os.lf_sawpos_reset": {
      "prefix": "os",
      "name": "lf_sawpos_reset",
      "full_name": "os.lf_sawpos_reset",
      "args": [
        "freq",
        "reset"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1 with reset."
    },
    "os.lf_sawpos_phase_reset": {
      "prefix": "os",
      "name": "lf_sawpos_phase_reset",
      "full_name": "os.lf_sawpos_phase_reset",
      "args": [
        "freq",
        "phase",
        "reset"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1 with phase control and reset."
    },
    "os.lf_saw": {
      "prefix": "os",
      "name": "lf_saw",
      "full_name": "os.lf_saw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between -1 and 1. `lf_saw` is a standard Faust function."
    },
    "os.sawN": {
      "prefix": "os",
      "name": "sawN",
      "full_name": "os.sawN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator using Nth-order polynomial transitions to reduce aliasing."
    },
    "os.sawNp": {
      "prefix": "os",
      "name": "sawNp",
      "full_name": "os.sawNp",
      "args": [
        "N",
        "freq",
        "phase"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as `(os.)sawN` but with a controllable waveform phase."
    },
    "os.freq": {
      "prefix": "os",
      "name": "freq",
      "full_name": "os.freq",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator with Order 2 or 4 Droop Correction Filtering."
    },
    "os.saw2ptr": {
      "prefix": "os",
      "name": "saw2ptr",
      "full_name": "os.saw2ptr",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator using Polynomial Transition Regions (PTR) for order 2."
    },
    "os.saw2dpw": {
      "prefix": "os",
      "name": "saw2dpw",
      "full_name": "os.saw2dpw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator using the Differentiated Polynomial Waveform (DWP) method."
    },
    "os.sawtooth": {
      "prefix": "os",
      "name": "sawtooth",
      "full_name": "os.sawtooth",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed aliasing-suppressed sawtooth oscillator, presently defined as `saw2`. `sawtooth` is a standard Faust function."
    },
    "os.impulse": {
      "prefix": "os",
      "name": "impulse",
      "full_name": "os.impulse",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "One-time impulse generated when the Faust process is started. `impulse` is a standard Faust function."
    },
    "os.pulsetrainN": {
      "prefix": "os",
      "name": "pulsetrainN",
      "full_name": "os.pulsetrainN",
      "args": [
        "N",
        "freq",
        "duty"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed pulse train oscillator."
    },
    "os.pulsetrain": {
      "prefix": "os",
      "name": "pulsetrain",
      "full_name": "os.pulsetrain",
      "args": [
        "freq",
        "duty"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed pulse train oscillator. Based on `pulsetrainN(2)`. `pulsetrain` is a standard Faust function."
    },
    "os.squareN": {
      "prefix": "os",
      "name": "squareN",
      "full_name": "os.squareN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed square wave oscillator."
    },
    "os.square": {
      "prefix": "os",
      "name": "square",
      "full_name": "os.square",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed square wave oscillator. Based on `squareN(2)`. `square` is a standard Faust function."
    },
    "os.imptrainN": {
      "prefix": "os",
      "name": "imptrainN",
      "full_name": "os.imptrainN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed impulse train generator."
    },
    "os.imptrain": {
      "prefix": "os",
      "name": "imptrain",
      "full_name": "os.imptrain",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed impulse train generator. Based on `imptrainN(2)`. `imptrain` is a standard Faust function."
    },
    "os.triangleN": {
      "prefix": "os",
      "name": "triangleN",
      "full_name": "os.triangleN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed triangle wave oscillator."
    },
    "os.triangle": {
      "prefix": "os",
      "name": "triangle",
      "full_name": "os.triangle",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed triangle wave oscillator. Based on `triangleN(2)`. `triangle` is a standard Faust function."
    },
    "os.oscb": {
      "prefix": "os",
      "name": "oscb",
      "full_name": "os.oscb",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the biquad."
    },
    "os.oscrq": {
      "prefix": "os",
      "name": "oscrq",
      "full_name": "os.oscrq",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Sinusoidal (sine and cosine) oscillator based on 2D vector rotation, = undamped \"coupled-form\" resonator = lossless 2nd-order normalized ladder filter."
    },
    "os.oscrs": {
      "prefix": "os",
      "name": "oscrs",
      "full_name": "os.oscrs",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal (sine) oscillator based on 2D vector rotation, = undamped \"coupled-form\" resonator = lossless 2nd-order normalized ladder filter."
    },
    "os.oscrc": {
      "prefix": "os",
      "name": "oscrc",
      "full_name": "os.oscrc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal (cosine) oscillator based on 2D vector rotation, = undamped \"coupled-form\" resonator = lossless 2nd-order normalized ladder filter."
    },
    "os.oscs": {
      "prefix": "os",
      "name": "oscs",
      "full_name": "os.oscs",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the state variable filter = undamped \"modified-coupled-form\" resonator = \"magic circle\" algorithm used in graphics."
    },
    "os.quadosc": {
      "prefix": "os",
      "name": "quadosc",
      "full_name": "os.quadosc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Quadrature (cosine and sine) oscillator based on QuadOsc by Martin Vicanek."
    },
    "os.sidebands": {
      "prefix": "os",
      "name": "sidebands",
      "full_name": "os.sidebands",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Adds harmonics to quad oscillator."
    },
    "os.sidebands_list": {
      "prefix": "os",
      "name": "sidebands_list",
      "full_name": "os.sidebands_list",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates the list of complex harmonics from quad oscillator."
    },
    "os.dsf": {
      "prefix": "os",
      "name": "dsf",
      "full_name": "os.dsf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "An environment with sine/cosine oscsillators with exponentially decaying harmonics based on direct summation formula."
    },
    "os.oscwc": {
      "prefix": "os",
      "name": "oscwc",
      "full_name": "os.oscwc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude cosine oscillator."
    },
    "os.oscws": {
      "prefix": "os",
      "name": "oscws",
      "full_name": "os.oscws",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude sine oscillator."
    },
    "os.oscq": {
      "prefix": "os",
      "name": "oscq",
      "full_name": "os.oscq",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude cosine and sine (quadrature) oscillator."
    },
    "os.oscw": {
      "prefix": "os",
      "name": "oscw",
      "full_name": "os.oscw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude cosine oscillator (default)."
    },
    "os.CZsaw": {
      "prefix": "os",
      "name": "CZsaw",
      "full_name": "os.CZsaw",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ saw oscillator. `CZsaw` is a standard Faust function."
    },
    "os.CZsawP": {
      "prefix": "os",
      "name": "CZsawP",
      "full_name": "os.CZsawP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ saw oscillator, with it's phase aligned to `fund:sin`. `CZsawP` is a standard Faust function."
    },
    "os.CZsquare": {
      "prefix": "os",
      "name": "CZsquare",
      "full_name": "os.CZsquare",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ square oscillator `CZsquare` is a standard Faust function."
    },
    "os.CZsquareP": {
      "prefix": "os",
      "name": "CZsquareP",
      "full_name": "os.CZsquareP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ square oscillator, with it's phase aligned to `fund:sin`. `CZsquareP` is a standard Faust function."
    },
    "os.CZpulse": {
      "prefix": "os",
      "name": "CZpulse",
      "full_name": "os.CZpulse",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ pulse oscillator. `CZpulse` is a standard Faust function."
    },
    "os.CZpulseP": {
      "prefix": "os",
      "name": "CZpulseP",
      "full_name": "os.CZpulseP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ pulse oscillator, with it's phase aligned to `fund:sin`. `CZpulseP` is a standard Faust function."
    },
    "os.CZsinePulse": {
      "prefix": "os",
      "name": "CZsinePulse",
      "full_name": "os.CZsinePulse",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ sine/pulse oscillator. `CZsinePulse` is a standard Faust function."
    },
    "os.CZsinePulseP": {
      "prefix": "os",
      "name": "CZsinePulseP",
      "full_name": "os.CZsinePulseP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ sine/pulse oscillator, with it's phase aligned to `fund:sin`. `CZsinePulseP` is a standard Faust function."
    },
    "os.CZhalfSine": {
      "prefix": "os",
      "name": "CZhalfSine",
      "full_name": "os.CZhalfSine",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ half sine oscillator. `CZhalfSine` is a standard Faust function."
    },
    "os.CZhalfSineP": {
      "prefix": "os",
      "name": "CZhalfSineP",
      "full_name": "os.CZhalfSineP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ half sine oscillator, with it's phase aligned to `fund:sin`. `CZhalfSineP` is a standard Faust function."
    },
    "os.CZresSaw": {
      "prefix": "os",
      "name": "CZresSaw",
      "full_name": "os.CZresSaw",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ resonant sawtooth oscillator. `CZresSaw` is a standard Faust function."
    },
    "os.CZresTriangle": {
      "prefix": "os",
      "name": "CZresTriangle",
      "full_name": "os.CZresTriangle",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ resonant triangle oscillator. `CZresTriangle` is a standard Faust function."
    },
    "os.CZresTrap": {
      "prefix": "os",
      "name": "CZresTrap",
      "full_name": "os.CZresTrap",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ resonant trapeze oscillator `CZresTrap` is a standard Faust function."
    },
    "os.polyblep": {
      "prefix": "os",
      "name": "polyblep",
      "full_name": "os.polyblep",
      "args": [
        "Q",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "PolyBLEP residual function, used for smoothing steps in the audio signal."
    },
    "os.polyblep_saw": {
      "prefix": "os",
      "name": "polyblep_saw",
      "full_name": "os.polyblep_saw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sawtooth oscillator with suppressed aliasing (using `polyblep`)."
    },
    "os.polyblep_square": {
      "prefix": "os",
      "name": "polyblep_square",
      "full_name": "os.polyblep_square",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Square wave oscillator with suppressed aliasing (using `polyblep`)."
    },
    "os.polyblep_triangle": {
      "prefix": "os",
      "name": "polyblep_triangle",
      "full_name": "os.polyblep_triangle",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Triangle wave oscillator with suppressed aliasing (using `polyblep`)."
    },
    "pf.flanger_mono": {
      "prefix": "pf",
      "name": "flanger_mono",
      "full_name": "pf.flanger_mono",
      "args": [
        "dmax",
        "curdel",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono flanging effect."
    },
    "pf.flanger_stereo": {
      "prefix": "pf",
      "name": "flanger_stereo",
      "full_name": "pf.flanger_stereo",
      "args": [
        "dmax",
        "curdel1",
        "curdel2",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo flanging effect. `flanger_stereo` is a standard Faust function."
    },
    "pf.phaser2_mono": {
      "prefix": "pf",
      "name": "phaser2_mono",
      "full_name": "pf.phaser2_mono",
      "args": [
        "Notches",
        "phase",
        "width",
        "frqmin",
        "fratio",
        "frqmax",
        "speed",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "Mono phasing effect."
    },
    "pf.phaser2_stereo": {
      "prefix": "pf",
      "name": "phaser2_stereo",
      "full_name": "pf.phaser2_stereo",
      "args": [
        "Notches",
        "width",
        "frqmin",
        "fratio",
        "frqmax",
        "speed",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "Stereo phasing effect. `phaser2_stereo` is a standard Faust function."
    },
    "pm.speedOfSound": {
      "prefix": "pm",
      "name": "speedOfSound",
      "full_name": "pm.speedOfSound",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Speed of sound in meters per second (340m/s)."
    },
    "pm.maxLength": {
      "prefix": "pm",
      "name": "maxLength",
      "full_name": "pm.maxLength",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "The default maximum length (3) in meters of strings and tubes used in this library. This variable should be overriden to allow longer strings or tubes. Useful conversion tools for physical modeling."
    },
    "pm.f2l": {
      "prefix": "pm",
      "name": "f2l",
      "full_name": "pm.f2l",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Frequency to length in meters."
    },
    "pm.l2f": {
      "prefix": "pm",
      "name": "l2f",
      "full_name": "pm.l2f",
      "args": [
        "length"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Length in meters to frequency."
    },
    "pm.l2s": {
      "prefix": "pm",
      "name": "l2s",
      "full_name": "pm.l2s",
      "args": [
        "l"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Length in meters to number of samples."
    },
    "pm.basicBlock": {
      "prefix": "pm",
      "name": "basicBlock",
      "full_name": "pm.basicBlock",
      "args": [
        "basicBlock : basicBlock : etc."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Empty bidirectional block to be used with [`chain`](#chain): 3 signals ins and 3 signals out."
    },
    "pm.chain": {
      "prefix": "pm",
      "name": "chain",
      "full_name": "pm.chain",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a chain of bidirectional blocks. Blocks must have 3 inputs and outputs. The first input/output carry left going waves, the second input/output carry right going waves, and the third"
    },
    "pm.inLeftWave": {
      "prefix": "pm",
      "name": "inLeftWave",
      "full_name": "pm.inLeftWave",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adds a signal to left going waves anywhere in a [`chain`](#chain) of blocks."
    },
    "pm.inRightWave": {
      "prefix": "pm",
      "name": "inRightWave",
      "full_name": "pm.inRightWave",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adds a signal to right going waves anywhere in a [`chain`](#chain) of blocks."
    },
    "pm.in": {
      "prefix": "pm",
      "name": "in",
      "full_name": "pm.in",
      "args": [
        "A : in(x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adds a signal to left and right going waves anywhere in a [`chain`](#chain) of blocks."
    },
    "pm.outLeftWave": {
      "prefix": "pm",
      "name": "outLeftWave",
      "full_name": "pm.outLeftWave",
      "args": [
        "A : outLeftWave : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sends the signal of left going waves to the output channel of the [`chain`](#chain)."
    },
    "pm.outRightWave": {
      "prefix": "pm",
      "name": "outRightWave",
      "full_name": "pm.outRightWave",
      "args": [
        "A : outRightWave : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sends the signal of right going waves to the output channel of the [`chain`](#chain)."
    },
    "pm.out": {
      "prefix": "pm",
      "name": "out",
      "full_name": "pm.out",
      "args": [
        "A : out : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sends the signal of right and left going waves to the output channel of the [`chain`](#chain)."
    },
    "pm.terminations": {
      "prefix": "pm",
      "name": "terminations",
      "full_name": "pm.terminations",
      "args": [
        "a",
        "b",
        "c"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates terminations on both sides of a [`chain`](#chain) without closing the inputs and outputs of the bidirectional signals chain. As for [`chain`](#chain), this function adds a 1 sample delay to th"
    },
    "pm.lTermination": {
      "prefix": "pm",
      "name": "lTermination",
      "full_name": "pm.lTermination",
      "args": [
        "a",
        "b"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a termination on the left side of a [`chain`](#chain) without closing the inputs and outputs of the bidirectional signals chain. This function adds a 1 sample delay near the termination and ca"
    },
    "pm.rTermination": {
      "prefix": "pm",
      "name": "rTermination",
      "full_name": "pm.rTermination",
      "args": [
        "b",
        "c"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a termination on the right side of a [`chain`](#chain) without closing the inputs and outputs of the bidirectional signals chain. This function adds a 1 sample delay near the termination and c"
    },
    "pm.closeIns": {
      "prefix": "pm",
      "name": "closeIns",
      "full_name": "pm.closeIns",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 3,
      "description": "Closes the inputs of a bidirectional chain in all directions."
    },
    "pm.closeOuts": {
      "prefix": "pm",
      "name": "closeOuts",
      "full_name": "pm.closeOuts",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 3,
      "outputs": 1,
      "description": "Closes the outputs of a bidirectional chain in all directions except for the main signal output (3d output)."
    },
    "pm.endChain": {
      "prefix": "pm",
      "name": "endChain",
      "full_name": "pm.endChain",
      "args": [
        "chain(..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Closes the inputs and outputs of a bidirectional chain in all directions except for the main signal output (3d output)."
    },
    "pm.waveguideN": {
      "prefix": "pm",
      "name": "waveguideN",
      "full_name": "pm.waveguideN",
      "args": [
        "A : waveguideUd(nMax",
        "n"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A series of waveguide functions based on various types of delays (see [`fdelay[n]`](#fdelayn))."
    },
    "pm.waveguide": {
      "prefix": "pm",
      "name": "waveguide",
      "full_name": "pm.waveguide",
      "args": [
        "A : waveguide(nMax",
        "n"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard `pm.lib` waveguide (based on [`waveguideFd4`](#waveguiden))."
    },
    "pm.bridgeFilter": {
      "prefix": "pm",
      "name": "bridgeFilter",
      "full_name": "pm.bridgeFilter",
      "args": [
        "brightness",
        "absorption"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Generic two zeros bridge FIR filter (as implemented in the [STK](https://ccrma.stanford.edu/software/stk/)) that can be used to implement the reflectance violin, guitar, etc. bridges."
    },
    "pm.modeFilter": {
      "prefix": "pm",
      "name": "modeFilter",
      "full_name": "pm.modeFilter",
      "args": [
        "freq",
        "t60",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Resonant bandpass filter that can be used to implement a single resonance (mode)."
    },
    "pm.stringSegment": {
      "prefix": "pm",
      "name": "stringSegment",
      "full_name": "pm.stringSegment",
      "args": [
        "A : stringSegment(maxLength",
        "length"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A string segment without terminations (just a simple waveguide)."
    },
    "pm.openString": {
      "prefix": "pm",
      "name": "openString",
      "full_name": "pm.openString",
      "args": [
        "... : openString(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a basic \"generic\" string with a selectable excitation position. Lowpass filters are built-in and allow to simulate the effect of dispersion on the sound and thus"
    },
    "pm.nylonString": {
      "prefix": "pm",
      "name": "nylonString",
      "full_name": "pm.nylonString",
      "args": [
        "... : nylonString(length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a basic nylon string with selectable excitation position. This element is based on [`openString`](#openstring) and has a fix stiffness corresponding to that of a nyl"
    },
    "pm.steelString": {
      "prefix": "pm",
      "name": "steelString",
      "full_name": "pm.steelString",
      "args": [
        "... : steelString(length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a basic steel string with selectable excitation position. This element is based on [`openString`](#openstring) and has a fix stiffness corresponding to that of a ste"
    },
    "pm.openStringPick": {
      "prefix": "pm",
      "name": "openStringPick",
      "full_name": "pm.openStringPick",
      "args": [
        "... : openStringPick(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a \"generic\" string with selectable excitation position. It also has a built-in pickup whose position is the same as the excitation position. Thus, moving the excitat"
    },
    "pm.openStringPickUp": {
      "prefix": "pm",
      "name": "openStringPickUp",
      "full_name": "pm.openStringPickUp",
      "args": [
        "... : openStringPickUp(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a \"generic\" string with selectable excitation position and stiffness. It also has a built-in pickup whose position can be independenly selected. The only constraint "
    },
    "pm.openStringPickDown": {
      "prefix": "pm",
      "name": "openStringPickDown",
      "full_name": "pm.openStringPickDown",
      "args": [
        "... : openStringPickDown(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a \"generic\" string with selectable excitation position and stiffness. It also has a built-in pickup whose position can be independenly selected. The only constraint "
    },
    "pm.ksReflexionFilter": {
      "prefix": "pm",
      "name": "ksReflexionFilter",
      "full_name": "pm.ksReflexionFilter",
      "args": [
        "_",
        "chain(..."
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "The \"typical\" one-zero Karplus-strong feedforward reflexion filter. This filter will be typically used in a termination (see below)."
    },
    "pm.rStringRigidTermination": {
      "prefix": "pm",
      "name": "rStringRigidTermination",
      "full_name": "pm.rStringRigidTermination",
      "args": [
        "rStringRigidTermination : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a right rigid string termination (no damping, just phase inversion)."
    },
    "pm.lStringRigidTermination": {
      "prefix": "pm",
      "name": "lStringRigidTermination",
      "full_name": "pm.lStringRigidTermination",
      "args": [
        "... : stringSegment : lStringRigidTermination"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a left rigid string termination (no damping, just phase inversion)."
    },
    "pm.elecGuitarBridge": {
      "prefix": "pm",
      "name": "elecGuitarBridge",
      "full_name": "pm.elecGuitarBridge",
      "args": [
        "... : stringSegment : elecGuitarBridge"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple electric guitar bridge. This block is based on [`bridgeFilter`](#bridgeFilter). The bridge doesn't implement transmittance since it is not meant to be connect"
    },
    "pm.elecGuitarNuts": {
      "prefix": "pm",
      "name": "elecGuitarNuts",
      "full_name": "pm.elecGuitarNuts",
      "args": [
        "elecGuitarNuts : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple electric guitar nuts. This block is based on [`bridgeFilter`](#bridgeFilter) and does essentially the same thing as [`elecGuitarBridge`](#elecguitarbridge), b"
    },
    "pm.guitarBridge": {
      "prefix": "pm",
      "name": "guitarBridge",
      "full_name": "pm.guitarBridge",
      "args": [
        "... : stringSegment : guitarBridge"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple acoustic guitar bridge. This bridge damps more hight frequencies than [`elecGuitarBridge`](#elecguitarbridge) and implements a transmittance"
    },
    "pm.guitarNuts": {
      "prefix": "pm",
      "name": "guitarNuts",
      "full_name": "pm.guitarNuts",
      "args": [
        "guitarNuts : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple acoustic guitar nuts. This nuts damps more hight frequencies than [`elecGuitarNuts`](#elecguitarnuts) and implements a transmittance"
    },
    "pm.idealString": {
      "prefix": "pm",
      "name": "idealString",
      "full_name": "pm.idealString",
      "args": [
        "length",
        "reflexion",
        "xPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "An \"ideal\" string with rigid terminations and where the plucking position and the pick-up position are the same. Since terminations are rigid, this string will ring forever."
    },
    "pm.ks": {
      "prefix": "pm",
      "name": "ks",
      "full_name": "pm.ks",
      "args": [
        "length",
        "damping",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A Karplus-Strong string (in that case, the string is implemented as a one dimension waveguide)."
    },
    "pm.ks_ui_MIDI": {
      "prefix": "pm",
      "name": "ks_ui_MIDI",
      "full_name": "pm.ks_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use, MIDI-enabled Karplus-Strong string with buil-in UI."
    },
    "pm.elecGuitarModel": {
      "prefix": "pm",
      "name": "elecGuitarModel",
      "full_name": "pm.elecGuitarModel",
      "args": [
        "length",
        "pluckPosition",
        "mute",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple electric guitar model (without audio effects, of course) with selectable pluck position. This model implements a single string. Additional strings should be created"
    },
    "pm.elecGuitar": {
      "prefix": "pm",
      "name": "elecGuitar",
      "full_name": "pm.elecGuitar",
      "args": [
        "length",
        "pluckPosition",
        "trigger"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple electric guitar model with steel strings (based on [`elecGuitarModel`](#elecguitarmodel)) implementing an excitation model."
    },
    "pm.elecGuitar_ui_MIDI": {
      "prefix": "pm",
      "name": "elecGuitar_ui_MIDI",
      "full_name": "pm.elecGuitar_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled electric guitar physical model with built-in UI."
    },
    "pm.guitarBody": {
      "prefix": "pm",
      "name": "guitarBody",
      "full_name": "pm.guitarBody",
      "args": [
        "... : guitarBody"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "WARNING: not implemented yet! Bidirectional block implementing a simple acoustic guitar body."
    },
    "pm.guitarModel": {
      "prefix": "pm",
      "name": "guitarModel",
      "full_name": "pm.guitarModel",
      "args": [
        "length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with steel strings and selectable excitation position. This model implements a single string. Additional strings should be created by making a polyphonic application out"
    },
    "pm.guitar": {
      "prefix": "pm",
      "name": "guitar",
      "full_name": "pm.guitar",
      "args": [
        "length",
        "pluckPosition",
        "trigger"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with steel strings (based on [`guitarModel`](#guitarmodel)) implementing an excitation model. This model implements a single string. Additional strings should be created"
    },
    "pm.guitar_ui_MIDI": {
      "prefix": "pm",
      "name": "guitar_ui_MIDI",
      "full_name": "pm.guitar_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled steel strings acoustic guitar physical model with built-in UI."
    },
    "pm.nylonGuitarModel": {
      "prefix": "pm",
      "name": "nylonGuitarModel",
      "full_name": "pm.nylonGuitarModel",
      "args": [
        "length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with nylon strings and selectable excitation position. This model implements a single string. Additional strings should be created by making a polyphonic application out"
    },
    "pm.nylonGuitar": {
      "prefix": "pm",
      "name": "nylonGuitar",
      "full_name": "pm.nylonGuitar",
      "args": [
        "length",
        "pluckPosition",
        "trigger"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with nylon strings (based on [`nylonGuitarModel`](#nylonguitarmodel)) implementing an excitation model. This model implements a single string. Additional strings should "
    },
    "pm.nylonGuitar_ui_MIDI": {
      "prefix": "pm",
      "name": "nylonGuitar_ui_MIDI",
      "full_name": "pm.nylonGuitar_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled nylon strings acoustic guitar physical model with built-in UI."
    },
    "pm.modeInterpRes": {
      "prefix": "pm",
      "name": "modeInterpRes",
      "full_name": "pm.modeInterpRes",
      "args": [
        "nModes",
        "x",
        "y"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Modular string instrument resonator based on IR measurements made on 3D printed models. The 2D space allowing for the control of the shape and the scale of the model is enabled by interpolating betwee"
    },
    "pm.modularInterpBody": {
      "prefix": "pm",
      "name": "modularInterpBody",
      "full_name": "pm.modularInterpBody",
      "args": [
        "... : modularInterpBody(nModes",
        "shape",
        "scale"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a modular string instrument resonator (see [`modeInterpRes`](#pm.modeinterpres))."
    },
    "pm.modularInterpStringModel": {
      "prefix": "pm",
      "name": "modularInterpStringModel",
      "full_name": "pm.modularInterpStringModel",
      "args": [
        "length",
        "pluckPosition",
        "shape",
        "scale",
        "bodyExcitation",
        "stringExcitation"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "String instrument model with a modular body (see [`modeInterpRes`](#pm.modeinterpres) and <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>)."
    },
    "pm.modularInterpInstr": {
      "prefix": "pm",
      "name": "modularInterpInstr",
      "full_name": "pm.modularInterpInstr",
      "args": [
        "stringLength",
        "pluckPosition",
        "shape",
        "scale",
        "gain",
        "tapBody",
        "triggerString"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "String instrument with a modular body (see [`modeInterpRes`](#pm.modeinterpres) and <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>)."
    },
    "pm.modularInterpInstr_ui_MIDI": {
      "prefix": "pm",
      "name": "modularInterpInstr_ui_MIDI",
      "full_name": "pm.modularInterpInstr_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled string instrument with a modular body (see [`modeInterpRes`](#pm.modeinterpres) and <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>)"
    },
    "pm.bowTable": {
      "prefix": "pm",
      "name": "bowTable",
      "full_name": "pm.bowTable",
      "args": [
        "offset",
        "slope"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Extremely basic bow table that can be used to implement a wide range of bow types for many different bowed string instruments (violin, cello, etc.)."
    },
    "pm.violinBowTable": {
      "prefix": "pm",
      "name": "violinBowTable",
      "full_name": "pm.violinBowTable",
      "args": [
        "bowPressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Violin bow table based on [`bowTable`](#bowtable)."
    },
    "pm.bowInteraction": {
      "prefix": "pm",
      "name": "bowInteraction",
      "full_name": "pm.bowInteraction",
      "args": [
        "... : stringSegment : bowInteraction(bowTable"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing the interaction of a bow in a [`chain`](#chain)."
    },
    "pm.violinBow": {
      "prefix": "pm",
      "name": "violinBow",
      "full_name": "pm.violinBow",
      "args": [
        "... : stringSegment : violinBow(bowPressure",
        "bowVelocity"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a violin bow and its interaction with a string."
    },
    "pm.violinBowedString": {
      "prefix": "pm",
      "name": "violinBowedString",
      "full_name": "pm.violinBowedString",
      "args": [
        "nuts : violinBowedString(stringLength",
        "bowPressure",
        "bowVelocity",
        "bowPosition"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Violin bowed string bidirectional block with controllable bow position. Terminations are not implemented in this model."
    },
    "pm.violinNuts": {
      "prefix": "pm",
      "name": "violinNuts",
      "full_name": "pm.violinNuts",
      "args": [
        "violinNuts : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing simple violin nuts. This function is based on [`bridgeFilter`](#bridgefilter)."
    },
    "pm.violinBridge": {
      "prefix": "pm",
      "name": "violinBridge",
      "full_name": "pm.violinBridge",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple violin bridge. This function is based on [`bridgeFilter`](#bridgefilter)."
    },
    "pm.violinBody": {
      "prefix": "pm",
      "name": "violinBody",
      "full_name": "pm.violinBody",
      "args": [
        "... : stringSegment : violinBridge : violinBody"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple violin body (just a simple resonant lowpass filter)."
    },
    "pm.violinModel": {
      "prefix": "pm",
      "name": "violinModel",
      "full_name": "pm.violinModel",
      "args": [
        "stringLength",
        "bowPressure",
        "bowVelocity",
        "bridgeReflexion",
        "// bridgeAbsorption",
        "bowPosition"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use simple violin physical model. This model implements a single string. Additional strings should be created by making a polyphonic application out of this function. Pitch is changed"
    },
    "pm.violin_ui": {
      "prefix": "pm",
      "name": "violin_ui",
      "full_name": "pm.violin_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use violin physical model with built-in UI."
    },
    "pm.violin_ui_MIDI": {
      "prefix": "pm",
      "name": "violin_ui_MIDI",
      "full_name": "pm.violin_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled violin physical model with built-in UI."
    },
    "pm.openTube": {
      "prefix": "pm",
      "name": "openTube",
      "full_name": "pm.openTube",
      "args": [
        "A : openTube(maxLength",
        "length"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A tube segment without terminations (same as [`stringSegment`](#stringsegment))."
    },
    "pm.reedTable": {
      "prefix": "pm",
      "name": "reedTable",
      "full_name": "pm.reedTable",
      "args": [
        "offeset",
        "slope"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Extremely basic reed table that can be used to implement a wide range of single reed types for many different instruments (saxophone, clarinet, etc.)."
    },
    "pm.fluteJetTable": {
      "prefix": "pm",
      "name": "fluteJetTable",
      "full_name": "pm.fluteJetTable",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Extremely basic flute jet table."
    },
    "pm.brassLipsTable": {
      "prefix": "pm",
      "name": "brassLipsTable",
      "full_name": "pm.brassLipsTable",
      "args": [
        "tubeLength",
        "lipsTension"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple brass lips/mouthpiece table. Since this implementation is very basic and that the lips and tube of the instrument are coupled to each other, the length of that tube must be provided here."
    },
    "pm.clarinetReed": {
      "prefix": "pm",
      "name": "clarinetReed",
      "full_name": "pm.clarinetReed",
      "args": [
        "stiffness"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Clarinet reed based on [`reedTable`](#reedtable) with controllable stiffness."
    },
    "pm.clarinetMouthPiece": {
      "prefix": "pm",
      "name": "clarinetMouthPiece",
      "full_name": "pm.clarinetMouthPiece",
      "args": [
        "clarinetMouthPiece(reedStiffness",
        "pressure"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a clarinet mouthpiece as well as the various interactions happening with traveling waves. This element is ready to be plugged to a tube..."
    },
    "pm.brassLips": {
      "prefix": "pm",
      "name": "brassLips",
      "full_name": "pm.brassLips",
      "args": [
        "brassLips(tubeLength",
        "lipsTension",
        "pressure"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a brass mouthpiece as well as the various interactions happening with traveling waves. This element is ready to be plugged to a tube..."
    },
    "pm.fluteEmbouchure": {
      "prefix": "pm",
      "name": "fluteEmbouchure",
      "full_name": "pm.fluteEmbouchure",
      "args": [
        "... : tube : fluteEmbouchure(pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a flute embouchure as well as the various interactions happening with traveling waves. This element is ready to be plugged between tubes segments..."
    },
    "pm.wBell": {
      "prefix": "pm",
      "name": "wBell",
      "full_name": "pm.wBell",
      "args": [
        "... : wBell(opening"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic wind instrument bell bidirectional block that should be placed at the end of a [`chain`](#chain)."
    },
    "pm.fluteHead": {
      "prefix": "pm",
      "name": "fluteHead",
      "full_name": "pm.fluteHead",
      "args": [
        "fluteHead : tube : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple flute head implementing waves reflexion."
    },
    "pm.fluteFoot": {
      "prefix": "pm",
      "name": "fluteFoot",
      "full_name": "pm.fluteFoot",
      "args": [
        "... : tube : fluteFoot"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple flute foot implementing waves reflexion and dispersion."
    },
    "pm.clarinetModel": {
      "prefix": "pm",
      "name": "clarinetModel",
      "full_name": "pm.clarinetModel",
      "args": [
        "length",
        "pressure",
        "reedStiffness",
        "bellOpening"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple clarinet physical model without tone holes (pitch is changed by changing the length of the tube of the instrument)."
    },
    "pm.clarinetModel_ui": {
      "prefix": "pm",
      "name": "clarinetModel_ui",
      "full_name": "pm.clarinetModel_ui",
      "args": [
        "pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`clarinetModel`](#clarinetModel) but with a built-in UI. This function doesn't implement a virtual \"blower\", thus `pressure` remains an argument here."
    },
    "pm.clarinet_ui": {
      "prefix": "pm",
      "name": "clarinet_ui",
      "full_name": "pm.clarinet_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use clarinet physical model with built-in UI based on [`clarinetModel`](#clarinetmodel)."
    },
    "pm.clarinet_ui_MIDI": {
      "prefix": "pm",
      "name": "clarinet_ui_MIDI",
      "full_name": "pm.clarinet_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI compliant clarinet physical model with built-in UI."
    },
    "pm.brassModel": {
      "prefix": "pm",
      "name": "brassModel",
      "full_name": "pm.brassModel",
      "args": [
        "tubeLength",
        "lipsTension",
        "mute",
        "pressure"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple generic brass instrument physical model without pistons (pitch is changed by changing the length of the tube of the instrument). This model is kind of hard to control and might not sound very"
    },
    "pm.brassModel_ui": {
      "prefix": "pm",
      "name": "brassModel_ui",
      "full_name": "pm.brassModel_ui",
      "args": [
        "pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`brassModel`](#brassModel) but with a built-in UI. This function doesn't implement a virtual \"blower\", thus `pressure` remains an argument here."
    },
    "pm.brass_ui": {
      "prefix": "pm",
      "name": "brass_ui",
      "full_name": "pm.brass_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use brass instrument physical model with built-in UI based on [`brassModel`](#brassmodel)."
    },
    "pm.brass_ui_MIDI": {
      "prefix": "pm",
      "name": "brass_ui_MIDI",
      "full_name": "pm.brass_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable brass instrument physical model with built-in UI."
    },
    "pm.fluteModel": {
      "prefix": "pm",
      "name": "fluteModel",
      "full_name": "pm.fluteModel",
      "args": [
        "tubeLength",
        "mouthPosition",
        "pressure"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple generic flute instrument physical model without tone holes (pitch is changed by changing the length of the tube of the instrument)."
    },
    "pm.fluteModel_ui": {
      "prefix": "pm",
      "name": "fluteModel_ui",
      "full_name": "pm.fluteModel_ui",
      "args": [
        "pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`fluteModel`](#fluteModel) but with a built-in UI. This function doesn't implement a virtual \"blower\", thus `pressure` remains an argument here."
    },
    "pm.flute_ui": {
      "prefix": "pm",
      "name": "flute_ui",
      "full_name": "pm.flute_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use flute physical model with built-in UI based on [`fluteModel`](#flutemodel)."
    },
    "pm.flute_ui_MIDI": {
      "prefix": "pm",
      "name": "flute_ui_MIDI",
      "full_name": "pm.flute_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable flute physical model with built-in UI."
    },
    "pm.impulseExcitation": {
      "prefix": "pm",
      "name": "impulseExcitation",
      "full_name": "pm.impulseExcitation",
      "args": [
        "gate"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates an impulse excitation of one sample."
    },
    "pm.strikeModel": {
      "prefix": "pm",
      "name": "strikeModel",
      "full_name": "pm.strikeModel",
      "args": [
        "LPcutoff",
        "HPcutoff",
        "sharpness",
        "gain",
        "gate"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a filtered noise excitation."
    },
    "pm.strike": {
      "prefix": "pm",
      "name": "strike",
      "full_name": "pm.strike",
      "args": [
        "exPos",
        "sharpness",
        "gain",
        "gate"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Strikes generator with controllable excitation position."
    },
    "pm.pluckString": {
      "prefix": "pm",
      "name": "pluckString",
      "full_name": "pm.pluckString",
      "args": [
        "stringLength",
        "cutoff",
        "maxFreq",
        "sharpness",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a plucking excitation signal."
    },
    "pm.blower": {
      "prefix": "pm",
      "name": "blower",
      "full_name": "pm.blower",
      "args": [
        "pressure",
        "breathGain",
        "breathCutoff"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A virtual blower creating a DC signal with some breath noise in it."
    },
    "pm.blower_ui": {
      "prefix": "pm",
      "name": "blower_ui",
      "full_name": "pm.blower_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`blower`](#blower) but with a built-in UI."
    },
    "pm.djembeModel": {
      "prefix": "pm",
      "name": "djembeModel",
      "full_name": "pm.djembeModel",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Dirt-simple djembe modal physical model. Mode parameters are empirically calculated and don't correspond to any measurements or 3D model. They kind of sound good though :)."
    },
    "pm.djembe": {
      "prefix": "pm",
      "name": "djembe",
      "full_name": "pm.djembe",
      "args": [
        "freq",
        "strikePosition",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Dirt-simple djembe modal physical model. Mode parameters are empirically calculated and don't correspond to any measurements or 3D model. They kind of sound good though :)."
    },
    "pm.djembe_ui_MIDI": {
      "prefix": "pm",
      "name": "djembe_ui_MIDI",
      "full_name": "pm.djembe_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple MIDI controllable djembe physical model with built-in UI."
    },
    "pm.marimbaBarModel": {
      "prefix": "pm",
      "name": "marimbaBarModel",
      "full_name": "pm.marimbaBarModel",
      "args": [
        "freq",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic marimba tone bar modal model."
    },
    "pm.marimbaResTube": {
      "prefix": "pm",
      "name": "marimbaResTube",
      "full_name": "pm.marimbaResTube",
      "args": [
        "tubeLength",
        "excitation"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple marimba resonance tube."
    },
    "pm.marimbaModel": {
      "prefix": "pm",
      "name": "marimbaModel",
      "full_name": "pm.marimbaModel",
      "args": [
        "freq",
        "exPos"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple marimba physical model implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see [`marimbaBarModel`](#marimbabarmodel) to know mor"
    },
    "pm.marimba": {
      "prefix": "pm",
      "name": "marimba",
      "full_name": "pm.marimba",
      "args": [
        "freq",
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple marimba physical model implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see [`marimbaBarModel`](#marimbabarmodel) to know mor"
    },
    "pm.marimba_ui_MIDI": {
      "prefix": "pm",
      "name": "marimba_ui_MIDI",
      "full_name": "pm.marimba_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple MIDI controllable marimba physical model with built-in UI implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube"
    },
    "pm.churchBellModel": {
      "prefix": "pm",
      "name": "churchBellModel",
      "full_name": "pm.churchBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic church bell modal model generated by `mesh2faust` from `libraries/modalmodels/churchBell`."
    },
    "pm.churchBell": {
      "prefix": "pm",
      "name": "churchBell",
      "full_name": "pm.churchBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic church bell modal model."
    },
    "pm.churchBell_ui": {
      "prefix": "pm",
      "name": "churchBell_ui",
      "full_name": "pm.churchBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Church bell physical model based on [`churchBell`](#pmchurchbell) with built-in UI."
    },
    "pm.englishBellModel": {
      "prefix": "pm",
      "name": "englishBellModel",
      "full_name": "pm.englishBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "English church bell modal model generated by `mesh2faust` from `libraries/modalmodels/englishBell`."
    },
    "pm.englishBell": {
      "prefix": "pm",
      "name": "englishBell",
      "full_name": "pm.englishBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "English church bell modal model."
    },
    "pm.englishBell_ui": {
      "prefix": "pm",
      "name": "englishBell_ui",
      "full_name": "pm.englishBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "English church bell physical model based on [`englishBell`](#pmenglishbell) with built-in UI."
    },
    "pm.frenchBellModel": {
      "prefix": "pm",
      "name": "frenchBellModel",
      "full_name": "pm.frenchBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "French church bell modal model generated by `mesh2faust` from `libraries/modalmodels/frenchBell`."
    },
    "pm.frenchBell": {
      "prefix": "pm",
      "name": "frenchBell",
      "full_name": "pm.frenchBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "French church bell modal model."
    },
    "pm.frenchBell_ui": {
      "prefix": "pm",
      "name": "frenchBell_ui",
      "full_name": "pm.frenchBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "French church bell physical model based on [`frenchBell`](#pmfrenchbell) with built-in UI."
    },
    "pm.germanBellModel": {
      "prefix": "pm",
      "name": "germanBellModel",
      "full_name": "pm.germanBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "German church bell modal model generated by `mesh2faust` from `libraries/modalmodels/germanBell`."
    },
    "pm.germanBell": {
      "prefix": "pm",
      "name": "germanBell",
      "full_name": "pm.germanBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "German church bell modal model."
    },
    "pm.germanBell_ui": {
      "prefix": "pm",
      "name": "germanBell_ui",
      "full_name": "pm.germanBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "German church bell physical model based on [`germanBell`](#pmgermanbell) with built-in UI."
    },
    "pm.russianBellModel": {
      "prefix": "pm",
      "name": "russianBellModel",
      "full_name": "pm.russianBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Russian church bell modal model generated by `mesh2faust` from `libraries/modalmodels/russianBell`."
    },
    "pm.russianBell": {
      "prefix": "pm",
      "name": "russianBell",
      "full_name": "pm.russianBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Russian church bell modal model."
    },
    "pm.russianBell_ui": {
      "prefix": "pm",
      "name": "russianBell_ui",
      "full_name": "pm.russianBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Russian church bell physical model based on [`russianBell`](#pmrussianbell) with built-in UI."
    },
    "pm.standardBellModel": {
      "prefix": "pm",
      "name": "standardBellModel",
      "full_name": "pm.standardBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard church bell modal model generated by `mesh2faust` from `libraries/modalmodels/standardBell`."
    },
    "pm.standardBell": {
      "prefix": "pm",
      "name": "standardBell",
      "full_name": "pm.standardBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard church bell modal model."
    },
    "pm.standardBell_ui": {
      "prefix": "pm",
      "name": "standardBell_ui",
      "full_name": "pm.standardBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard church bell physical model based on [`standardBell`](#pmstandardbell) with built-in UI."
    },
    "pm.formantValues": {
      "prefix": "pm",
      "name": "formantValues",
      "full_name": "pm.formantValues",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Formant data values in an environment."
    },
    "pm.voiceGender": {
      "prefix": "pm",
      "name": "voiceGender",
      "full_name": "pm.voiceGender",
      "args": [
        "voiceType"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Calculate the gender for the provided `voiceType` value. (0: male, 1: female)"
    },
    "pm.skirtWidthMultiplier": {
      "prefix": "pm",
      "name": "skirtWidthMultiplier",
      "full_name": "pm.skirtWidthMultiplier",
      "args": [
        "vowel",
        "freq",
        "gender"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Calculates value to multiply bandwidth to obtain `skirtwidth` for a Fof filter."
    },
    "pm.autobendFreq": {
      "prefix": "pm",
      "name": "autobendFreq",
      "full_name": "pm.autobendFreq",
      "args": [
        "n",
        "freq",
        "voiceType"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Autobends the center frequencies of formants 1 and 2 based on the fundamental frequency of the excitation signal and leaves all other formant frequencies unchanged. Ported from `chant-lib`."
    },
    "pm.vocalEffort": {
      "prefix": "pm",
      "name": "vocalEffort",
      "full_name": "pm.vocalEffort",
      "args": [
        "freq",
        "gender"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Changes the gains of the formants based on the fundamental frequency of the excitation signal. Higher formants are reinforced for higher fundamental frequencies."
    },
    "pm.fof": {
      "prefix": "pm",
      "name": "fof",
      "full_name": "pm.fof",
      "args": [
        "fc",
        "bw",
        "a",
        "g"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Function to generate a single Formant-Wave-Function."
    },
    "pm.fofSH": {
      "prefix": "pm",
      "name": "fofSH",
      "full_name": "pm.fofSH",
      "args": [
        "fc",
        "bw",
        "a",
        "g"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "FOF with sample and hold used on `bw` and a parameter used in the filter-cycling FOF function `fofCycle`."
    },
    "pm.fofCycle": {
      "prefix": "pm",
      "name": "fofCycle",
      "full_name": "pm.fofCycle",
      "args": [
        "fc",
        "bw",
        "a",
        "g",
        "n"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "FOF implementation where time-varying filter parameter noise is mitigated by using a cycle of `n` sample and hold FOF filters."
    },
    "pm.fofSmooth": {
      "prefix": "pm",
      "name": "fofSmooth",
      "full_name": "pm.fofSmooth",
      "args": [
        "fc",
        "bw",
        "sw",
        "g",
        "tau"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "FOF implementation where time-varying filter parameter noise is mitigated by lowpass filtering the filter parameters `bw` and `a` with [smooth](#smooth)."
    },
    "pm.formantFilterFofCycle": {
      "prefix": "pm",
      "name": "formantFilterFofCycle",
      "full_name": "pm.formantFilterFofCycle",
      "args": [
        "voiceType",
        "vowel",
        "nFormants",
        "i",
        "freq"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filter based on a single FOF filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. A cycle of `n` fof filters with sample-and-hold is"
    },
    "pm.formantFilterFofSmooth": {
      "prefix": "pm",
      "name": "formantFilterFofSmooth",
      "full_name": "pm.formantFilterFofSmooth",
      "args": [
        "voiceType",
        "vowel",
        "nFormants",
        "i",
        "freq"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filter based on a single FOF filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Fof filter parameters are lowpass filtered"
    },
    "pm.formantFilterBP": {
      "prefix": "pm",
      "name": "formantFilterBP",
      "full_name": "pm.formantFilterBP",
      "args": [
        "voiceType",
        "vowel",
        "nFormants",
        "i",
        "freq"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filter based on a single resonant bandpass filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspon"
    },
    "pm.formantFilterbank": {
      "prefix": "pm",
      "name": "formantFilterbank",
      "full_name": "pm.formantFilterbank",
      "args": [
        "voiceType",
        "vowel",
        "formantGen",
        "freq"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank which can use different types of filterbank functions and different excitation signals. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to anothe"
    },
    "pm.formantFilterbankFofCycle": {
      "prefix": "pm",
      "name": "formantFilterbankFofCycle",
      "full_name": "pm.formantFilterbankFofCycle",
      "args": [
        "voiceType",
        "vowel",
        "freq"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank based on a bank of fof filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to"
    },
    "pm.formantFilterbankFofSmooth": {
      "prefix": "pm",
      "name": "formantFilterbankFofSmooth",
      "full_name": "pm.formantFilterbankFofSmooth",
      "args": [
        "voiceType",
        "vowel",
        "freq"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank based on a bank of fof filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to"
    },
    "pm.formantFilterbankBP": {
      "prefix": "pm",
      "name": "formantFilterbankBP",
      "full_name": "pm.formantFilterbankBP",
      "args": [
        "voiceType",
        "vowel",
        "freq"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank based on a bank of resonant bandpass filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must cor"
    },
    "pm.SFFormantModel": {
      "prefix": "pm",
      "name": "SFFormantModel",
      "full_name": "pm.SFFormantModel",
      "args": [
        "voiceType",
        "vowel",
        "exType",
        "freq",
        "gain",
        "source",
        "filterbank",
        "isFof"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The `source` and `filterbank` must be specified by the user. `filterbank` must take the same input parameters as [`formantFilterbank`]("
    },
    "pm.SFFormantModelFofCycle": {
      "prefix": "pm",
      "name": "SFFormantModelFofCycle",
      "full_name": "pm.SFFormantModelFofCycle",
      "args": [
        "voiceType",
        "vowel",
        "freq",
        "gain"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The source is just a periodic impulse and the \"filter\" is a bank of FOF filters. Formant parameters are linearly interpolated allowing "
    },
    "pm.SFFormantModelFofSmooth": {
      "prefix": "pm",
      "name": "SFFormantModelFofSmooth",
      "full_name": "pm.SFFormantModelFofSmooth",
      "args": [
        "voiceType",
        "vowel",
        "freq",
        "gain"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The source is just a periodic impulse and the \"filter\" is a bank of FOF filters. Formant parameters are linearly interpolated allowing "
    },
    "pm.SFFormantModelBP": {
      "prefix": "pm",
      "name": "SFFormantModelBP",
      "full_name": "pm.SFFormantModelBP",
      "args": [
        "voiceType",
        "vowel",
        "exType",
        "freq",
        "gain"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The source is just a sawtooth wave and the \"filter\" is a bank of resonant bandpass filters. Formant parameters are linearly interpolate"
    },
    "pm.SFFormantModelFofCycle_ui": {
      "prefix": "pm",
      "name": "SFFormantModelFofCycle_ui",
      "full_name": "pm.SFFormantModelFofCycle_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use source-filter vocal synthesizer with built-in user interface."
    },
    "pm.SFFormantModelFofSmooth_ui": {
      "prefix": "pm",
      "name": "SFFormantModelFofSmooth_ui",
      "full_name": "pm.SFFormantModelFofSmooth_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use source-filter vocal synthesizer with built-in user interface."
    },
    "pm.SFFormantModelBP_ui": {
      "prefix": "pm",
      "name": "SFFormantModelBP_ui",
      "full_name": "pm.SFFormantModelBP_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use source-filter vocal synthesizer with built-in user interface."
    },
    "pm.SFFormantModelFofCycle_ui_MIDI": {
      "prefix": "pm",
      "name": "SFFormantModelFofCycle_ui_MIDI",
      "full_name": "pm.SFFormantModelFofCycle_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable source-filter vocal synthesizer."
    },
    "pm.SFFormantModelFofSmooth_ui_MIDI": {
      "prefix": "pm",
      "name": "SFFormantModelFofSmooth_ui_MIDI",
      "full_name": "pm.SFFormantModelFofSmooth_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable source-filter vocal synthesizer."
    },
    "pm.SFFormantModelBP_ui_MIDI": {
      "prefix": "pm",
      "name": "SFFormantModelBP_ui_MIDI",
      "full_name": "pm.SFFormantModelBP_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable source-filter vocal synthesizer."
    },
    "pm.allpassNL": {
      "prefix": "pm",
      "name": "allpassNL",
      "full_name": "pm.allpassNL",
      "args": [
        "... : allpassNL(nonlinearity"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block adding nonlinearities in both directions in a chain. Nonlinearities are created by modulating the coefficients of a passive allpass filter by the signal it is processing."
    },
    "pm.modalModel": {
      "prefix": "pm",
      "name": "modalModel",
      "full_name": "pm.modalModel",
      "args": [
        "n",
        "freqs",
        "t60s",
        "gains"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Implement multiple resonance modes using resonant bandpass filters."
    },
    "pm.rk_solve": {
      "prefix": "pm",
      "name": "rk_solve",
      "full_name": "pm.rk_solve",
      "args": [
        "ts",
        "ks",
        "ni",
        "h",
        "eq",
        "iv"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Solves the system of ordinary differential equations of any order using the explicit Runge-Kutta methods."
    },
    "pl.SR": {
      "prefix": "pl",
      "name": "SR",
      "full_name": "pl.SR",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current sampling rate (between 1 and 192000Hz). Constant during program execution. Setting this value to a constant will allow the compiler to optimize the code by computing constant expressions at"
    },
    "pl.BS": {
      "prefix": "pl",
      "name": "BS",
      "full_name": "pl.BS",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current block-size (between 1 and 16384 frames). Can change during the execution."
    },
    "pl.tablesize": {
      "prefix": "pl",
      "name": "tablesize",
      "full_name": "pl.tablesize",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator table size. This value is used to define the size of the table used by the oscillators. It is usually a power of 2 and can be lowered to save memory. The default value is 65536."
    },
    "qu.quantize": {
      "prefix": "qu",
      "name": "quantize",
      "full_name": "qu.quantize",
      "args": [
        "rf",
        "nl"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Configurable frequency quantization tool. Snaps input frequencies to exact scale notes. Works for positive audio frequencies."
    },
    "qu.quantizeSmoothed": {
      "prefix": "qu",
      "name": "quantizeSmoothed",
      "full_name": "qu.quantizeSmoothed",
      "args": [
        "rf",
        "nl"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Configurable frequency quantization tool. Smoothly transitions between scale notes. Works for positive audio frequencies."
    },
    "qu.ionian": {
      "prefix": "qu",
      "name": "ionian",
      "full_name": "qu.ionian",
      "args": [
        "rf",
        "ionian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the ionian mode."
    },
    "qu.dorian": {
      "prefix": "qu",
      "name": "dorian",
      "full_name": "qu.dorian",
      "args": [
        "rf",
        "dorian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the dorian mode."
    },
    "qu.phrygian": {
      "prefix": "qu",
      "name": "phrygian",
      "full_name": "qu.phrygian",
      "args": [
        "rf",
        "phrygian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the phrygian mode."
    },
    "qu.lydian": {
      "prefix": "qu",
      "name": "lydian",
      "full_name": "qu.lydian",
      "args": [
        "rf",
        "lydian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the lydian mode."
    },
    "qu.mixo": {
      "prefix": "qu",
      "name": "mixo",
      "full_name": "qu.mixo",
      "args": [
        "rf",
        "mixo"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the mixolydian mode."
    },
    "qu.eolian": {
      "prefix": "qu",
      "name": "eolian",
      "full_name": "qu.eolian",
      "args": [
        "rf",
        "eolian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the eolian mode."
    },
    "qu.locrian": {
      "prefix": "qu",
      "name": "locrian",
      "full_name": "qu.locrian",
      "args": [
        "rf",
        "locrian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the locrian mode."
    },
    "qu.pentanat": {
      "prefix": "qu",
      "name": "pentanat",
      "full_name": "qu.pentanat",
      "args": [
        "rf",
        "pentanat"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the pythagorean tuning for the minor pentatonic scale."
    },
    "qu.kumoi": {
      "prefix": "qu",
      "name": "kumoi",
      "full_name": "qu.kumoi",
      "args": [
        "rf",
        "kumoi"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the kumoijoshi, the japanese pentatonic scale."
    },
    "qu.natural": {
      "prefix": "qu",
      "name": "natural",
      "full_name": "qu.natural",
      "args": [
        "rf",
        "natural"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the natural major scale."
    },
    "qu.dodeca": {
      "prefix": "qu",
      "name": "dodeca",
      "full_name": "qu.dodeca",
      "args": [
        "rf",
        "dodeca"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the dodecaphonic scale."
    },
    "qu.dimin": {
      "prefix": "qu",
      "name": "dimin",
      "full_name": "qu.dimin",
      "args": [
        "rf",
        "dimin"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the diminished scale."
    },
    "qu.penta": {
      "prefix": "qu",
      "name": "penta",
      "full_name": "qu.penta",
      "args": [
        "rf",
        "penta"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the minor pentatonic scale."
    },
    "rm.parReduce": {
      "prefix": "rm",
      "name": "parReduce",
      "full_name": "rm.parReduce",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "`parReduce(op,N)` combines a set of `N` parallel signals into a single one using a binary operation `op`."
    },
    "rm.topReduce": {
      "prefix": "rm",
      "name": "topReduce",
      "full_name": "rm.topReduce",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "`topReduce(op,N)` involves combining a set of `N` parallel signals into a single one using a binary operation `op`. With `topReduce`, the reduction process starts from the top two incoming signals, do"
    },
    "rm.botReduce": {
      "prefix": "rm",
      "name": "botReduce",
      "full_name": "rm.botReduce",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "`botReduce(op,N)` combines a set of `N` parallel signals into a single one using a binary operation `op`. With `botReduce`, the reduction process starts from the bottom two incoming signals, up to the"
    },
    "rm.reduce": {
      "prefix": "rm",
      "name": "reduce",
      "full_name": "rm.reduce",
      "args": [
        "op",
        "n"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Reduce a block of `n` consecutive samples of the incomming signal using a binary operation `op`. For example: `reduce(max,128)` will compute the maximun value of each block of 128 samples. Please note"
    },
    "rm.reducemap": {
      "prefix": "rm",
      "name": "reducemap",
      "full_name": "rm.reducemap",
      "args": [
        "op",
        "foo",
        "n"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Like `reduce` but a `foo` function is applied to the result. From a mathematical point of view: `reducemap(op,foo,n)` is equivalent to `reduce(op,n):foo`"
    },
    "re.jcrev": {
      "prefix": "re",
      "name": "jcrev",
      "full_name": "re.jcrev",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 4,
      "description": "This artificial reverberator take a mono signal and output stereo (`satrev`) and quad (`jcrev`). They were implemented by John Chowning in the MUS10 computer-music language (descended from Music V by "
    },
    "re.satrev": {
      "prefix": "re",
      "name": "satrev",
      "full_name": "re.satrev",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 2,
      "description": "This artificial reverberator take a mono signal and output stereo (`satrev`) and quad (`jcrev`).  They were implemented by John Chowning in the MUS10 computer-music language (descended from Music V by"
    },
    "re.fdnrev0": {
      "prefix": "re",
      "name": "fdnrev0",
      "full_name": "re.fdnrev0",
      "args": [
        "MAXDELAY",
        "delays",
        "BBSO",
        "freqs",
        "durs",
        "loopgainmax",
        "nonl"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Pure Feedback Delay Network Reverberator (generalized for easy scaling). `fdnrev0` is a standard Faust function."
    },
    "re.zita_rev_fdn": {
      "prefix": "re",
      "name": "zita_rev_fdn",
      "full_name": "re.zita_rev_fdn",
      "args": [
        "f1",
        "f2",
        "t60dc",
        "t60m",
        "fsmax"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 2,
      "description": "Internal 8x8 late-reverberation FDN used in the FOSS Linux reverb `zita-rev1` by Fons Adriaensen <fons@linuxaudio.org>.  This is an FDN reverb with allpass comb filters in each feedback delay in addit"
    },
    "re.zita_rev1_stereo": {
      "prefix": "re",
      "name": "zita_rev1_stereo",
      "full_name": "re.zita_rev1_stereo",
      "args": [
        "rdel",
        "f1",
        "f2",
        "t60dc",
        "t60m",
        "fsmax"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Extend `zita_rev_fdn` to include `zita_rev1` input/output mapping in stereo mode. `zita_rev1_stereo` is a standard Faust function."
    },
    "re.zita_rev1_ambi": {
      "prefix": "re",
      "name": "zita_rev1_ambi",
      "full_name": "re.zita_rev1_ambi",
      "args": [
        "rgxyz",
        "rdel",
        "f1",
        "f2",
        "t60dc",
        "t60m",
        "fsmax"
      ],
      "arg_count": 7,
      "inputs": 2,
      "outputs": 4,
      "description": "Extend `zita_rev_fdn` to include `zita_rev1` input/output mapping in \"ambisonics mode\", as provided in the Linux C++ version."
    },
    "re.vital_rev": {
      "prefix": "re",
      "name": "vital_rev",
      "full_name": "re.vital_rev",
      "args": [
        "prelow",
        "prehigh",
        "lowcutoff",
        "highcutoff",
        "lowgain",
        "highgain",
        "chorus_amt",
        "chorus_freq",
        "predelay",
        "time",
        "size",
        "mix"
      ],
      "arg_count": 12,
      "inputs": 2,
      "outputs": 2,
      "description": "A port of the reverb from the Vital synthesizer. All input parameters have been normalized to a continuous [0,1] range, making them easy to modulate. The scaling of the parameters happens inside the f"
    },
    "re.mono_freeverb": {
      "prefix": "re",
      "name": "mono_freeverb",
      "full_name": "re.mono_freeverb",
      "args": [
        "fb1",
        "fb2",
        "damp",
        "spread"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "A simple Schroeder reverberator primarily developed by \"Jezar at Dreampoint\" that is extensively used in the free-software world. It uses four Schroeder allpasses in series and eight parallel Schroede"
    },
    "re.stereo_freeverb": {
      "prefix": "re",
      "name": "stereo_freeverb",
      "full_name": "re.stereo_freeverb",
      "args": [
        "fb1",
        "fb2",
        "damp",
        "spread"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "A simple Schroeder reverberator primarily developed by \"Jezar at Dreampoint\" that is extensively used in the free-software world. It uses four Schroeder allpasses in series and eight parallel Schroede"
    },
    "re.dattorro_rev": {
      "prefix": "re",
      "name": "dattorro_rev",
      "full_name": "re.dattorro_rev",
      "args": [
        "pre_delay",
        "bw",
        "i_diff1",
        "i_diff2",
        "decay",
        "d_diff1",
        "d_diff2",
        "damping"
      ],
      "arg_count": 8,
      "inputs": 2,
      "outputs": 2,
      "description": "Reverberator based on the Dattorro reverb topology. This implementation does not use modulated delay lengths (excursion)."
    },
    "re.dattorro_rev_default": {
      "prefix": "re",
      "name": "dattorro_rev_default",
      "full_name": "re.dattorro_rev_default",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Reverberator based on the Dattorro reverb topology with reverb parameters from the original paper. This implementation does not use modulated delay lengths (excursion) and"
    },
    "re.jpverb": {
      "prefix": "re",
      "name": "jpverb",
      "full_name": "re.jpverb",
      "args": [
        "t60",
        "damp",
        "size",
        "early_diff",
        "mod_depth",
        "mod_freq",
        "low",
        "mid",
        "high",
        "low_cutoff",
        "high_cutoff"
      ],
      "arg_count": 11,
      "inputs": 2,
      "outputs": 2,
      "description": "An algorithmic reverb (stereo in/out), inspired by the lush chorused sound of certain vintage Lexicon and Alesis reverberation units. Designed to sound great with synthetic sound sources, rather than "
    },
    "re.greyhole": {
      "prefix": "re",
      "name": "greyhole",
      "full_name": "re.greyhole",
      "args": [
        "dt",
        "damp",
        "size",
        "early_diff",
        "feedback",
        "mod_depth",
        "mod_freq"
      ],
      "arg_count": 7,
      "inputs": 2,
      "outputs": 2,
      "description": "A complex echo-like effect (stereo in/out), inspired by the classic Eventide effect of a similar name. The effect consists of a diffuser (like a mini-reverb, structurally similar to the one used in `j"
    },
    "re.kb_rom_rev1": {
      "prefix": "re",
      "name": "kb_rom_rev1",
      "full_name": "re.kb_rom_rev1",
      "args": [
        "rt",
        "damp"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Reverberator based on Keith Barr's all-pass single feedback loop reverb topology. Originally designed for the Spin Semiconductor FV-1 chip, this code is an adaptation of the rom_rev1.spn file, part of"
    },
    "re.springreverb": {
      "prefix": "re",
      "name": "springreverb",
      "full_name": "re.springreverb",
      "args": [
        "dwell",
        "blend",
        "tone",
        "tension",
        "springs"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono spring-inspired reverb originally designed for the Chaos Audio Stratus, which defines all parameters in the [0..10] range. They have been remapped to more typical [0..1] ranges in this implementa"
    },
    "ro.cross": {
      "prefix": "ro",
      "name": "cross",
      "full_name": "ro.cross",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cross N signals: `(x1,x2,..,xn) -> (xn,..,x2,x1)`. `cross` is a standard Faust function."
    },
    "ro.crossnn": {
      "prefix": "ro",
      "name": "crossnn",
      "full_name": "ro.crossnn",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cross two `bus(N)`s."
    },
    "ro.crossn1": {
      "prefix": "ro",
      "name": "crossn1",
      "full_name": "ro.crossn1",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Cross `bus(N)` and `bus(1)`."
    },
    "ro.cross1n": {
      "prefix": "ro",
      "name": "cross1n",
      "full_name": "ro.cross1n",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Cross `bus(1)` and `bus(N)`."
    },
    "ro.crossNM": {
      "prefix": "ro",
      "name": "crossNM",
      "full_name": "ro.crossNM",
      "args": [
        "N",
        "M"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cross `bus(N)` and `bus(M)`."
    },
    "ro.interleave": {
      "prefix": "ro",
      "name": "interleave",
      "full_name": "ro.interleave",
      "args": [
        "R",
        "C"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Interleave R x C cables from column order to row order. That is, transpose the input CxR matrix, the first R inputs is the first row."
    },
    "ro.butterfly": {
      "prefix": "ro",
      "name": "butterfly",
      "full_name": "ro.butterfly",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Addition (first half) then substraction (second half) of interleaved signals."
    },
    "ro.hadamard": {
      "prefix": "ro",
      "name": "hadamard",
      "full_name": "ro.hadamard",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Hadamard matrix function of size `N = 2^k`."
    },
    "ro.recursivize": {
      "prefix": "ro",
      "name": "recursivize",
      "full_name": "ro.recursivize",
      "args": [
        "p",
        "q"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Create a recursion from two arbitrary processors `p` and `q`."
    },
    "ro.bubbleSort": {
      "prefix": "ro",
      "name": "bubbleSort",
      "full_name": "ro.bubbleSort",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sort a set of N parallel signals in ascending order on-the-fly through the Bubble Sort algorithm."
    },
    "si.bus": {
      "prefix": "si",
      "name": "bus",
      "full_name": "si.bus",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Put N cables in parallel. `bus` is a standard Faust function."
    },
    "si.block": {
      "prefix": "si",
      "name": "block",
      "full_name": "si.block",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Block - terminate N signals. `block` is a standard Faust function."
    },
    "si.interpolate": {
      "prefix": "si",
      "name": "interpolate",
      "full_name": "si.interpolate",
      "args": [
        "i"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 1,
      "description": "Linear interpolation between two signals."
    },
    "si.repeat": {
      "prefix": "si",
      "name": "repeat",
      "full_name": "si.repeat",
      "args": [
        "N",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Repeat an effect N time(s) and take the parallel sum of all intermediate buses."
    },
    "si.smoo": {
      "prefix": "si",
      "name": "smoo",
      "full_name": "si.smoo",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Smoothing function based on `smooth` ideal to smooth UI signals (sliders, etc.) down. Approximately, this is a 7 Hz one-pole low-pass considering the coefficient calculation:"
    },
    "si.polySmooth": {
      "prefix": "si",
      "name": "polySmooth",
      "full_name": "si.polySmooth",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "A smoothing function based on `smooth` that doesn't smooth when a trigger signal is given. This is very useful when making polyphonic synthesizer to make sure that the value of the parameter"
    },
    "si.smoothAndH": {
      "prefix": "si",
      "name": "smoothAndH",
      "full_name": "si.smoothAndH",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "A smoothing function based on `smooth` that holds its output signal when a trigger is sent to it. This feature is convenient when implementing polyphonic instruments to prevent some"
    },
    "si.bsmooth": {
      "prefix": "si",
      "name": "bsmooth",
      "full_name": "si.bsmooth",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Block smooth linear interpolation during a block of samples (given by the `ma.BS` value)."
    },
    "si.dot": {
      "prefix": "si",
      "name": "dot",
      "full_name": "si.dot",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Dot product for two vectors of size N."
    },
    "si.smooth": {
      "prefix": "si",
      "name": "smooth",
      "full_name": "si.smooth",
      "args": [
        "s"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Exponential smoothing by a unity-dc-gain one-pole lowpass. `smooth` is a standard Faust function."
    },
    "si.smoothq": {
      "prefix": "si",
      "name": "smoothq",
      "full_name": "si.smoothq",
      "args": [
        "time",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Smoothing with continuously variable curves from Exponential to Linear, with a constant time."
    },
    "si.cbus": {
      "prefix": "si",
      "name": "cbus",
      "full_name": "si.cbus",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "N parallel cables for complex signals. `cbus` is a standard Faust function."
    },
    "si.cmul": {
      "prefix": "si",
      "name": "cmul",
      "full_name": "si.cmul",
      "args": [
        "r2",
        "i2"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 2,
      "description": "Multiply two complex signals pointwise. `cmul` is a standard Faust function."
    },
    "si.cconj": {
      "prefix": "si",
      "name": "cconj",
      "full_name": "si.cconj",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 2,
      "description": "Complex conjugation of a (complex) signal. `cconj` is a standard Faust function."
    },
    "si.onePoleSwitching": {
      "prefix": "si",
      "name": "onePoleSwitching",
      "full_name": "si.onePoleSwitching",
      "args": [
        "att",
        "rel"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One pole filter with independent attack and release times."
    },
    "si.rev": {
      "prefix": "si",
      "name": "rev",
      "full_name": "si.rev",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Reverse the input signal by blocks of n>0 samples. `rev(1)` is the indentity function. `rev(n)` has a latency of `n-1` samples."
    },
    "si.vecOp": {
      "prefix": "si",
      "name": "vecOp",
      "full_name": "si.vecOp",
      "args": [
        "vectorsList",
        "op"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "This function is a generalisation of Faust's iterators such as `prod` and `sum`, and it allows to perform operations on an arbitrary number of vectors, provided that they all have the same length. Unl"
    },
    "si.bpar": {
      "prefix": "si",
      "name": "bpar",
      "full_name": "si.bpar",
      "args": [
        "N",
        "f"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Balanced `par` where the repeated expression doesn't depend on a variable. The built-in `par` is implemented as an unbalanced tree, and also has to substitute the variable into the repeated expression"
    },
    "si.bsum": {
      "prefix": "si",
      "name": "bsum",
      "full_name": "si.bsum",
      "args": [
        "N",
        "f"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Balanced `sum`, see `si.bpar`."
    },
    "si.bprod": {
      "prefix": "si",
      "name": "bprod",
      "full_name": "si.bprod",
      "args": [
        "N",
        "f"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Balanced `prod`, see `si.bpar`."
    },
    "so.loop": {
      "prefix": "so",
      "name": "loop",
      "full_name": "so.loop",
      "args": [
        "sf",
        "part"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Play a soundfile in a loop taking into account its sampling rate. `loop` is a standard Faust function."
    },
    "so.loop_speed": {
      "prefix": "so",
      "name": "loop_speed",
      "full_name": "so.loop_speed",
      "args": [
        "sf",
        "part",
        "speed"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Play a soundfile in a loop taking into account its sampling rate, with speed control. `loop_speed` is a standard Faust function."
    },
    "so.loop_speed_level": {
      "prefix": "so",
      "name": "loop_speed_level",
      "full_name": "so.loop_speed_level",
      "args": [
        "sf",
        "part",
        "speed",
        "level"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Play a soundfile in a loop taking into account its sampling rate, with speed and level controls. `loop_speed_level` is a standard Faust function."
    },
    "sp.panner": {
      "prefix": "sp",
      "name": "panner",
      "full_name": "sp.panner",
      "args": [
        "g"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 2,
      "description": "A simple linear stereo panner. `panner` is a standard Faust function."
    },
    "sp.constantPowerPan": {
      "prefix": "sp",
      "name": "constantPowerPan",
      "full_name": "sp.constantPowerPan",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Apply the constant power pan rule to a stereo signal. The channels are not respatialized. Their gains are simply adjusted. A pan of 0 preserves the left channel and silences"
    },
    "sp.spat": {
      "prefix": "sp",
      "name": "spat",
      "full_name": "sp.spat",
      "args": [
        "N",
        "r",
        "d"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "GMEM SPAT: n-outputs spatializer. `spat` is a standard Faust function."
    },
    "sp.wfs": {
      "prefix": "sp",
      "name": "wfs",
      "full_name": "sp.wfs",
      "args": [
        "xref",
        "yref",
        "zref",
        "speakersDist",
        "nSources",
        "nSpeakers",
        "inProc",
        "xs",
        "ys",
        "zs"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "Wave Field Synthesis algorithm for multiple sound sources. Implementation generalized starting from Pierre Lecomte version."
    },
    "sp.wfs_ui": {
      "prefix": "sp",
      "name": "wfs_ui",
      "full_name": "sp.wfs_ui",
      "args": [
        "xref",
        "yref",
        "zref",
        "speakersDist",
        "nSources",
        "nSpeaker"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Wave Field Synthesis algorithm for multiple sound sources with a built-in UI."
    },
    "sp.stereoize": {
      "prefix": "sp",
      "name": "stereoize",
      "full_name": "sp.stereoize",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Transform an arbitrary processor `p` into a stereo processor with 2 inputs and 2 outputs."
    },
    "sy.popFilterDrum": {
      "prefix": "sy",
      "name": "popFilterDrum",
      "full_name": "sy.popFilterDrum",
      "args": [
        "freq",
        "q",
        "gate"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple percussion instrument based on a \"popped\" resonant bandpass filter. `popFilterDrum` is a standard Faust function."
    },
    "sy.dubDub": {
      "prefix": "sy",
      "name": "dubDub",
      "full_name": "sy.dubDub",
      "args": [
        "freq",
        "ctFreq",
        "q",
        "gate"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple synth based on a sawtooth wave filtered by a resonant lowpass. `dubDub` is a standard Faust function."
    },
    "sy.sawTrombone": {
      "prefix": "sy",
      "name": "sawTrombone",
      "full_name": "sy.sawTrombone",
      "args": [
        "freq",
        "gain",
        "gate"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple trombone based on a lowpassed sawtooth wave. `sawTrombone` is a standard Faust function."
    },
    "sy.combString": {
      "prefix": "sy",
      "name": "combString",
      "full_name": "sy.combString",
      "args": [
        "freq",
        "res",
        "gate"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Simplest string physical model ever based on a comb filter. `combString` is a standard Faust function."
    },
    "sy.additiveDrum": {
      "prefix": "sy",
      "name": "additiveDrum",
      "full_name": "sy.additiveDrum",
      "args": [
        "freq",
        "freqRatio",
        "gain",
        "harmDec",
        "att",
        "rel",
        "gate"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple drum using additive synthesis. `additiveDrum` is a standard Faust function."
    },
    "sy.fm": {
      "prefix": "sy",
      "name": "fm",
      "full_name": "sy.fm",
      "args": [
        "freqs",
        "indices"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "An FM synthesizer with an arbitrary number of modulators connected as a sequence. `fm` is a standard Faust function."
    },
    "sy.kick": {
      "prefix": "sy",
      "name": "kick",
      "full_name": "sy.kick",
      "args": [
        "pitch",
        "click",
        "attack",
        "decay",
        "drive",
        "gate"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Kick drum synthesis via a pitched sine sweep."
    },
    "sy.clap": {
      "prefix": "sy",
      "name": "clap",
      "full_name": "sy.clap",
      "args": [
        "tone",
        "attack",
        "decay",
        "gate"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Clap synthesis via filtered white noise."
    },
    "sy.hat": {
      "prefix": "sy",
      "name": "hat",
      "full_name": "sy.hat",
      "args": [
        "pitch",
        "tone",
        "attack",
        "decay",
        "gate"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Hi hat drum synthesis via phase modulation."
    },
    "ve.moog_vcf": {
      "prefix": "ve",
      "name": "moog_vcf",
      "full_name": "ve.moog_vcf",
      "args": [
        "res",
        "fr"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Moog \"Voltage Controlled Filter\" (VCF) as two biquads. Implementation of the ideal Moog VCF transfer function factored into second-order sections. As a result, it is more accurate than `moog_vcf` abov"
    },
    "ve.moogLadder": {
      "prefix": "ve",
      "name": "moogLadder",
      "full_name": "ve.moogLadder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog model of the 4th-order Moog Ladder (without any nonlinearities), which is arguably the most well-known ladder filter in analog synthesizers. Several 1st-order filters are cascaded in se"
    },
    "ve.lowpassLadder4": {
      "prefix": "ve",
      "name": "lowpassLadder4",
      "full_name": "ve.lowpassLadder4",
      "args": [
        "k",
        "CF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Topology-preserving transform implementation of a four-pole ladder lowpass. This is essentially the same filter as the moogLadder above except for the parameters, which will be expressed in Hz, for th"
    },
    "ve.moogHalfLadder": {
      "prefix": "ve",
      "name": "moogHalfLadder",
      "full_name": "ve.moogHalfLadder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog model of the 2nd-order Moog Half Ladder (simplified version of `(ve.)moogLadder`). Several 1st-order filters are cascaded in series. Feedback is then used, in part, to control the cut-o"
    },
    "ve.diodeLadder": {
      "prefix": "ve",
      "name": "diodeLadder",
      "full_name": "ve.diodeLadder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "4th order virtual analog diode ladder filter. In addition to the individual states used within each independent 1st-order filter, there are also additional feedback paths found in the block diagram. T"
    },
    "ve.korg35LPF": {
      "prefix": "ve",
      "name": "korg35LPF",
      "full_name": "ve.korg35LPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog models of the Korg 35 low-pass filter found in the MS-10 and MS-20 synthesizers."
    },
    "ve.korg35HPF": {
      "prefix": "ve",
      "name": "korg35HPF",
      "full_name": "ve.korg35HPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog models of the Korg 35 high-pass filter found in the MS-10 and MS-20 synthesizers."
    },
    "ve.oberheim": {
      "prefix": "ve",
      "name": "oberheim",
      "full_name": "ve.oberheim",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 4,
      "description": "Generic multi-outputs Oberheim filter that produces the BSF, BPF, HPF and LPF outputs (see description above)."
    },
    "ve.oberheimBSF": {
      "prefix": "ve",
      "name": "oberheimBSF",
      "full_name": "ve.oberheimBSF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Band-Stop Oberheim filter (see description above). Specialize the generic implementation: keep the first BSF output, the compiler will only generate the needed code."
    },
    "ve.oberheimBPF": {
      "prefix": "ve",
      "name": "oberheimBPF",
      "full_name": "ve.oberheimBPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Band-Pass Oberheim filter (see description above). Specialize the generic implementation: keep the second BPF output, the compiler will only generate the needed code."
    },
    "ve.oberheimHPF": {
      "prefix": "ve",
      "name": "oberheimHPF",
      "full_name": "ve.oberheimHPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "High-Pass Oberheim filter (see description above). Specialize the generic implementation: keep the third HPF output, the compiler will only generate the needed code."
    },
    "ve.oberheimLPF": {
      "prefix": "ve",
      "name": "oberheimLPF",
      "full_name": "ve.oberheimLPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Low-Pass Oberheim filter (see description above). Specialize the generic implementation: keep the fourth LPF output, the compiler will only generate the needed code."
    },
    "ve.sallenKeyOnePole": {
      "prefix": "ve",
      "name": "sallenKeyOnePole",
      "full_name": "ve.sallenKeyOnePole",
      "args": [
        "normFreq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 2,
      "description": "Sallen-Key generic One Pole filter that produces the LPF and HPF outputs (see description above)."
    },
    "ve.sallenKeyOnePoleLPF": {
      "prefix": "ve",
      "name": "sallenKeyOnePoleLPF",
      "full_name": "ve.sallenKeyOnePoleLPF",
      "args": [
        "normFreq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key One Pole lowpass filter (see description above). Specialize the generic implementation: keep the first LPF output, the compiler will only generate the needed code."
    },
    "ve.sallenKeyOnePoleHPF": {
      "prefix": "ve",
      "name": "sallenKeyOnePoleHPF",
      "full_name": "ve.sallenKeyOnePoleHPF",
      "args": [
        "normFreq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key One Pole Highpass filter (see description above). The dry input signal is routed in parallel to the output. The LPF'd signal is subtracted from the input so that the HPF remains."
    },
    "ve.sallenKey2ndOrder": {
      "prefix": "ve",
      "name": "sallenKey2ndOrder",
      "full_name": "ve.sallenKey2ndOrder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 3,
      "description": "Sallen-Key generic 2nd order filter that produces the LPF, BPF and HPF outputs."
    },
    "ve.sallenKey2ndOrderLPF": {
      "prefix": "ve",
      "name": "sallenKey2ndOrderLPF",
      "full_name": "ve.sallenKey2ndOrderLPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key 2nd order lowpass filter (see description above). Specialize the generic implementation: keep the first LPF output, the compiler will only generate the needed code."
    },
    "ve.sallenKey2ndOrderBPF": {
      "prefix": "ve",
      "name": "sallenKey2ndOrderBPF",
      "full_name": "ve.sallenKey2ndOrderBPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key 2nd order bandpass filter (see description above). Specialize the generic implementation: keep the second BPF output, the compiler will only generate the needed code."
    },
    "ve.sallenKey2ndOrderHPF": {
      "prefix": "ve",
      "name": "sallenKey2ndOrderHPF",
      "full_name": "ve.sallenKey2ndOrderHPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key 2nd order highpass filter (see description above). Specialize the generic implementation: keep the third HPF output, the compiler will only generate the needed code."
    },
    "ve.biquad": {
      "prefix": "ve",
      "name": "biquad",
      "full_name": "ve.biquad",
      "args": [
        "b0",
        "b1",
        "b2",
        "a1",
        "a2"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Basic biquad section implementing the difference equation: `y[n] = b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] - a1 * y[n-1] - a2 * y[n-2]`"
    },
    "ve.lowpass2Matched": {
      "prefix": "ve",
      "name": "lowpass2Matched",
      "full_name": "ve.lowpass2Matched",
      "args": [
        "CF",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant lowpass filter."
    },
    "ve.highpass2Matched": {
      "prefix": "ve",
      "name": "highpass2Matched",
      "full_name": "ve.highpass2Matched",
      "args": [
        "CF",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant highpass filter."
    },
    "ve.bandpass2Matched": {
      "prefix": "ve",
      "name": "bandpass2Matched",
      "full_name": "ve.bandpass2Matched",
      "args": [
        "CF",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant bandpass filter."
    },
    "ve.peaking2Matched": {
      "prefix": "ve",
      "name": "peaking2Matched",
      "full_name": "ve.peaking2Matched",
      "args": [
        "G",
        "CF",
        "Q"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant bandpass filter."
    },
    "ve.lowshelf2Matched": {
      "prefix": "ve",
      "name": "lowshelf2Matched",
      "full_name": "ve.lowshelf2Matched",
      "args": [
        "G",
        "CF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order Butterworth lowshelf filter."
    },
    "ve.highshelf2Matched": {
      "prefix": "ve",
      "name": "highshelf2Matched",
      "full_name": "ve.highshelf2Matched",
      "args": [
        "G",
        "CF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order Butterworth highshelf filter."
    },
    "ve.wah4": {
      "prefix": "ve",
      "name": "wah4",
      "full_name": "ve.wah4",
      "args": [
        "fr"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Wah effect, 4th order. `wah4` is a standard Faust function."
    },
    "ve.autowah": {
      "prefix": "ve",
      "name": "autowah",
      "full_name": "ve.autowah",
      "args": [
        "level"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Auto-wah effect. `autowah` is a standard Faust function."
    },
    "ve.crybaby": {
      "prefix": "ve",
      "name": "crybaby",
      "full_name": "ve.crybaby",
      "args": [
        "wah"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Digitized CryBaby wah pedal. `crybaby` is a standard Faust function."
    },
    "ve.vocoder": {
      "prefix": "ve",
      "name": "vocoder",
      "full_name": "ve.vocoder",
      "args": [
        "nBands",
        "att",
        "rel",
        "BWRatio",
        "source",
        "excitation"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "A very simple vocoder where the spectrum of the modulation signal is analyzed using a filter bank. `vocoder` is a standard Faust function."
    },
    "vl.version": {
      "prefix": "vl",
      "name": "version",
      "full_name": "vl.version",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 3,
      "description": "Return the version number of the Faust standard libraries as a MAJOR, MINOR, PATCH versioning triplet."
    },
    "wd.resistor": {
      "prefix": "wd",
      "name": "resistor",
      "full_name": "wd.resistor",
      "args": [
        "A : r1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistor."
    },
    "wd.resistor_Vout": {
      "prefix": "wd",
      "name": "resistor_Vout",
      "full_name": "wd.resistor_Vout",
      "args": [
        "A : rout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistor + voltage Out."
    },
    "wd.resistor_Iout": {
      "prefix": "wd",
      "name": "resistor_Iout",
      "full_name": "wd.resistor_Iout",
      "args": [
        "A : rout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Resistor + current Out."
    },
    "wd.u_voltage": {
      "prefix": "wd",
      "name": "u_voltage",
      "full_name": "wd.u_voltage",
      "args": [
        "v1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Voltage Source."
    },
    "wd.u_current": {
      "prefix": "wd",
      "name": "u_current",
      "full_name": "wd.u_current",
      "args": [
        "i1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Current Source."
    },
    "wd.resVoltage": {
      "prefix": "wd",
      "name": "resVoltage",
      "full_name": "wd.resVoltage",
      "args": [
        "A : v1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistive Voltage Source."
    },
    "wd.resVoltage_Vout": {
      "prefix": "wd",
      "name": "resVoltage_Vout",
      "full_name": "wd.resVoltage_Vout",
      "args": [
        "A : vout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistive Voltage Source + voltage output."
    },
    "wd.u_resVoltage": {
      "prefix": "wd",
      "name": "u_resVoltage",
      "full_name": "wd.u_resVoltage",
      "args": [
        "v1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Resistive Voltage Source."
    },
    "wd.resCurrent": {
      "prefix": "wd",
      "name": "resCurrent",
      "full_name": "wd.resCurrent",
      "args": [
        "A : i1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistive Current Source."
    },
    "wd.u_resCurrent": {
      "prefix": "wd",
      "name": "u_resCurrent",
      "full_name": "wd.u_resCurrent",
      "args": [
        "i1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Resistive Current Source."
    },
    "wd.u_switch": {
      "prefix": "wd",
      "name": "u_switch",
      "full_name": "wd.u_switch",
      "args": [
        "s1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Switch."
    },
    "wd.capacitor": {
      "prefix": "wd",
      "name": "capacitor",
      "full_name": "wd.capacitor",
      "args": [
        "A : c1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Capacitor."
    },
    "wd.capacitor_Vout": {
      "prefix": "wd",
      "name": "capacitor_Vout",
      "full_name": "wd.capacitor_Vout",
      "args": [
        "A : cout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Capacitor + voltage out."
    },
    "wd.inductor": {
      "prefix": "wd",
      "name": "inductor",
      "full_name": "wd.inductor",
      "args": [
        "A : l1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Inductor."
    },
    "wd.inductor_Vout": {
      "prefix": "wd",
      "name": "inductor_Vout",
      "full_name": "wd.inductor_Vout",
      "args": [
        "A : lout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Inductor + Voltage out."
    },
    "wd.u_idealDiode": {
      "prefix": "wd",
      "name": "u_idealDiode",
      "full_name": "wd.u_idealDiode",
      "args": [
        "u_idealDiode : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Diode."
    },
    "wd.u_chua": {
      "prefix": "wd",
      "name": "u_chua",
      "full_name": "wd.u_chua",
      "args": [
        "chua1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Chua Diode."
    },
    "wd.lambert": {
      "prefix": "wd",
      "name": "lambert",
      "full_name": "wd.lambert",
      "args": [
        "n",
        "itr"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "An implementation of the lambert function. It uses Halley's method of iteration to approximate the output. Included in the WD library for use in non-linear diode models."
    },
    "wd.u_diodePair": {
      "prefix": "wd",
      "name": "u_diodePair",
      "full_name": "wd.u_diodePair",
      "args": [
        "d1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted pair of diodes facing in opposite directions."
    },
    "wd.u_diodeSingle": {
      "prefix": "wd",
      "name": "u_diodeSingle",
      "full_name": "wd.u_diodeSingle",
      "args": [
        "d1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted single diode."
    },
    "wd.u_diodeAntiparallel": {
      "prefix": "wd",
      "name": "u_diodeAntiparallel",
      "full_name": "wd.u_diodeAntiparallel",
      "args": [
        "d1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted set of antiparallel diodes with M diodes facing forwards and N diodes facing backwards."
    },
    "wd.u_parallel2Port": {
      "prefix": "wd",
      "name": "u_parallel2Port",
      "full_name": "wd.u_parallel2Port",
      "args": [
        "u_parallel2Port : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted 2-port parallel connection."
    },
    "wd.parallel2Port": {
      "prefix": "wd",
      "name": "parallel2Port",
      "full_name": "wd.parallel2Port",
      "args": [
        "A : parallel2Port : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port parallel connection."
    },
    "wd.u_series2Port": {
      "prefix": "wd",
      "name": "u_series2Port",
      "full_name": "wd.u_series2Port",
      "args": [
        "u_series2Port : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted 2-port series connection."
    },
    "wd.series2Port": {
      "prefix": "wd",
      "name": "series2Port",
      "full_name": "wd.series2Port",
      "args": [
        "A : series2Port : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port series connection."
    },
    "wd.parallelCurrent": {
      "prefix": "wd",
      "name": "parallelCurrent",
      "full_name": "wd.parallelCurrent",
      "args": [
        "A : i1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port parallel connection + ideal current source."
    },
    "wd.seriesVoltage": {
      "prefix": "wd",
      "name": "seriesVoltage",
      "full_name": "wd.seriesVoltage",
      "args": [
        "A : v1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port series connection + ideal voltage source."
    },
    "wd.u_transformer": {
      "prefix": "wd",
      "name": "u_transformer",
      "full_name": "wd.u_transformer",
      "args": [
        "t1 : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted ideal transformer."
    },
    "wd.transformer": {
      "prefix": "wd",
      "name": "transformer",
      "full_name": "wd.transformer",
      "args": [
        "A : t1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted ideal transformer."
    },
    "wd.u_transformerActive": {
      "prefix": "wd",
      "name": "u_transformerActive",
      "full_name": "wd.u_transformerActive",
      "args": [
        "t1 : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted ideal active transformer."
    },
    "wd.transformerActive": {
      "prefix": "wd",
      "name": "transformerActive",
      "full_name": "wd.transformerActive",
      "args": [
        "A : t1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted ideal active transformer."
    },
    "wd.parallel": {
      "prefix": "wd",
      "name": "parallel",
      "full_name": "wd.parallel",
      "args": [
        "A : parallel : (B",
        "C"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 3-port parallel connection."
    },
    "wd.series": {
      "prefix": "wd",
      "name": "series",
      "full_name": "wd.series",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 3-port series connection."
    },
    "wd.u_sixportPassive": {
      "prefix": "wd",
      "name": "u_sixportPassive",
      "full_name": "wd.u_sixportPassive",
      "args": [
        "0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted six-port rigid connection."
    },
    "wd.genericNode": {
      "prefix": "wd",
      "name": "genericNode",
      "full_name": "wd.genericNode",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating an adapted node from another faust function or scattering matrix."
    },
    "wd.genericNode_Vout": {
      "prefix": "wd",
      "name": "genericNode_Vout",
      "full_name": "wd.genericNode_Vout",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating a terminating/leaf node which gives the voltage across itself as a model output."
    },
    "wd.genericNode_Iout": {
      "prefix": "wd",
      "name": "genericNode_Iout",
      "full_name": "wd.genericNode_Iout",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating a terminating/leaf node which gives the current through itself as a model output."
    },
    "wd.u_genericNode": {
      "prefix": "wd",
      "name": "u_genericNode",
      "full_name": "wd.u_genericNode",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating an unadapted node from another Faust function or scattering matrix."
    },
    "wd.builddown": {
      "prefix": "wd",
      "name": "builddown",
      "full_name": "wd.builddown",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for building the structure for calculating waves traveling down the WD connection tree."
    },
    "wd.buildup": {
      "prefix": "wd",
      "name": "buildup",
      "full_name": "wd.buildup",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for building the structure for calculating waves traveling up the WD connection tree."
    },
    "wd.getres": {
      "prefix": "wd",
      "name": "getres",
      "full_name": "wd.getres",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for determining the upward-facing port resistance of a partial WD connection tree."
    },
    "wd.parres": {
      "prefix": "wd",
      "name": "parres",
      "full_name": "wd.parres",
      "args": [
        "A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for determining the upward-facing port resistance of a partial WD connection tree."
    },
    "wd.buildout": {
      "prefix": "wd",
      "name": "buildout",
      "full_name": "wd.buildout",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for creating the output matrix for a WD model from a WD connection tree."
    },
    "wd.buildtree": {
      "prefix": "wd",
      "name": "buildtree",
      "full_name": "wd.buildtree",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for building the DSP model from a WD connection tree structure."
    },
    "wa.lowpass2": {
      "prefix": "wa",
      "name": "lowpass2",
      "full_name": "wa.lowpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order resonant lowpass filter with 12dB/octave rolloff. Frequencies below the cutoff pass through, frequencies above it are attenuated."
    },
    "wa.highpass2": {
      "prefix": "wa",
      "name": "highpass2",
      "full_name": "wa.highpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order resonant highpass filter with 12dB/octave rolloff. Frequencies below the cutoff are attenuated, frequencies above it pass through."
    },
    "wa.bandpass2": {
      "prefix": "wa",
      "name": "bandpass2",
      "full_name": "wa.bandpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order bandpass filter. Frequencies outside the given range of frequencies are attenuated, the frequencies inside it pass through."
    },
    "wa.notch2": {
      "prefix": "wa",
      "name": "notch2",
      "full_name": "wa.notch2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard notch filter, also called a band-stop or band-rejection filter. It is the opposite of a bandpass filter: frequencies outside the give range of frequencies pass through, frequencies inside it "
    },
    "wa.allpass2": {
      "prefix": "wa",
      "name": "allpass2",
      "full_name": "wa.allpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order allpass filter. It lets all frequencies through, but changes the phase-relationship between the various frequencies."
    },
    "wa.peaking2": {
      "prefix": "wa",
      "name": "peaking2",
      "full_name": "wa.peaking2",
      "args": [
        "f0",
        "gain",
        "Q",
        "dtune"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Frequencies inside the range get a boost or an attenuation, frequencies outside it are unchanged."
    },
    "wa.lowshelf2": {
      "prefix": "wa",
      "name": "lowshelf2",
      "full_name": "wa.lowshelf2",
      "args": [
        "f0",
        "gain",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard second-order lowshelf filter. Frequencies lower than the frequency get a boost, or an attenuation, frequencies over it are unchanged."
    },
    "wa.highshelf2": {
      "prefix": "wa",
      "name": "highshelf2",
      "full_name": "wa.highshelf2",
      "args": [
        "f0",
        "gain",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard second-order highshelf filter. Frequencies higher than the frequency get a boost or an attenuation, frequencies lower than it are unchanged."
    }
  }
}