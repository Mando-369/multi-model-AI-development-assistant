{
  "version": "1.0",
  "source": "/Users/thomasmandolini/Dev/Local Coding Assistant/multi-model-AI-development-assistant/faust_documentation/faustlibraries",
  "libraries": {
    "aanl": {
      "file": "aanl.lib",
      "prefix": "aa",
      "function_count": 44
    },
    "all": {
      "file": "all.lib",
      "prefix": null,
      "function_count": 0
    },
    "analyzers": {
      "file": "analyzers.lib",
      "prefix": "an",
      "function_count": 25
    },
    "basics": {
      "file": "basics.lib",
      "prefix": "ba",
      "function_count": 96
    },
    "compressors": {
      "file": "compressors.lib",
      "prefix": "co",
      "function_count": 29
    },
    "delays": {
      "file": "delays.lib",
      "prefix": "de",
      "function_count": 7
    },
    "demos": {
      "file": "demos.lib",
      "prefix": "dm",
      "function_count": 41
    },
    "doc": {
      "file": "doc.lib",
      "prefix": null,
      "function_count": 0
    },
    "envelopes": {
      "file": "envelopes.lib",
      "prefix": "en",
      "function_count": 20
    },
    "fds": {
      "file": "fds.lib",
      "prefix": "fd",
      "function_count": 16
    },
    "filters": {
      "file": "filters.lib",
      "prefix": "fi",
      "function_count": 137
    },
    "hoa": {
      "file": "hoa.lib",
      "prefix": "ho",
      "function_count": 29
    },
    "instruments": {
      "file": "instruments.lib",
      "prefix": null,
      "function_count": 0
    },
    "interpolators": {
      "file": "interpolators.lib",
      "prefix": "it",
      "function_count": 16
    },
    "linearalgebra": {
      "file": "linearalgebra.lib",
      "prefix": "la",
      "function_count": 7
    },
    "maths": {
      "file": "maths.lib",
      "prefix": "ma",
      "function_count": 54
    },
    "maxmsp": {
      "file": "maxmsp.lib",
      "prefix": null,
      "function_count": 0
    },
    "mi": {
      "file": "mi.lib",
      "prefix": "mi",
      "function_count": 15
    },
    "misceffects": {
      "file": "misceffects.lib",
      "prefix": "ef",
      "function_count": 39
    },
    "motion": {
      "file": "motion.lib",
      "prefix": "mo",
      "function_count": 22
    },
    "noises": {
      "file": "noises.lib",
      "prefix": "no",
      "function_count": 17
    },
    "oscillators": {
      "file": "oscillators.lib",
      "prefix": "os",
      "function_count": 97
    },
    "phaflangers": {
      "file": "phaflangers.lib",
      "prefix": "pf",
      "function_count": 4
    },
    "physmodels": {
      "file": "physmodels.lib",
      "prefix": "pm",
      "function_count": 153
    },
    "platform": {
      "file": "platform.lib",
      "prefix": "pl",
      "function_count": 3
    },
    "quantizers": {
      "file": "quantizers.lib",
      "prefix": "qu",
      "function_count": 23
    },
    "reducemaps": {
      "file": "reducemaps.lib",
      "prefix": null,
      "function_count": 5
    },
    "reverbs": {
      "file": "reverbs.lib",
      "prefix": "re",
      "function_count": 22
    },
    "routes": {
      "file": "routes.lib",
      "prefix": "ro",
      "function_count": 10
    },
    "sf": {
      "file": "sf.lib",
      "prefix": null,
      "function_count": 0
    },
    "signals": {
      "file": "signals.lib",
      "prefix": "si",
      "function_count": 20
    },
    "soundfiles": {
      "file": "soundfiles.lib",
      "prefix": "so",
      "function_count": 13
    },
    "spats": {
      "file": "spats.lib",
      "prefix": "sp",
      "function_count": 6
    },
    "stdfaust": {
      "file": "stdfaust.lib",
      "prefix": null,
      "function_count": 0
    },
    "synths": {
      "file": "synths.lib",
      "prefix": "sy",
      "function_count": 9
    },
    "tonestacks": {
      "file": "tonestacks.lib",
      "prefix": null,
      "function_count": 0
    },
    "tubes": {
      "file": "tubes.lib",
      "prefix": null,
      "function_count": 0
    },
    "vaeffects": {
      "file": "vaeffects.lib",
      "prefix": "ve",
      "function_count": 30
    },
    "version": {
      "file": "version.lib",
      "prefix": "vl",
      "function_count": 1
    },
    "wdmodels": {
      "file": "wdmodels.lib",
      "prefix": "wd",
      "function_count": 44
    },
    "webaudio": {
      "file": "webaudio.lib",
      "prefix": "wa",
      "function_count": 8
    }
  },
  "functions": {
    "aa.clip": {
      "prefix": "aa",
      "name": "clip",
      "full_name": "aa.clip",
      "args": [
        "l",
        "h",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Clipping function.",
      "param_docs": {},
      "example": ""
    },
    "aa.Rsqrt": {
      "prefix": "aa",
      "name": "Rsqrt",
      "full_name": "aa.Rsqrt",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued sqrt().",
      "param_docs": {},
      "example": ""
    },
    "aa.Rlog": {
      "prefix": "aa",
      "name": "Rlog",
      "full_name": "aa.Rlog",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued log().",
      "param_docs": {},
      "example": ""
    },
    "aa.Rtan": {
      "prefix": "aa",
      "name": "Rtan",
      "full_name": "aa.Rtan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued tan().",
      "param_docs": {},
      "example": ""
    },
    "aa.Racos": {
      "prefix": "aa",
      "name": "Racos",
      "full_name": "aa.Racos",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued acos().",
      "param_docs": {},
      "example": ""
    },
    "aa.Rasin": {
      "prefix": "aa",
      "name": "Rasin",
      "full_name": "aa.Rasin",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued asin().",
      "param_docs": {},
      "example": ""
    },
    "aa.Racosh": {
      "prefix": "aa",
      "name": "Racosh",
      "full_name": "aa.Racosh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued acosh()",
      "param_docs": {},
      "example": ""
    },
    "aa.Rcosh": {
      "prefix": "aa",
      "name": "Rcosh",
      "full_name": "aa.Rcosh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued cosh().",
      "param_docs": {},
      "example": ""
    },
    "aa.Rsinh": {
      "prefix": "aa",
      "name": "Rsinh",
      "full_name": "aa.Rsinh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued sinh().",
      "param_docs": {},
      "example": ""
    },
    "aa.Ratanh": {
      "prefix": "aa",
      "name": "Ratanh",
      "full_name": "aa.Ratanh",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Real-valued atanh().",
      "param_docs": {},
      "example": ""
    },
    "aa.ADAA1": {
      "prefix": "aa",
      "name": "ADAA1",
      "full_name": "aa.ADAA1",
      "args": [
        "EPS",
        "f",
        "F1"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Generalised first-order Antiderivative Anti-Aliasing (ADAA) function.",
      "param_docs": {
        "EPS": "a threshold for switching between safe and ill-conditioned paths",
        "f": "a function that we want to process with ADAA",
        "F1": "f's first antiderivative"
      },
      "example": "aa = library(\"aanl.lib\");\nba = library(\"basics.lib\");\nma = library(\"maths.lib\");\nos = library(\"oscillators.lib\");\nADAA1_test = aa.ADAA1(0.001, f, F1, os.osc(110))\nwith {\nf(x) = aa.clip(-1.0, 1.0, x);\nF1(x) = ba.if((x <= 1.0) & (x >= -1.0), 0.5 * x^2, x * ma.signum(x) - 0.5);\n};"
    },
    "aa.ADAA2": {
      "prefix": "aa",
      "name": "ADAA2",
      "full_name": "aa.ADAA2",
      "args": [
        "EPS",
        "f",
        "F1",
        "F2"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Generalised second-order Antiderivative Anti-Aliasing (ADAA) function.",
      "param_docs": {
        "EPS": "a threshold for switching between safe and ill-conditioned paths",
        "f": "a function that we want to process with ADAA",
        "F1": "f's first antiderivative",
        "F2": "f's second antiderivative"
      },
      "example": "aa = library(\"aanl.lib\");\nba = library(\"basics.lib\");\nma = library(\"maths.lib\");\nos = library(\"oscillators.lib\");\nADAA2_test = aa.ADAA2(0.001, f, F1, F2, os.osc(110))\nwith {\nf(x) = aa.clip(-1.0, 1.0, x);\nF1(x) = ba.if((x <= 1.0) & (x >= -1.0), 0.5 * x^2, x * ma.signum(x) - 0.5);\nF2(x) = ba.if((x <= 1.0) & (x >= -1.0), (1.0 / 3.0) * x^3, ((0.5 * x^2) - 1.0 / 6.0) * ma.signum(x));\n};"
    },
    "aa.hardclip": {
      "prefix": "aa",
      "name": "hardclip",
      "full_name": "aa.hardclip",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA hard-clip.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nhardclip_test = aa.hardclip(os.osc(110));"
    },
    "aa.hardclip2": {
      "prefix": "aa",
      "name": "hardclip2",
      "full_name": "aa.hardclip2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA hard-clip.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nhardclip2_test = aa.hardclip2(os.osc(110));"
    },
    "aa.cubic1": {
      "prefix": "aa",
      "name": "cubic1",
      "full_name": "aa.cubic1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA cubic saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\ncubic1_test = aa.cubic1(os.osc(110));"
    },
    "aa.parabolic": {
      "prefix": "aa",
      "name": "parabolic",
      "full_name": "aa.parabolic",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA parabolic saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nparabolic_test = aa.parabolic(os.osc(110));"
    },
    "aa.parabolic2": {
      "prefix": "aa",
      "name": "parabolic2",
      "full_name": "aa.parabolic2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA parabolic saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nparabolic2_test = aa.parabolic2(os.osc(110));"
    },
    "aa.hyperbolic": {
      "prefix": "aa",
      "name": "hyperbolic",
      "full_name": "aa.hyperbolic",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA hyperbolic saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nhyperbolic_test = aa.hyperbolic(os.osc(110));"
    },
    "aa.hyperbolic2": {
      "prefix": "aa",
      "name": "hyperbolic2",
      "full_name": "aa.hyperbolic2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA hyperbolic saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nhyperbolic2_test = aa.hyperbolic2(os.osc(110));"
    },
    "aa.sinarctan": {
      "prefix": "aa",
      "name": "sinarctan",
      "full_name": "aa.sinarctan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA sin(atan()) saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nsinarctan_test = aa.sinarctan(os.osc(110));"
    },
    "aa.sinarctan2": {
      "prefix": "aa",
      "name": "sinarctan2",
      "full_name": "aa.sinarctan2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA sin(atan()) saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nsinarctan2_test = aa.sinarctan2(os.osc(110));"
    },
    "aa.softclipQuadratic1": {
      "prefix": "aa",
      "name": "softclipQuadratic1",
      "full_name": "aa.softclipQuadratic1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA quadratic softclip.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nsoftclipQuadratic1_test = aa.softclipQuadratic1(os.osc(110));"
    },
    "aa.softclipQuadratic2": {
      "prefix": "aa",
      "name": "softclipQuadratic2",
      "full_name": "aa.softclipQuadratic2",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA quadratic softclip.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nsoftclipQuadratic2_test = aa.softclipQuadratic2(os.osc(110));"
    },
    "aa.tanh1": {
      "prefix": "aa",
      "name": "tanh1",
      "full_name": "aa.tanh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA tanh() saturator.",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\ntanh1_test = aa.tanh1(os.osc(110));"
    },
    "aa.arctan": {
      "prefix": "aa",
      "name": "arctan",
      "full_name": "aa.arctan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA atan().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\narctan_test = aa.arctan(os.osc(110));"
    },
    "aa.arctan2": {
      "prefix": "aa",
      "name": "arctan2",
      "full_name": "aa.arctan2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA atan().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\narctan2_test = aa.arctan2(os.osc(110));"
    },
    "aa.asinh1": {
      "prefix": "aa",
      "name": "asinh1",
      "full_name": "aa.asinh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA asinh() saturator (unbounded).",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nasinh1_test = aa.asinh1(os.osc(110));"
    },
    "aa.asinh2": {
      "prefix": "aa",
      "name": "asinh2",
      "full_name": "aa.asinh2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA asinh() saturator (unbounded).",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nasinh2_test = aa.asinh2(os.osc(110));"
    },
    "aa.cosine1": {
      "prefix": "aa",
      "name": "cosine1",
      "full_name": "aa.cosine1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA cos().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\ncosine1_test = aa.cosine1(os.osc(110));"
    },
    "aa.cosine2": {
      "prefix": "aa",
      "name": "cosine2",
      "full_name": "aa.cosine2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA cos().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\ncosine2_test = aa.cosine2(os.osc(110));"
    },
    "aa.arccos": {
      "prefix": "aa",
      "name": "arccos",
      "full_name": "aa.arccos",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA acos().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\narccos_test = aa.arccos(os.osc(110));"
    },
    "aa.arccos2": {
      "prefix": "aa",
      "name": "arccos2",
      "full_name": "aa.arccos2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA acos().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\narccos2_test = aa.arccos2(os.osc(110));"
    },
    "aa.acosh1": {
      "prefix": "aa",
      "name": "acosh1",
      "full_name": "aa.acosh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA acosh().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nacosh1_test = aa.acosh1(1.0 + abs(os.osc(110)));"
    },
    "aa.acosh2": {
      "prefix": "aa",
      "name": "acosh2",
      "full_name": "aa.acosh2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA acosh().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nacosh2_test = aa.acosh2(1.0 + abs(os.osc(110)));"
    },
    "aa.sine": {
      "prefix": "aa",
      "name": "sine",
      "full_name": "aa.sine",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA sin().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nsine_test = aa.sine(os.osc(110));"
    },
    "aa.sine2": {
      "prefix": "aa",
      "name": "sine2",
      "full_name": "aa.sine2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA sin().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\nsine2_test = aa.sine2(os.osc(110));"
    },
    "aa.arcsin": {
      "prefix": "aa",
      "name": "arcsin",
      "full_name": "aa.arcsin",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA asin().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\narcsin_test = aa.arcsin(os.osc(110));"
    },
    "aa.arcsin2": {
      "prefix": "aa",
      "name": "arcsin2",
      "full_name": "aa.arcsin2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA asin().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\narcsin2_test = aa.arcsin2(os.osc(110));"
    },
    "aa.tangent": {
      "prefix": "aa",
      "name": "tangent",
      "full_name": "aa.tangent",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA tan().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nma = library(\"maths.lib\");\nos = library(\"oscillators.lib\");\ntangent_test = aa.tangent(0.25 * ma.PI * os.osc(110));"
    },
    "aa.atanh1": {
      "prefix": "aa",
      "name": "atanh1",
      "full_name": "aa.atanh1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order ADAA atanh().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\natanh1_test = aa.atanh1(0.8 * os.osc(110));"
    },
    "aa.atanh2": {
      "prefix": "aa",
      "name": "atanh2",
      "full_name": "aa.atanh2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order ADAA atanh().",
      "param_docs": {},
      "example": "aa = library(\"aanl.lib\");\nos = library(\"oscillators.lib\");\natanh2_test = aa.atanh2(0.8 * os.osc(110));"
    },
    "aa.softclipEnv.softclip": {
      "prefix": "aa",
      "name": "softclipEnv.softclip",
      "full_name": "aa.softclipEnv.softclip",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "softclipEnv softclip filter",
      "param_docs": {},
      "example": ""
    },
    "aa.softclipEnv.F1": {
      "prefix": "aa",
      "name": "softclipEnv.F1",
      "full_name": "aa.softclipEnv.F1",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "softclipEnv F1 filter",
      "param_docs": {},
      "example": ""
    },
    "aa.softclipEnv.F2": {
      "prefix": "aa",
      "name": "softclipEnv.F2",
      "full_name": "aa.softclipEnv.F2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "softclipEnv F2 filter",
      "param_docs": {},
      "example": ""
    },
    "an.abs_envelope_rect": {
      "prefix": "an",
      "name": "abs_envelope_rect",
      "full_name": "an.abs_envelope_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with moving-average algorithm.",
      "param_docs": {
        "period": "sets the averaging frame in seconds"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nabs_envelope_rect_test = an.abs_envelope_rect(0.05, os.osc(220));"
    },
    "an.abs_envelope_tau": {
      "prefix": "an",
      "name": "abs_envelope_tau",
      "full_name": "an.abs_envelope_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with one-pole lowpass and tau response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 1/e) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nabs_envelope_tau_test = an.abs_envelope_tau(0.05, os.osc(220));"
    },
    "an.abs_envelope_t60": {
      "prefix": "an",
      "name": "abs_envelope_t60",
      "full_name": "an.abs_envelope_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with one-pole lowpass and t60 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 60 dB) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nabs_envelope_t60_test = an.abs_envelope_t60(0.05, os.osc(220));"
    },
    "an.abs_envelope_t19": {
      "prefix": "an",
      "name": "abs_envelope_t19",
      "full_name": "an.abs_envelope_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Absolute value average with one-pole lowpass and t19 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 1/e^2.2) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nabs_envelope_t19_test = an.abs_envelope_t19(0.05, os.osc(220));"
    },
    "an.amp_follower": {
      "prefix": "an",
      "name": "amp_follower",
      "full_name": "an.amp_follower",
      "args": [
        "rel"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Classic analog audio envelope follower with infinitely fast rise and exponential decay.  The amplitude envelope instantaneously follows the absolute value going up, but then floats down exponentially.",
      "param_docs": {
        "rel": "release time = amplitude-envelope time-constant (sec) going down"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\namp_follower_test = os.osc(220) : an.amp_follower(0.05);"
    },
    "an.amp_follower_ud": {
      "prefix": "an",
      "name": "amp_follower_ud",
      "full_name": "an.amp_follower_ud",
      "args": [
        "att",
        "rel"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Envelope follower with different up and down time-constants (also called a \"peak detector\").",
      "param_docs": {
        "att": "attack time = amplitude-envelope time constant (sec) going up",
        "rel": "release time = amplitude-envelope time constant (sec) going down"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\namp_follower_ud_test = os.osc(220) : an.amp_follower_ud(0.002, 0.05);"
    },
    "an.amp_follower_ar": {
      "prefix": "an",
      "name": "amp_follower_ar",
      "full_name": "an.amp_follower_ar",
      "args": [
        "att",
        "rel"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Envelope follower with independent attack and release times. The release can be shorter than the attack (unlike in `amp_follower_ud` above).",
      "param_docs": {
        "att": "attack time = amplitude-envelope time constant (sec) going up",
        "rel": "release time = amplitude-envelope time constant (sec) going down"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\namp_follower_ar_test = os.osc(220) : an.amp_follower_ar(0.002, 0.05);"
    },
    "an.ms_envelope_rect": {
      "prefix": "an",
      "name": "ms_envelope_rect",
      "full_name": "an.ms_envelope_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square with moving-average algorithm.",
      "param_docs": {
        "period": "sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nms_envelope_rect_test = an.ms_envelope_rect(0.05, os.osc(220));"
    },
    "an.ms_envelope_tau": {
      "prefix": "an",
      "name": "ms_envelope_tau",
      "full_name": "an.ms_envelope_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square average with one-pole lowpass and tau response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 1/e) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nms_envelope_tau_test = an.ms_envelope_tau(0.05, os.osc(220));"
    },
    "an.ms_envelope_t60": {
      "prefix": "an",
      "name": "ms_envelope_t60",
      "full_name": "an.ms_envelope_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square with one-pole lowpass and t60 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 60 dB) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nms_envelope_t60_test = an.ms_envelope_t60(0.05, os.osc(220));"
    },
    "an.ms_envelope_t19": {
      "prefix": "an",
      "name": "ms_envelope_t19",
      "full_name": "an.ms_envelope_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Mean square with one-pole lowpass and t19 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 1/e^2.2) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nms_envelope_t19_test = an.ms_envelope_t19(0.05, os.osc(220));"
    },
    "an.rms_envelope_rect": {
      "prefix": "an",
      "name": "rms_envelope_rect",
      "full_name": "an.rms_envelope_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with moving-average algorithm.",
      "param_docs": {
        "period": "sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nrms_envelope_rect_test = an.rms_envelope_rect(0.05, os.osc(220));"
    },
    "an.rms_envelope_tau": {
      "prefix": "an",
      "name": "rms_envelope_tau",
      "full_name": "an.rms_envelope_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with one-pole lowpass and tau response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 1/e) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nrms_envelope_tau_test = an.rms_envelope_tau(0.05, os.osc(220));"
    },
    "an.rms_envelope_t60": {
      "prefix": "an",
      "name": "rms_envelope_t60",
      "full_name": "an.rms_envelope_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with one-pole lowpass and t60 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 60 dB) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nrms_envelope_t60_test = an.rms_envelope_t60(0.05, os.osc(220));"
    },
    "an.rms_envelope_t19": {
      "prefix": "an",
      "name": "rms_envelope_t19",
      "full_name": "an.rms_envelope_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Root mean square with one-pole lowpass and t19 response (see [filters.lib](https://faustlibraries.grame.fr/libs/filters/)).",
      "param_docs": {
        "period": "(time to decay by 1/e^2.2) sets the averaging frame in secs"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nrms_envelope_t19_test = an.rms_envelope_t19(0.05, os.osc(220));"
    },
    "an.zcr": {
      "prefix": "an",
      "name": "zcr",
      "full_name": "an.zcr",
      "args": [
        "tau"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Zero-crossing rate (ZCR) with one-pole lowpass averaging based on the tau constant. It outputs an index between 0 and 1 at a desired analysis frame. The ZCR of a signal correlates with the noisiness [",
      "param_docs": {
        "tau": "(time to decay by e^-1) sets the averaging frame in seconds."
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nzcr_test = an.zcr(0.01, os.osc(220));"
    },
    "an.pitchTracker": {
      "prefix": "an",
      "name": "pitchTracker",
      "full_name": "an.pitchTracker",
      "args": [
        "N",
        "tau"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "This function implements a pitch-tracking algorithm by means of zero-crossing rate analysis and adaptive low-pass filtering. The design is based on the algorithm described in [this tutorial (section 2",
      "param_docs": {
        "N": "a constant numerical expression, sets the order of the low-pass filter, which",
        "tau": "response time in seconds based on exponentially-weighted averaging with tau time-constant. See <https://ccrma.stanford.edu/~jos/st/Exponentials.html>."
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\npitchTracker_test = an.pitchTracker(4, 0.02, os.osc(220));"
    },
    "an.spectralCentroid": {
      "prefix": "an",
      "name": "spectralCentroid",
      "full_name": "an.spectralCentroid",
      "args": [
        "nonlinearity",
        "tau"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "This function implements a time-domain spectral centroid by means of RMS measurements and adaptive crossover filtering. The weight difference of the upper and lower spectral powers are used to recursi",
      "param_docs": {
        "nonlinearity": "a boolean to activate or deactivate nonlinear integration. The",
        "tau": "response time in seconds based on exponentially-weighted averaging with tau time-constant. See <https://ccrma.stanford.edu/~jos/st/Exponentials.html>."
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nspectralCentroid_test = (os.osc(440) + os.osc(880)) : an.spectralCentroid(1, 0.01);"
    },
    "an.mth_octave_analyzer": {
      "prefix": "an",
      "name": "mth_octave_analyzer",
      "full_name": "an.mth_octave_analyzer",
      "args": [
        "O",
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Octave analyzer. `mth_octave_analyzer[N]` are standard Faust functions.",
      "param_docs": {
        "O": "(odd) order of filter used to split each frequency band into two",
        "M": "number of band-slices per octave",
        "ftop": "highest band-split crossover frequency (e.g., 20 kHz)",
        "N": "total number of bands (including dc and Nyquist)"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_analyzer_test = os.osc(440) : an.mth_octave_analyzer(3, 3, 8000, 5);"
    },
    "an.mth_octave_spectral_level6e": {
      "prefix": "an",
      "name": "mth_octave_spectral_level6e",
      "full_name": "an.mth_octave_spectral_level6e",
      "args": [
        "M",
        "ftop",
        "NBands",
        "tau",
        "dB_offset"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Spectral level display.",
      "param_docs": {
        "M": "bands per octave",
        "ftop": "lower edge frequency of top band",
        "NBands": "number of passbands (including highpass and dc bands),",
        "tau": "spectral display averaging-time (time constant) in seconds,",
        "dB_offset": "constant dB offset in all band level meters."
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_spectral_level6e_test = os.osc(440) : an.mth_octave_spectral_level6e(3, 8000, 5, 0.05, 0);"
    },
    "an.mth_octave_spectral_level_demo": {
      "prefix": "an",
      "name": "mth_octave_spectral_level_demo",
      "full_name": "an.mth_octave_spectral_level_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A bunch of special cases based on the different analyzer functions described above:",
      "param_docs": {},
      "example": ""
    },
    "an.analyzer": {
      "prefix": "an",
      "name": "analyzer",
      "full_name": "an.analyzer",
      "args": [
        "O",
        "freqs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Analyzer.",
      "param_docs": {
        "O": "band-split filter order (ODD integer required for filterbank[i])",
        "freqs": "(fc1,fc2,...,fcNs) [in numerically ascending order], where"
      },
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nanalyzer_test = os.osc(440) : an.analyzer(3, (500, 2000));"
    },
    "an.ifft": {
      "prefix": "an",
      "name": "ifft",
      "full_name": "an.ifft",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Inverse Fast Fourier Transform (IFFT).",
      "param_docs": {},
      "example": "an = library(\"analyzers.lib\");\nos = library(\"oscillators.lib\");\nifft_test = (an.rtocv(8, os.osc(220)) : an.fft(8)) : an.ifft(8);"
    },
    "an.logsweep": {
      "prefix": "an",
      "name": "logsweep",
      "full_name": "an.logsweep",
      "args": [
        "fs",
        "fe",
        "dur"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Logarithmic sine sweep generator.",
      "param_docs": {
        "fs": "start frequency in Hz",
        "fe": "end frequency in Hz",
        "dur": "duration of the sweep in seconds"
      },
      "example": "an = library(\"analyzers.lib\");\nlogsweep_test = an.logsweep(20, 2000, 5);"
    },
    "an.linsweep": {
      "prefix": "an",
      "name": "linsweep",
      "full_name": "an.linsweep",
      "args": [
        "fs",
        "fe",
        "dur"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear sine sweep generator.",
      "param_docs": {
        "fs": "start frequency in Hz",
        "fe": "end frequency in Hz",
        "dur": "duration of the sweep in seconds"
      },
      "example": "an = library(\"analyzers.lib\");\nlinsweep_test = an.linsweep(20, 2000, 5);"
    },
    "ba.samp2sec": {
      "prefix": "ba",
      "name": "samp2sec",
      "full_name": "ba.samp2sec",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a number of samples to a duration in seconds at the current sampling rate (see `ma.SR`). `samp2sec` is a standard Faust function.",
      "param_docs": {
        "n": "number of samples"
      },
      "example": "ba = library(\"basics.lib\");\nsamp2sec_test = ba.samp2sec(512);"
    },
    "ba.sec2samp": {
      "prefix": "ba",
      "name": "sec2samp",
      "full_name": "ba.sec2samp",
      "args": [
        "d"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a duration in seconds to a number of samples at the current sampling rate (see `ma.SR`). `samp2sec` is a standard Faust function.",
      "param_docs": {
        "d": "duration in seconds"
      },
      "example": "ba = library(\"basics.lib\");\nsec2samp_test = ba.sec2samp(0.01);"
    },
    "ba.db2linear": {
      "prefix": "ba",
      "name": "db2linear",
      "full_name": "ba.db2linear",
      "args": [
        "l"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "dB-to-linear value converter. It can be used to convert an amplitude in dB to a linear gain ]0-N]. `db2linear` is a standard Faust function.",
      "param_docs": {
        "l": "amplitude in dB"
      },
      "example": "ba = library(\"basics.lib\");\ndb2linear_test = ba.db2linear(-6);"
    },
    "ba.linear2db": {
      "prefix": "ba",
      "name": "linear2db",
      "full_name": "ba.linear2db",
      "args": [
        "g"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "linea-to-dB value converter. It can be used to convert a linear gain ]0-N] to an amplitude in dB. `linear2db` is a standard Faust function.",
      "param_docs": {
        "g": "a linear gain"
      },
      "example": "ba = library(\"basics.lib\");\nlinear2db_test = ba.linear2db(0.5);"
    },
    "ba.lin2LogGain": {
      "prefix": "ba",
      "name": "lin2LogGain",
      "full_name": "ba.lin2LogGain",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a linear gain (0-1) to a log gain (0-1).",
      "param_docs": {
        "n": "the linear gain"
      },
      "example": "ba = library(\"basics.lib\");\nlin2LogGain_test = ba.lin2LogGain(0.5);"
    },
    "ba.log2LinGain": {
      "prefix": "ba",
      "name": "log2LinGain",
      "full_name": "ba.log2LinGain",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a log gain (0-1) to a linear gain (0-1).",
      "param_docs": {
        "n": "the log gain"
      },
      "example": "ba = library(\"basics.lib\");\nlog2LinGain_test = ba.log2LinGain(0.25);"
    },
    "ba.tau2pole": {
      "prefix": "ba",
      "name": "tau2pole",
      "full_name": "ba.tau2pole",
      "args": [
        "tau2pole(tau"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Returns a real pole giving exponential decay. Note that t60 (time to decay 60 dB) is ~6.91 time constants. `tau2pole` is a standard Faust function.",
      "param_docs": {
        "tau": "time-constant in seconds"
      },
      "example": "ba = library(\"basics.lib\");\ntau2pole_test = ba.tau2pole(0.01);"
    },
    "ba.pole2tau": {
      "prefix": "ba",
      "name": "pole2tau",
      "full_name": "ba.pole2tau",
      "args": [
        "pole"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Returns the time-constant, in seconds, corresponding to the given real, positive pole in (0-1). `pole2tau` is a standard Faust function.",
      "param_docs": {
        "pole": "the pole"
      },
      "example": "ba = library(\"basics.lib\");\npole2tau_test = ba.pole2tau(0.9);"
    },
    "ba.midikey2hz": {
      "prefix": "ba",
      "name": "midikey2hz",
      "full_name": "ba.midikey2hz",
      "args": [
        "mk"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a MIDI key number to a frequency in Hz (MIDI key 69 = A440). `midikey2hz` is a standard Faust function.",
      "param_docs": {
        "mk": "the MIDI key number"
      },
      "example": "ba = library(\"basics.lib\");\nmidikey2hz_test = ba.midikey2hz(60);"
    },
    "ba.hz2midikey": {
      "prefix": "ba",
      "name": "hz2midikey",
      "full_name": "ba.hz2midikey",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency in Hz to a MIDI key number (MIDI key 69 = A440). `hz2midikey` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "ba = library(\"basics.lib\");\nhz2midikey_test = ba.hz2midikey(440);"
    },
    "ba.semi2ratio": {
      "prefix": "ba",
      "name": "semi2ratio",
      "full_name": "ba.semi2ratio",
      "args": [
        "semi"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts semitones in a frequency multiplicative ratio. `semi2ratio` is a standard Faust function.",
      "param_docs": {
        "semi": "number of semitone"
      },
      "example": "ba = library(\"basics.lib\");\nsemi2ratio_test = ba.semi2ratio(7);"
    },
    "ba.ratio2semi": {
      "prefix": "ba",
      "name": "ratio2semi",
      "full_name": "ba.ratio2semi",
      "args": [
        "ratio"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency multiplicative ratio in semitones. `ratio2semi` is a standard Faust function.",
      "param_docs": {
        "ratio": "frequency multiplicative ratio"
      },
      "example": "ba = library(\"basics.lib\");\nratio2semi_test = ba.ratio2semi(2.0);"
    },
    "ba.cent2ratio": {
      "prefix": "ba",
      "name": "cent2ratio",
      "full_name": "ba.cent2ratio",
      "args": [
        "cent"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts cents in a frequency multiplicative ratio.",
      "param_docs": {
        "cent": "number of cents"
      },
      "example": "ba = library(\"basics.lib\");\ncent2ratio_test = ba.cent2ratio(100);"
    },
    "ba.ratio2cent": {
      "prefix": "ba",
      "name": "ratio2cent",
      "full_name": "ba.ratio2cent",
      "args": [
        "ratio"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency multiplicative ratio in cents.",
      "param_docs": {
        "ratio": "frequency multiplicative ratio"
      },
      "example": "ba = library(\"basics.lib\");\nratio2cent_test = ba.ratio2cent(1.5);"
    },
    "ba.pianokey2hz": {
      "prefix": "ba",
      "name": "pianokey2hz",
      "full_name": "ba.pianokey2hz",
      "args": [
        "pk"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a piano key number to a frequency in Hz (piano key 49 = A440).",
      "param_docs": {
        "pk": "the piano key number"
      },
      "example": "ba = library(\"basics.lib\");\npianokey2hz_test = ba.pianokey2hz(49);"
    },
    "ba.hz2pianokey": {
      "prefix": "ba",
      "name": "hz2pianokey",
      "full_name": "ba.hz2pianokey",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a frequency in Hz to a piano key number (piano key 49 = A440).",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "ba = library(\"basics.lib\");\nhz2pianokey_test = ba.hz2pianokey(440);"
    },
    "ba.counter": {
      "prefix": "ba",
      "name": "counter",
      "full_name": "ba.counter",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Starts counting 0, 1, 2, 3..., and raise the current integer value at each upfront of the trigger.",
      "param_docs": {
        "trig": "the trigger signal, each upfront will move the counter to the next integer"
      },
      "example": "ba = library(\"basics.lib\");\ncounter_test = ba.counter(button(\"trig\"));"
    },
    "ba.countdown": {
      "prefix": "ba",
      "name": "countdown",
      "full_name": "ba.countdown",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Starts counting down from n included to 0. While trig is 1 the output is n. The countdown starts with the transition of trig from 1 to 0. At the end of the countdown the output value will remain at 0 ",
      "param_docs": {
        "n": "the starting point of the countdown",
        "trig": "the trigger signal (1: start at `n`; 0: decrease until 0)"
      },
      "example": "ba = library(\"basics.lib\");\ncountdown_test = ba.countdown(8, button(\"trig\"));"
    },
    "ba.countup": {
      "prefix": "ba",
      "name": "countup",
      "full_name": "ba.countup",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Starts counting up from 0 to n included. While trig is 1 the output is 0. The countup starts with the transition of trig from 1 to 0. At the end of the countup the output value will remain at n until ",
      "param_docs": {
        "n": "the maximum count value",
        "trig": "the trigger signal (1: start at 0; 0: increase until `n`)"
      },
      "example": "ba = library(\"basics.lib\");\ncountup_test = ba.countup(8, button(\"trig\"));"
    },
    "ba.sweep": {
      "prefix": "ba",
      "name": "sweep",
      "full_name": "ba.sweep",
      "args": [
        "period",
        "run"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Counts from 0 to `period-1` repeatedly, generating a sawtooth waveform, like `os.lf_rawsaw`, starting at 1 when `run` transitions from 0 to 1.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\nsweep_test = ba.sweep(64, checkbox(\"run\"));"
    },
    "ba.time": {
      "prefix": "ba",
      "name": "time",
      "full_name": "ba.time",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple counter that produces the sequence of 0,1,2...N integer values. `time` is a standard Faust function.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\ntime_test = ba.time;"
    },
    "ba.ramp": {
      "prefix": "ba",
      "name": "ramp",
      "full_name": "ba.ramp",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A linear ramp with a slope of '(+/-)1/n' samples to reach the next target value.",
      "param_docs": {
        "n": "number of samples to increment/decrement the value by one"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nramp_test = os.osc(1) : ba.ramp(256);"
    },
    "ba.line": {
      "prefix": "ba",
      "name": "line",
      "full_name": "ba.line",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A ramp interpolator that generates a linear transition to reach a target value:",
      "param_docs": {
        "n": "number of samples to reach the new target received at its input"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nline_test = os.osc(1) : ba.line(256);"
    },
    "ba.tempo": {
      "prefix": "ba",
      "name": "tempo",
      "full_name": "ba.tempo",
      "args": [
        "t"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Converts a tempo in BPM into a number of samples.",
      "param_docs": {
        "t": "tempo in BPM"
      },
      "example": "ba = library(\"basics.lib\");\ntempo_test = ba.tempo(120);"
    },
    "ba.period": {
      "prefix": "ba",
      "name": "period",
      "full_name": "ba.period",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Basic sawtooth wave of period `p`.",
      "param_docs": {
        "p": "period as a number of samples"
      },
      "example": "ba = library(\"basics.lib\");\nperiod_test = ba.period(64);"
    },
    "ba.spulse": {
      "prefix": "ba",
      "name": "spulse",
      "full_name": "ba.spulse",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Produces a single pulse of n samples when trig goes from 0 to 1.",
      "param_docs": {
        "n": "pulse length as a number of samples",
        "trig": "the trigger signal (1: start the pulse)"
      },
      "example": "ba = library(\"basics.lib\");\nspulse_test = ba.spulse(32, button(\"trig\"));"
    },
    "ba.pulse": {
      "prefix": "ba",
      "name": "pulse",
      "full_name": "ba.pulse",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Pulses (like 10000) generated at period `p`.",
      "param_docs": {
        "p": "period as a number of samples"
      },
      "example": "ba = library(\"basics.lib\");\npulse_test = ba.pulse(64);"
    },
    "ba.pulsen": {
      "prefix": "ba",
      "name": "pulsen",
      "full_name": "ba.pulsen",
      "args": [
        "n",
        "p"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Pulses (like 11110000) of length `n` generated at period `p`.",
      "param_docs": {
        "n": "pulse length as a number of samples",
        "p": "period as a number of samples"
      },
      "example": "ba = library(\"basics.lib\");\npulsen_test = ba.pulsen(8, 64);"
    },
    "ba.cycle": {
      "prefix": "ba",
      "name": "cycle",
      "full_name": "ba.cycle",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Split nonzero input values into `n` cycles.",
      "param_docs": {
        "n": "the number of cycles/output signals"
      },
      "example": "ba = library(\"basics.lib\");\ncycle_test = button(\"gate\") : ba.cycle(3);"
    },
    "ba.beat": {
      "prefix": "ba",
      "name": "beat",
      "full_name": "ba.beat",
      "args": [
        "t"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Pulses at tempo `t` in BPM. `beat` is a standard Faust function.",
      "param_docs": {
        "t": "tempo in BPM"
      },
      "example": "ba = library(\"basics.lib\");\nbeat_test = ba.beat(120);"
    },
    "ba.pulse_countup": {
      "prefix": "ba",
      "name": "pulse_countup",
      "full_name": "ba.pulse_countup",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting up pulses. While trig is 1 the output is counting up, while trig is 0 the counter is reset to 0.",
      "param_docs": {
        "trig": "the trigger signal (1: start at next pulse; 0: reset to 0)"
      },
      "example": "ba = library(\"basics.lib\");\npulse_countup_test = ba.pulse_countup(button(\"run\"));"
    },
    "ba.pulse_countdown": {
      "prefix": "ba",
      "name": "pulse_countdown",
      "full_name": "ba.pulse_countdown",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting down pulses. While trig is 1 the output is counting down, while trig is 0 the counter is reset to 0.",
      "param_docs": {
        "trig": "the trigger signal (1: start at next pulse; 0: reset to 0)"
      },
      "example": "ba = library(\"basics.lib\");\npulse_countdown_test = ba.pulse_countdown(button(\"run\"));"
    },
    "ba.pulse_countup_loop": {
      "prefix": "ba",
      "name": "pulse_countup_loop",
      "full_name": "ba.pulse_countup_loop",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting up pulses from 0 to n included. While trig is 1 the output is counting up, while trig is 0 the counter is reset to 0. At the end of the countup (n) the output value will be reset to 0.",
      "param_docs": {
        "n": "the highest number of the countup (included) before reset to 0",
        "trig": "the trigger signal (1: start at next pulse; 0: reset to 0)"
      },
      "example": "ba = library(\"basics.lib\");\npulse_countup_loop_test = ba.pulse_countup_loop(4, button(\"run\"));"
    },
    "ba.pulse_countdown_loop": {
      "prefix": "ba",
      "name": "pulse_countdown_loop",
      "full_name": "ba.pulse_countdown_loop",
      "args": [
        "n",
        "trig"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Starts counting down pulses from 0 to n included. While trig is 1 the output is counting down, while trig is 0 the counter is reset to 0. At the end of the countdown (n) the output value will be reset",
      "param_docs": {
        "n": "the highest number of the countup (included) before reset to 0",
        "trig": "the trigger signal (1: start at next pulse; 0: reset to 0)"
      },
      "example": "ba = library(\"basics.lib\");\npulse_countdown_loop_test = ba.pulse_countdown_loop(4, button(\"run\"));"
    },
    "ba.resetCtr": {
      "prefix": "ba",
      "name": "resetCtr",
      "full_name": "ba.resetCtr",
      "args": [
        "n",
        "m"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Function that lets through the mth impulse out of each consecutive group of `n` impulses.",
      "param_docs": {
        "n": "the total number of impulses being split",
        "m": "index of impulse to allow to be output"
      },
      "example": "ba = library(\"basics.lib\");\nresetCtr_test = ba.pulse(16) : ba.resetCtr(4, 2);"
    },
    "ba.count": {
      "prefix": "ba",
      "name": "count",
      "full_name": "ba.count",
      "args": [
        "l"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Count the number of elements of list l. `count` is a standard Faust function.",
      "param_docs": {
        "l": "list of elements"
      },
      "example": "ba = library(\"basics.lib\");\ncount_test = ba.count((10,20,30,40));"
    },
    "ba.take": {
      "prefix": "ba",
      "name": "take",
      "full_name": "ba.take",
      "args": [
        "P",
        "l"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Take an element from a list. `take` is a standard Faust function.",
      "param_docs": {
        "P": "position (int, known at compile time, P > 0)",
        "l": "list of elements"
      },
      "example": "ba = library(\"basics.lib\");\ntake_test = ba.take(3, (10,20,30,40));"
    },
    "ba.pick": {
      "prefix": "ba",
      "name": "pick",
      "full_name": "ba.pick",
      "args": [
        "l",
        "n"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Pick the nth element from a list. Similar to `ba.take(n+1,l)` but faster and more powerful.",
      "param_docs": {
        "l": "list of elements",
        "n": "index of element to pick, compile time constant."
      },
      "example": "ba = library(\"basics.lib\");\npick_test = ba.pick((10,20,30,40), 2);"
    },
    "ba.pickN": {
      "prefix": "ba",
      "name": "pickN",
      "full_name": "ba.pickN",
      "args": [
        "N",
        "O"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Select the inputs listed in `O` among `N` at compile time.",
      "param_docs": {
        "N": "number of inputs, compile time constant",
        "O": "list of the inputs to select, compile time constants"
      },
      "example": "ba = library(\"basics.lib\");\npickN_test = (1,2,3,4) : ba.pickN(4, (0,2));"
    },
    "ba.subseq": {
      "prefix": "ba",
      "name": "subseq",
      "full_name": "ba.subseq",
      "args": [
        "l",
        "P",
        "N"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Extract a part of a list.",
      "param_docs": {
        "l": "list",
        "P": "start point (int, known at compile time, 0: begin of list)",
        "N": "number of elements (int, known at compile time)"
      },
      "example": "ba = library(\"basics.lib\");\nsubseq_test = ba.subseq((10,20,30,40,50), 1, 3);"
    },
    "ba.tabulate": {
      "prefix": "ba",
      "name": "tabulate",
      "full_name": "ba.tabulate",
      "args": [
        "C",
        "FX",
        "S",
        "r0",
        "r1",
        "x"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Tabulate a 1D function over the range [r0, r1] for access via nearest-value, linear, cubic interpolation. In other words, the uniformly tabulated function can be evaluated using interpolation of order",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\ntabulate_test = ba.tabulate(1, ba.midikey2hz, 128, 0, 127, 60).lin;"
    },
    "ba.tabulate_chebychev": {
      "prefix": "ba",
      "name": "tabulate_chebychev",
      "full_name": "ba.tabulate_chebychev",
      "args": [
        "C",
        "FX",
        "NX",
        "CD",
        "r0",
        "r1"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Tabulate a 1D function over the range [r0, r1] for access via Chebyshev polynomial approximation. In contrast to `(ba.)tabulate`, which interpolates only between tabulated samples, `(ba.)tabulate_cheb",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\ntabulate_chebychev_test = ba.tabulate_chebychev(1, ba.midikey2hz, 32, 4, 0, 127, 60);"
    },
    "ba.tabulateNd": {
      "prefix": "ba",
      "name": "tabulateNd",
      "full_name": "ba.tabulateNd",
      "args": [
        "C",
        "function",
        "(parameters"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Tabulate an nD function for access via nearest-value or linear or cubic interpolation. In other words, the tabulated function can be evaluated using interpolation of order 0 (none), 1 (linear), or 3 (",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\npowSin(x,y) = sin(pow(x,y));\ntabulateNd_test = ba.tabulateNd(1, powSin, (8,8, 2.0,2.0, 8.0,8.0, 3.0,4.0)).lin;"
    },
    "ba.if": {
      "prefix": "ba",
      "name": "if",
      "full_name": "ba.if",
      "args": [
        "cond",
        "then",
        "else"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "if-then-else implemented with a select2. WARNING: since `select2` is strict (always evaluating both branches), the resulting if does not have the usual \"lazy\" semantic of the C if form, and thus canno",
      "param_docs": {
        "cond": "condition",
        "then": "signal selected while cond is true",
        "else": "signal selected while cond is false"
      },
      "example": "ba = library(\"basics.lib\");\nif_test = ba.if(1, 0.5, -0.5);"
    },
    "ba.ifNc": {
      "prefix": "ba",
      "name": "ifNc",
      "full_name": "ba.ifNc",
      "args": [
        "cond1",
        "then1",
        "cond2",
        "then2",
        "... condN",
        "thenN",
        "else"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "if-then-elseif-then-...elsif-then-else implemented on top of `ba.if`.",
      "param_docs": {
        "Nc": "number of branches/conditions (constant numerical expression)",
        "condX": "condition",
        "thenX": "signal selected if condX is the 1st true condition",
        "else": "signal selected if all the cond1-condN conditions are false"
      },
      "example": "ba = library(\"basics.lib\");\nifNc_test = ba.ifNc((1, 10, 0, 20, 30));"
    },
    "ba.ifNcNo": {
      "prefix": "ba",
      "name": "ifNcNo",
      "full_name": "ba.ifNcNo",
      "args": [
        "Nc",
        "No",
        "cond1",
        "then1",
        "cond2",
        "then2",
        "... condN",
        "thenN",
        "else"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "`ifNcNo(Nc,No)` is similar to `ifNc(Nc)` above but then/else branches have `No` outputs.",
      "param_docs": {
        "Nc": "number of branches/conditions (constant numerical expression)",
        "No": "number of outputs (constant numerical expression)",
        "condX": "condition",
        "thenX": "list of No signals selected if condX is the 1st true condition",
        "else": "list of No signals selected if all the cond1-condN conditions are false"
      },
      "example": "ba = library(\"basics.lib\");\nifNcNo_test = (1, 10, 0, 20, 30) : ba.ifNcNo(2, 1);"
    },
    "ba.selector": {
      "prefix": "ba",
      "name": "selector",
      "full_name": "ba.selector",
      "args": [
        "I",
        "N"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Selects the ith input among n at compile time.",
      "param_docs": {
        "I": "input to select (int, numbered from 0, known at compile time)",
        "N": "number of inputs (int, known at compile time, N > I)"
      },
      "example": "ba = library(\"basics.lib\");\nselector_test = (0.1, 0.2, 0.3, 0.4) : ba.selector(2, 4);"
    },
    "ba.select2stereo": {
      "prefix": "ba",
      "name": "select2stereo",
      "full_name": "ba.select2stereo",
      "args": [
        "bpc"
      ],
      "arg_count": 1,
      "inputs": 4,
      "outputs": 2,
      "description": "Select between 2 stereo signals.",
      "param_docs": {
        "bpc": "the selector switch (0/1)"
      },
      "example": "ba = library(\"basics.lib\");\nselect2stereo_test = ba.select2stereo(1, (0.1,0.2, 0.3,0.4));"
    },
    "ba.selectn": {
      "prefix": "ba",
      "name": "selectn",
      "full_name": "ba.selectn",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Selects the ith input among N at run time.",
      "param_docs": {
        "N": "number of inputs (int, known at compile time, N > 0)",
        "i": "input to select (int, numbered from 0)"
      },
      "example": "ba = library(\"basics.lib\");\nselectn_test = (1,2,3,4) : ba.selectn(4, 2);"
    },
    "ba.selectbus": {
      "prefix": "ba",
      "name": "selectbus",
      "full_name": "ba.selectbus",
      "args": [
        "BUS_SIZE",
        "NUM_BUSES",
        "id"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Select a bus among `NUM_BUSES` buses, where each bus has `BUS_SIZE` outputs. The order of the signal inputs should be the signals of the first bus, the signals of the second bus, and so on.",
      "param_docs": {
        "BUS_SIZE": "number of outputs from each bus (int, known at compile time).",
        "NUM_BUSES": "number of buses (int, known at compile time).",
        "id": "index of the bus to select (int, `0<=id<NUM_BUSES`)"
      },
      "example": "ba = library(\"basics.lib\");\nselectbus_test = (1,2,3,4) : ba.selectbus(2, 2, 1);"
    },
    "ba.selectxbus": {
      "prefix": "ba",
      "name": "selectxbus",
      "full_name": "ba.selectxbus",
      "args": [
        "BUS_SIZE",
        "NUM_BUSES",
        "fade",
        "id"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Like `ba.selectbus`, but with a cross-fade when selecting the bus using the same technique than `ba.selectmulti`.",
      "param_docs": {
        "BUS_SIZE": "number of outputs from each bus (int, known at compile time).",
        "NUM_BUSES": "number of buses (int, known at compile time).",
        "fade": "number of samples for the crossfade.",
        "id": "index of the bus to select (int, `0<=id<NUM_BUSES`)"
      },
      "example": "ba = library(\"basics.lib\");\nselectxbus_test = (1,2,3,4) : ba.selectxbus(2, 2, 16, checkbox(\"bus\"));"
    },
    "ba.selectmulti": {
      "prefix": "ba",
      "name": "selectmulti",
      "full_name": "ba.selectmulti",
      "args": [
        "n",
        "lgen",
        "id"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Selects the ith circuit among N at run time (all should have the same number of inputs and outputs) with a crossfade.",
      "param_docs": {
        "n": "crossfade in samples",
        "lgen": "list of circuits",
        "id": "circuit to select (int, numbered from 0)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\neffects = ((_*0.5,_*0.5),(_*0.25,_*0.25));\nchoice = int(checkbox(\"choice\"));\nselectmulti_test = (os.osc(440), os.osc(660)) : ba.selectmulti(ma.SR/100, effects, choice);"
    },
    "ba.selectoutn": {
      "prefix": "ba",
      "name": "selectoutn",
      "full_name": "ba.selectoutn",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Route input to the output among N at run time.",
      "param_docs": {
        "N": "number of outputs (int, known at compile time, N > 0)",
        "i": "output number to route to (int, numbered from 0) (i.e. slider)"
      },
      "example": "ba = library(\"basics.lib\");\nselectoutn_test = 1 : ba.selectoutn(3, 1);"
    },
    "ba.latch": {
      "prefix": "ba",
      "name": "latch",
      "full_name": "ba.latch",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Latch input on the rising edge of trig. Captures (\"records\") the input x whenever trig crosses from \u22640 to >0, and holds the last captured value at all other times.",
      "param_docs": {
        "trig": "trigger signal. A rising edge (\u22640 \u2192 >0) samples the input."
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nlatch_test = os.osc(2) : ba.latch(button(\"hold\"));"
    },
    "ba.sAndH": {
      "prefix": "ba",
      "name": "sAndH",
      "full_name": "ba.sAndH",
      "args": [
        "trig"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sample And Hold: \"records\" the input when trig is 1, outputs a frozen value when trig is 0. `sAndH` is a standard Faust function.",
      "param_docs": {
        "trig": "hold trigger (0 for hold, 1 for bypass)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nsAndH_test = os.osc(2) : ba.sAndH(button(\"hold\"));"
    },
    "ba.tAndH": {
      "prefix": "ba",
      "name": "tAndH",
      "full_name": "ba.tAndH",
      "args": [
        "pred"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Test And Hold: \"records\" the input when pred(input) is true, outputs a frozen value otherwise.",
      "param_docs": {
        "pred": "predicate to test the input"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nisPositive(x) = x > 0.0;\ntAndH_test = os.osc(2) : ba.tAndH(isPositive);"
    },
    "ba.downSample": {
      "prefix": "ba",
      "name": "downSample",
      "full_name": "ba.downSample",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Down sample a signal. WARNING: this function doesn't change the rate of a signal, it just holds samples... `downSample` is a standard Faust function.",
      "param_docs": {
        "freq": "new rate in Hz"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\ndownSample_test = os.osc(440) : ba.downSample(11025);"
    },
    "ba.downSampleCV": {
      "prefix": "ba",
      "name": "downSampleCV",
      "full_name": "ba.downSampleCV",
      "args": [
        "amount"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A version of `ba.downSample` where the frequency parameter has been replaced by an `amount` parameter that is in the range zero to one. WARNING: this function doesn't change the rate of a",
      "param_docs": {
        "amount": "The amount of down-sampling to perform [0..1]"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\ndownSampleCV_test = os.osc(440) : ba.downSampleCV(0.5);"
    },
    "ba.peakhold": {
      "prefix": "ba",
      "name": "peakhold",
      "full_name": "ba.peakhold",
      "args": [
        "mode"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Outputs current max value above zero.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\npeakhold_test = os.osc(440) : ba.peakhold(1);"
    },
    "ba.peakholder": {
      "prefix": "ba",
      "name": "peakholder",
      "full_name": "ba.peakholder",
      "args": [
        "holdTime"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "While peak-holder functions are scarcely discussed in the literature (please do send me an email if you know otherwise), common sense tells that the expected behaviour should be as follows: the absolu",
      "param_docs": {
        "holdTime": "hold time in samples"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\npeakholder_test = os.osc(440) : ba.peakholder(ba.sec2samp(0.1));"
    },
    "ba.kr2ar": {
      "prefix": "ba",
      "name": "kr2ar",
      "full_name": "ba.kr2ar",
      "args": [
        "\"freq\"",
        "200",
        "200",
        "2000",
        "0.1"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Force a control rate signal to be used as an audio rate signal.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\nkr2ar_test = button(\"gate\") : ba.kr2ar;"
    },
    "ba.impulsify": {
      "prefix": "ba",
      "name": "impulsify",
      "full_name": "ba.impulsify",
      "args": [
        "\"gate\""
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Turns a signal into an impulse with the value of the current sample (0.3,0.2,0.1 becomes 0.3,0.0,0.0). This function is typically used with a `button` to turn its output into an impulse. `impulsify` i",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nimpulsify_test = os.osc(440) : ba.impulsify;"
    },
    "ba.automat": {
      "prefix": "ba",
      "name": "automat",
      "full_name": "ba.automat",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Record and replay in a loop the successives values of the input signal.",
      "param_docs": {
        "t": "tempo in BPM",
        "size": "number of items in the loop",
        "init": "init value in the loop"
      },
      "example": "ba = library(\"basics.lib\");\nautoControl = hslider(\"autoControl\", 0.2, 0, 1, 0.01);\nautomat_test = autoControl : ba.automat(120, 4, 0.0);"
    },
    "ba.bpf": {
      "prefix": "ba",
      "name": "bpf",
      "full_name": "ba.bpf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "bpf is an environment (a group of related definitions) that can be used to create break-point functions. It contains three functions:",
      "param_docs": {},
      "example": ""
    },
    "ba.listInterp": {
      "prefix": "ba",
      "name": "listInterp",
      "full_name": "ba.listInterp",
      "args": [
        "v"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Linearly interpolates between the elements of a list.",
      "param_docs": {
        "index": "the index (float) to interpolate between the different values."
      },
      "example": "ba = library(\"basics.lib\");\nlistInterp_test = ba.listInterp((800,400,350,450,325), 1.5);"
    },
    "ba.bypass1": {
      "prefix": "ba",
      "name": "bypass1",
      "full_name": "ba.bypass1",
      "args": [
        "bpc",
        "e"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Takes a mono input signal, route it to `e` and bypass it if `bpc = 1`. When bypassed, `e` is feed with zeros so that its state is cleanup up. `bypass1` is a standard Faust function.",
      "param_docs": {
        "bpc": "bypass switch (0/1)",
        "e": "a mono effect"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nbypass1_test = os.osc(440) : ba.bypass1(button(\"bypass\"), *(0.5));"
    },
    "ba.bypass2": {
      "prefix": "ba",
      "name": "bypass2",
      "full_name": "ba.bypass2",
      "args": [
        "bpc",
        "e"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Takes a stereo input signal, route it to `e` and bypass it if `bpc = 1`. When bypassed, `e` is feed with zeros so that its state is cleanup up. `bypass2` is a standard Faust function.",
      "param_docs": {
        "bpc": "bypass switch (0/1)",
        "e": "a stereo effect"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nbypass2_test = (os.osc(440), os.osc(660)) : ba.bypass2(button(\"bypass\"), par(i,2, *(0.5)));"
    },
    "ba.bypass1to2": {
      "prefix": "ba",
      "name": "bypass1to2",
      "full_name": "ba.bypass1to2",
      "args": [
        "bpc",
        "e"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 2,
      "description": "Bypass switch for effect `e` having mono input signal and stereo output. Effect `e` is bypassed if `bpc = 1`.When bypassed, `e` is feed with zeros so that its state is cleanup up.",
      "param_docs": {
        "bpc": "bypass switch (0/1)",
        "e": "a mono-to-stereo effect"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nmonoToStereo(x) = (x*0.5, x*0.25);\nbypass1to2_test = os.osc(440) : ba.bypass1to2(button(\"bypass\"), monoToStereo);"
    },
    "ba.bypass_fade": {
      "prefix": "ba",
      "name": "bypass_fade",
      "full_name": "ba.bypass_fade",
      "args": [
        "n",
        "b",
        "e"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Bypass an arbitrary (N x N) circuit with 'n' samples crossfade. Inputs and outputs signals are faded out when 'e' is bypassed, so that 'e' state is cleanup up.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nbypass_fade_test = (os.osc(440), os.osc(660)) : ba.bypass_fade(128, button(\"bypass\"), par(i,2, *(0.5)));"
    },
    "ba.toggle": {
      "prefix": "ba",
      "name": "toggle",
      "full_name": "ba.toggle",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Triggered by the change of 0 to 1, it toggles the output value between 0 and 1.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\ntoggle_test = ba.toggle(button(\"trig\"));"
    },
    "ba.on_and_off": {
      "prefix": "ba",
      "name": "on_and_off",
      "full_name": "ba.on_and_off",
      "args": [
        "a",
        "b"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "The first channel set the output to 1, the second channel to 0.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\non_and_off_test = button(\"on\"), button(\"off\") : ba.on_and_off;"
    },
    "ba.bitcrusher": {
      "prefix": "ba",
      "name": "bitcrusher",
      "full_name": "ba.bitcrusher",
      "args": [
        "nbits"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Produce distortion by reduction of the signal resolution.",
      "param_docs": {
        "nbits": "the number of bits of the wanted resolution"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nbitcrusher_test = os.osc(440) : ba.bitcrusher(8);"
    },
    "ba.mulaw_bitcrusher": {
      "prefix": "ba",
      "name": "mulaw_bitcrusher",
      "full_name": "ba.mulaw_bitcrusher",
      "args": [
        "mu",
        "nbits"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Produce distortion by reducing the signal resolution using \u03bc-law compression.",
      "param_docs": {
        "mu": "controls the degree of \u03bc-law compression, larger values result in stronger compression",
        "nbits": "the number of bits of the wanted resolution"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nmulaw_bitcrusher_test = os.osc(440) : ba.mulaw_bitcrusher(2.0, 8);"
    },
    "ba.slidingReduce": {
      "prefix": "ba",
      "name": "slidingReduce",
      "full_name": "ba.slidingReduce",
      "args": [
        "op",
        "n",
        "maxN",
        "disabledVal"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Fold-like high order function. Apply a commutative binary operation `op` to the last `n` consecutive samples of a signal `x`. For example : `slidingReduce(max,128,128,0-(ma.MAX))` will compute the max",
      "param_docs": {
        "n": "the number of values to process",
        "maxN": "the maximum number of values to process (int, known at compile time, maxN > 0)",
        "op": "the operator. Needs to be a commutative one.",
        "disabledVal": "the value to use when we want to ignore a value."
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\nslidingReduce_test = os.osc(440) : ba.slidingReduce(max, 64, 64, 0 - ma.MAX);"
    },
    "ba.slidingSum": {
      "prefix": "ba",
      "name": "slidingSum",
      "full_name": "ba.slidingSum",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding sum of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nslidingSum_test = os.osc(440) : ba.slidingSum(64);"
    },
    "ba.slidingSump": {
      "prefix": "ba",
      "name": "slidingSump",
      "full_name": "ba.slidingSump",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding sum of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process",
        "maxN": "the maximum number of values to process (int, known at compile time, maxN > 0)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nslidingSump_test = os.osc(440) : ba.slidingSump(64, 128);"
    },
    "ba.slidingMax": {
      "prefix": "ba",
      "name": "slidingMax",
      "full_name": "ba.slidingMax",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding maximum of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process",
        "maxN": "the maximum number of values to process (int, known at compile time, maxN > 0)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\nslidingMax_test = os.osc(440) : ba.slidingMax(64, 128);"
    },
    "ba.slidingMin": {
      "prefix": "ba",
      "name": "slidingMin",
      "full_name": "ba.slidingMin",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding minimum of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process",
        "maxN": "the maximum number of values to process (int, known at compile time, maxN > 0)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\nslidingMin_test = os.osc(440) : ba.slidingMin(64, 128);"
    },
    "ba.slidingMean": {
      "prefix": "ba",
      "name": "slidingMean",
      "full_name": "ba.slidingMean",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding mean of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nslidingMean_test = os.osc(440) : ba.slidingMean(64);"
    },
    "ba.slidingMeanp": {
      "prefix": "ba",
      "name": "slidingMeanp",
      "full_name": "ba.slidingMeanp",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The sliding mean of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process",
        "maxN": "the maximum number of values to process (int, known at compile time, maxN > 0)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nslidingMeanp_test = os.osc(440) : ba.slidingMeanp(64, 128);"
    },
    "ba.slidingRMS": {
      "prefix": "ba",
      "name": "slidingRMS",
      "full_name": "ba.slidingRMS",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The root mean square of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nslidingRMS_test = os.osc(440) : ba.slidingRMS(64);"
    },
    "ba.slidingRMSp": {
      "prefix": "ba",
      "name": "slidingRMSp",
      "full_name": "ba.slidingRMSp",
      "args": [
        "n",
        "maxN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "The root mean square of the last n input samples.",
      "param_docs": {
        "n": "the number of values to process",
        "maxN": "the maximum number of values to process (int, known at compile time, maxN > 0)"
      },
      "example": "ba = library(\"basics.lib\");\nos = library(\"oscillators.lib\");\nslidingRMSp_test = os.osc(440) : ba.slidingRMSp(64, 128);"
    },
    "ba.parallelOp": {
      "prefix": "ba",
      "name": "parallelOp",
      "full_name": "ba.parallelOp",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Apply a commutative binary operation `op` to N parallel inputs.",
      "param_docs": {},
      "example": "ba = library(\"basics.lib\");\nparallelOp_test = (0.2, 0.5, 0.1) : ba.parallelOp(max, 3);"
    },
    "ba.parallelMax": {
      "prefix": "ba",
      "name": "parallelMax",
      "full_name": "ba.parallelMax",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The maximum of N parallel inputs.",
      "param_docs": {
        "N": "the number of parallel inputs known at compile time"
      },
      "example": "ba = library(\"basics.lib\");\nparallelMax_test = (0.2, 0.5, 0.1) : ba.parallelMax(3);"
    },
    "ba.parallelMin": {
      "prefix": "ba",
      "name": "parallelMin",
      "full_name": "ba.parallelMin",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The minimum of N parallel inputs.",
      "param_docs": {
        "N": "the number of parallel inputs known at compile time"
      },
      "example": "ba = library(\"basics.lib\");\nparallelMin_test = (0.2, 0.5, 0.1) : ba.parallelMin(3);"
    },
    "ba.parallelMean": {
      "prefix": "ba",
      "name": "parallelMean",
      "full_name": "ba.parallelMean",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The mean of N parallel inputs.",
      "param_docs": {
        "N": "the number of parallel inputs known at compile time"
      },
      "example": "ba = library(\"basics.lib\");\nparallelMean_test = (0.2, 0.5, 0.1) : ba.parallelMean(3);"
    },
    "ba.parallelRMS": {
      "prefix": "ba",
      "name": "parallelRMS",
      "full_name": "ba.parallelRMS",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The RMS of N parallel inputs.",
      "param_docs": {
        "N": "the number of parallel inputs known at compile time"
      },
      "example": "ba = library(\"basics.lib\");\nparallelRMS_test = (0.2, 0.5, 0.1) : ba.parallelRMS(3);"
    },
    "ba.bpf.start": {
      "prefix": "ba",
      "name": "bpf.start",
      "full_name": "ba.bpf.start",
      "args": [
        "x0",
        "y0"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf start filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf.point": {
      "prefix": "ba",
      "name": "bpf.point",
      "full_name": "ba.bpf.point",
      "args": [
        "x1",
        "y1"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf point filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf.end": {
      "prefix": "ba",
      "name": "bpf.end",
      "full_name": "ba.bpf.end",
      "args": [
        "x1",
        "y1"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf end filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf.step": {
      "prefix": "ba",
      "name": "bpf.step",
      "full_name": "ba.bpf.step",
      "args": [
        "x1",
        "y1"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf step filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf.step_end": {
      "prefix": "ba",
      "name": "bpf.step_end",
      "full_name": "ba.bpf.step_end",
      "args": [
        "x1",
        "y1"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf step_end filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf.curve": {
      "prefix": "ba",
      "name": "bpf.curve",
      "full_name": "ba.bpf.curve",
      "args": [
        "B",
        "x1",
        "y1"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf curve filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf.curve_end": {
      "prefix": "ba",
      "name": "bpf.curve_end",
      "full_name": "ba.bpf.curve_end",
      "args": [
        "B",
        "x1",
        "y1"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf curve_end filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf._bias_curve": {
      "prefix": "ba",
      "name": "bpf._bias_curve",
      "full_name": "ba.bpf._bias_curve",
      "args": [
        "b",
        "x"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf _bias_curve filter",
      "param_docs": {},
      "example": ""
    },
    "ba.bpf._curve_util": {
      "prefix": "ba",
      "name": "bpf._curve_util",
      "full_name": "ba.bpf._curve_util",
      "args": [
        "x0",
        "x1",
        "y0",
        "y1",
        "b",
        "x"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "bpf _curve_util filter",
      "param_docs": {},
      "example": ""
    },
    "co.ratio": {
      "prefix": "co",
      "name": "ratio",
      "full_name": "co.ratio",
      "args": [
        "ratio"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "This utility converts a ratio to a strength.",
      "param_docs": {
        "ratio": "compression ratio, between 1 and infinity (1=no compression, infinity means hard limiting)"
      },
      "example": "co = library(\"compressors.lib\");\nratio2strength_test = co.ratio2strength(4);"
    },
    "co.strength": {
      "prefix": "co",
      "name": "strength",
      "full_name": "co.strength",
      "args": [
        "strength"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "This utility converts a strength to a ratio.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)"
      },
      "example": "co = library(\"compressors.lib\");\nstrength2ratio_test = co.strength2ratio(0.75);"
    },
    "co.peak_compression_gain_mono_db": {
      "prefix": "co",
      "name": "peak_compression_gain_mono_db",
      "full_name": "co.peak_compression_gain_mono_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressor gain computer with dB output. `peak_compression_gain_mono_db` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\npeak_compression_gain_mono_db_test = os.osc(440) : co.peak_compression_gain_mono_db(0.5, -12, 0.01, 0.1, 6, 0);"
    },
    "co.peak_compression_gain_N_chan_db": {
      "prefix": "co",
      "name": "peak_compression_gain_N_chan_db",
      "full_name": "co.peak_compression_gain_N_chan_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 5,
      "description": "N channels dynamic range compressor gain computer with dB output. `peak_compression_gain_N_chan_db` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\npeak_compression_gain_N_chan_db_test = (os.osc(440), os.osc(660)) : co.peak_compression_gain_N_chan_db(0.5, -12, 0.01, 0.1, 6, 0, 0.5, 2);"
    },
    "co.FFcompressor_N_chan": {
      "prefix": "co",
      "name": "FFcompressor_N_chan",
      "full_name": "co.FFcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "N"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward N channels dynamic range compressor. `FFcompressor_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "meter": "a gain reduction meter. It can be implemented like so:",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nFFcompressor_N_chan_test = (os.osc(440), os.osc(660)) : co.FFcompressor_N_chan(0.5, -12, 0.01, 0.1, 6, 0, 0.5, meter, 2);"
    },
    "co.FBcompressor_N_chan": {
      "prefix": "co",
      "name": "FBcompressor_N_chan",
      "full_name": "co.FBcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "N"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed back N channels dynamic range compressor. `FBcompressor_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "meter": "a gain reduction meter. It can be implemented with:",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nFBcompressor_N_chan_test = (os.osc(440), os.osc(660)) : co.FBcompressor_N_chan(0.5, -12, 0.01, 0.1, 6, 0, 0.5, meter, 2);"
    },
    "co.FBFFcompressor_N_chan": {
      "prefix": "co",
      "name": "FBFFcompressor_N_chan",
      "full_name": "co.FBFFcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "FBFF",
        "meter",
        "N"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward / feed back N channels dynamic range compressor. The feedback part has a much higher strength, so they end up sounding similar. `FBFFcompressor_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "FBFF": "fade between feed forward (0) and feed back (1) compression",
        "meter": "a gain reduction meter. It can be implemented like so:",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nFBFFcompressor_N_chan_test = (os.osc(440), os.osc(660)) : co.FBFFcompressor_N_chan(0.4, -12, 0.01, 0.1, 6, 0, 0.5, 0.3, meter, 2);"
    },
    "co.RMS_compression_gain_mono_db": {
      "prefix": "co",
      "name": "RMS_compression_gain_mono_db",
      "full_name": "co.RMS_compression_gain_mono_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono RMS dynamic range compressor gain computer with dB output. `RMS_compression_gain_mono_db` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nRMS_compression_gain_mono_db_test = os.osc(330) : co.RMS_compression_gain_mono_db(0.5, -18, 0.02, 0.12, 6, 0);"
    },
    "co.RMS_compression_gain_N_chan_db": {
      "prefix": "co",
      "name": "RMS_compression_gain_N_chan_db",
      "full_name": "co.RMS_compression_gain_N_chan_db",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 5,
      "description": "RMS N channels dynamic range compressor gain computer with dB output. `RMS_compression_gain_N_chan_db` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "N": "the number of channels of the compressor"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nRMS_compression_gain_N_chan_db_test = (os.osc(330), os.osc(550)) : co.RMS_compression_gain_N_chan_db(0.5, -18, 0.02, 0.12, 6, 0, 0.5, 2);"
    },
    "co.RMS_FBFFcompressor_N_chan": {
      "prefix": "co",
      "name": "RMS_FBFFcompressor_N_chan",
      "full_name": "co.RMS_FBFFcompressor_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "FBFF",
        "meter",
        "N"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 3,
      "description": "RMS feed forward / feed back N channels dynamic range compressor. The feedback part has a much higher strength, so they end up sounding similar. `RMS_FBFFcompressor_N_chan` is a standard Faust functio",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "FBFF": "fade between feed forward (0) and feed back (1) compression.",
        "meter": "a gain reduction meter. It can be implemented with:",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nRMS_FBFFcompressor_N_chan_test = (os.osc(330), os.osc(550)) : co.RMS_FBFFcompressor_N_chan(0.4, -18, 0.02, 0.12, 6, 0, 0.5, 0.3, meter, 2);"
    },
    "co.RMS_FBcompressor_peak_limiter_N_chan": {
      "prefix": "co",
      "name": "RMS_FBcompressor_peak_limiter_N_chan",
      "full_name": "co.RMS_FBcompressor_peak_limiter_N_chan",
      "args": [
        "strength",
        "thresh",
        "threshLim",
        "att",
        "rel",
        "knee",
        "link",
        "meter",
        "meterLim",
        "N"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 5,
      "description": "N channel RMS feed back compressor into peak limiter feeding back into the FB compressor. By combining them this way, they complement each other optimally: the RMS compressor doesn't have to deal with",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "threshLim": "dB level threshold above which the brickwall limiter kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "meter": "compressor gain reduction meter. It can be implemented with:",
        "meterLim": "brickwall limiter gain reduction meter. It can be implemented with:",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nmeterLim(x) = x;\nRMS_FBcompressor_peak_limiter_N_chan_test = (os.osc(330), os.osc(550)) : co.RMS_FBcompressor_peak_limiter_N_chan(0.4, -18, -2, 0.02, 0.12, 6, 0.5, meter, meterLim, 2);"
    },
    "co.peak_compression_gain_mono": {
      "prefix": "co",
      "name": "peak_compression_gain_mono",
      "full_name": "co.peak_compression_gain_mono",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressor gain computer with linear output. `peak_compression_gain_mono` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\npeak_compression_gain_mono_test = os.osc(440) : co.peak_compression_gain_mono(0.5, -12, 0.01, 0.1, 6, 0);"
    },
    "co.peak_compression_gain_N_chan": {
      "prefix": "co",
      "name": "peak_compression_gain_N_chan",
      "full_name": "co.peak_compression_gain_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 4,
      "description": "N channels dynamic range compressor gain computer with linear output. `peak_compression_gain_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\npeak_compression_gain_N_chan_test = (os.osc(440), os.osc(660)) : co.peak_compression_gain_N_chan(0.5, -12, 0.01, 0.1, 6, 0, 0.5, 2);"
    },
    "co.RMS_compression_gain_mono": {
      "prefix": "co",
      "name": "RMS_compression_gain_mono",
      "full_name": "co.RMS_compression_gain_mono",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono RMS dynamic range compressor gain computer with linear output. `RMS_compression_gain_mono` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nRMS_compression_gain_mono_test = os.osc(330) : co.RMS_compression_gain_mono(0.5, -18, 0.02, 0.12, 6, 0);"
    },
    "co.RMS_compression_gain_N_chan": {
      "prefix": "co",
      "name": "RMS_compression_gain_N_chan",
      "full_name": "co.RMS_compression_gain_N_chan",
      "args": [
        "strength",
        "thresh",
        "att",
        "rel",
        "knee",
        "prePost",
        "link",
        "N"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 4,
      "description": "RMS N channels dynamic range compressor gain computer with linear output. `RMS_compression_gain_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)",
        "thresh": "dB level threshold above which compression kicks in",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "N": "the number of channels of the compressor, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nRMS_compression_gain_N_chan_test = (os.osc(330), os.osc(550)) : co.RMS_compression_gain_N_chan(0.5, -18, 0.02, 0.12, 6, 0, 0.5, 2);"
    },
    "co.compressor_lad_mono": {
      "prefix": "co",
      "name": "compressor_lad_mono",
      "full_name": "co.compressor_lad_mono",
      "args": [
        "lad",
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressor with lookahead delay. `compressor_lad_mono` is a standard Faust function.",
      "param_docs": {
        "lad": "lookahead delay in seconds (nonnegative) - gets rounded to nearest sample.",
        "ratio": "compression ratio (1 = no compression, >1 means compression)",
        "thresh": "dB level threshold above which compression kicks in (0 dB = max level)",
        "att": "attack time = time constant (sec) when level & compression are going up",
        "rel": "release time = time constant (sec) coming out of compression"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\ncompressor_lad_mono_test = os.osc(440) : co.compressor_lad_mono(0.005, 4, -9, 0.01, 0.1);"
    },
    "co.compressor_mono": {
      "prefix": "co",
      "name": "compressor_mono",
      "full_name": "co.compressor_mono",
      "args": [
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono dynamic range compressors. `compressor_mono` is a standard Faust function.",
      "param_docs": {
        "ratio": "compression ratio (1 = no compression, >1 means compression)",
        "thresh": "dB level threshold above which compression kicks in (0 dB = max level)",
        "att": "attack time = time constant (sec) when level & compression are going up",
        "rel": "release time = time constant (sec) coming out of compression"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\ncompressor_mono_test = os.osc(440) : co.compressor_mono(4, -9, 0.01, 0.2);"
    },
    "co.compressor_stereo": {
      "prefix": "co",
      "name": "compressor_stereo",
      "full_name": "co.compressor_stereo",
      "args": [
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo dynamic range compressors.",
      "param_docs": {
        "ratio": "compression ratio (1 = no compression, >1 means compression)",
        "thresh": "dB level threshold above which compression kicks in (0 dB = max level)",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\ncompressor_stereo_test = (os.osc(440), os.osc(660)) : co.compressor_stereo(4, -9, 0.01, 0.2);"
    },
    "co.compression_gain_mono": {
      "prefix": "co",
      "name": "compression_gain_mono",
      "full_name": "co.compression_gain_mono",
      "args": [
        "ratio",
        "thresh",
        "att",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Compression-gain calculation for dynamic range compressors.",
      "param_docs": {
        "ratio": "compression ratio (1 = no compression, >1 means compression)",
        "thresh": "dB level threshold above which compression kicks in (0 dB = max level)",
        "att": "attack time = time constant (sec) when level & compression going up",
        "rel": "release time = time constant (sec) coming out of compression"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\ncompression_gain_mono_test = os.osc(440) : co.compression_gain_mono(4, -9, 0.01, 0.2);"
    },
    "co.limiter_1176_R4_mono": {
      "prefix": "co",
      "name": "limiter_1176_R4_mono",
      "full_name": "co.limiter_1176_R4_mono",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "A limiter guards against hard-clipping.  It can be implemented as a compressor having a high threshold (near the clipping level), fast attack, and high ratio.  Since",
      "param_docs": {},
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_1176_R4_mono_test = os.osc(440) : co.limiter_1176_R4_mono;"
    },
    "co.limiter_1176_R4_stereo": {
      "prefix": "co",
      "name": "limiter_1176_R4_stereo",
      "full_name": "co.limiter_1176_R4_stereo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "A limiter guards against hard-clipping.  It can be implemented as a compressor having a high threshold (near the clipping level), fast attack and release, and high ratio.  Since",
      "param_docs": {},
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_1176_R4_stereo_test = (os.osc(440), os.osc(660)) : co.limiter_1176_R4_stereo;"
    },
    "co.peak_expansion_gain_N_chan_db": {
      "prefix": "co",
      "name": "peak_expansion_gain_N_chan_db",
      "full_name": "co.peak_expansion_gain_N_chan_db",
      "args": [
        "strength",
        "thresh",
        "range",
        "att",
        "hold",
        "rel",
        "knee",
        "prePost",
        "link",
        "maxHold",
        "N"
      ],
      "arg_count": 11,
      "inputs": 0,
      "outputs": 5,
      "description": "N channels dynamic range expander gain computer. `peak_expansion_gain_N_chan_db` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the expansion (0 = no expansion, 100 means gating, <1 means upward compression)",
        "thresh": "dB level threshold below which expansion kicks in",
        "range": "maximum amount of expansion in dB",
        "att": "attack time = time constant (sec) coming out of expansion",
        "hold": "hold time (sec)",
        "rel": "release time = time constant (sec) going into expansion",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "maxHold": "the maximum hold time in samples, known at compile time",
        "N": "the number of channels of the gain computer, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\npeak_expansion_gain_N_chan_db_test = (os.osc(220), os.osc(330)) : co.peak_expansion_gain_N_chan_db(0.5, -40, 20, 0.05, 0.01, 0.2, 6, 0, 0.5, 2048, 2);"
    },
    "co.expander_N_chan": {
      "prefix": "co",
      "name": "expander_N_chan",
      "full_name": "co.expander_N_chan",
      "args": [
        "strength",
        "thresh",
        "range",
        "att",
        "hold",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "maxHold",
        "N"
      ],
      "arg_count": 12,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward N channels dynamic range expander. `expander_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the expansion (0 = no expansion, 100 means gating, <1 means upward compression)",
        "thresh": "dB level threshold below which expansion kicks in",
        "range": "maximum amount of expansion in dB",
        "att": "attack time = time constant (sec) coming out of expansion",
        "hold": "hold time",
        "rel": "release time = time constant (sec) going into expansion",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "meter": "a gain reduction meter. It can be implemented like so:",
        "maxHold": "the maximum hold time in samples, known at compile time",
        "N": "the number of channels of the expander, known at compile time"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nexpander_N_chan_test = (os.osc(220), os.osc(330)) : co.expander_N_chan(0.5, -40, 20, 0.05, 0.02, 0.2, 6, 0, 0.5, meter, 4096, 2);"
    },
    "co.expanderSC_N_chan": {
      "prefix": "co",
      "name": "expanderSC_N_chan",
      "full_name": "co.expanderSC_N_chan",
      "args": [
        "strength",
        "thresh",
        "range",
        "att",
        "hold",
        "rel",
        "knee",
        "prePost",
        "link",
        "meter",
        "maxHold",
        "N",
        "SCfunction",
        "SCswitch",
        "SCsignal"
      ],
      "arg_count": 15,
      "inputs": 0,
      "outputs": 2,
      "description": "Feed forward N channels dynamic range expander with sidechain. `expanderSC_N_chan` is a standard Faust function.",
      "param_docs": {
        "strength": "strength of the expansion (0 = no expansion, 100 means gating, <1 means upward compression)",
        "thresh": "dB level threshold below which expansion kicks in",
        "range": "maximum amount of expansion in dB",
        "att": "attack time = time constant (sec) coming out of expansion",
        "hold": "hold time",
        "rel": "release time = time constant (sec) going into expansion",
        "knee": "a gradual increase in gain reduction around the threshold:",
        "prePost": "places the level detector either at the input or after the gain computer;",
        "link": "the amount of linkage between the channels: 0 = each channel is independent, 1 = all channels have the same amount of gain reduction",
        "meter": "a gain reduction meter. It can be implemented like so:",
        "maxHold": "the maximum hold time in samples, known at compile time",
        "N": "the number of channels of the expander, known at compile time",
        "SCfunction": "a function that get's placed before the level-detector, needs to have a single input and output",
        "SCswitch": "use either the regular audio input or the SCsignal as the input for the level detector",
        "SCsignal": "an audio signal, to be used as the input for the level detector when SCswitch is 1"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nmeter(x) = x;\nSCfunction(x) = x;\nexpanderSC_N_chan_test = (os.osc(220), os.osc(330)) : co.expanderSC_N_chan(0.5, -40, 20, 0.05, 0.02, 0.2, 6, 0, 0.5, meter, 4096, 2, SCfunction, 1, os.osc(880));"
    },
    "co.limiter_lad_N": {
      "prefix": "co",
      "name": "limiter_lad_N",
      "full_name": "co.limiter_lad_N",
      "args": [
        "N",
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 2,
      "description": "N-channels lookahead limiter inspired by IOhannes Zm\u00f6lnig's post, which is in turn based on the thesis by Peter Falkner \"Entwicklung eines digitalen Stereo-Limiters mit Hilfe des Signalprozessors DSP5",
      "param_docs": {
        "N": "is the number of channels, known at compile-time",
        "LD": "is the lookahead delay in seconds, known at compile-time",
        "ceiling": "is the linear amplitude output limit",
        "attack": "is the attack time in seconds",
        "hold": "is the hold time in seconds",
        "release": "is the release time in seconds"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_lad_N_test = (os.osc(440), os.osc(660)) : co.limiter_lad_N(2, 0.01, 1, 0.01, 0.05, 0.2);"
    },
    "co.limiter_lad_mono": {
      "prefix": "co",
      "name": "limiter_lad_mono",
      "full_name": "co.limiter_lad_mono",
      "args": [
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Specialised case of `limiter_lad_N` mono limiter.",
      "param_docs": {
        "LD": "is the lookahead delay in seconds, known at compile-time",
        "ceiling": "is the linear amplitude output limit",
        "attack": "is the attack time in seconds",
        "hold": "is the hold time in seconds",
        "release": "is the release time in seconds"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_lad_mono_test = os.osc(440) : co.limiter_lad_mono(0.01, 1, 0.01, 0.05, 0.2);"
    },
    "co.limiter_lad_stereo": {
      "prefix": "co",
      "name": "limiter_lad_stereo",
      "full_name": "co.limiter_lad_stereo",
      "args": [
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 5,
      "inputs": 2,
      "outputs": 2,
      "description": "Specialised case of `limiter_lad_N` stereo limiter.",
      "param_docs": {
        "LD": "is the lookahead delay in seconds, known at compile-time",
        "ceiling": "is the linear amplitude output limit",
        "attack": "is the attack time in seconds",
        "hold": "is the hold time in seconds",
        "release": "is the release time in seconds"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_lad_stereo_test = (os.osc(440), os.osc(660)) : co.limiter_lad_stereo(0.01, 1, 0.01, 0.05, 0.2);"
    },
    "co.limiter_lad_quad": {
      "prefix": "co",
      "name": "limiter_lad_quad",
      "full_name": "co.limiter_lad_quad",
      "args": [
        "LD",
        "ceiling",
        "attack",
        "hold",
        "release"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 2,
      "description": "Specialised case of `limiter_lad_N` quadraphonic limiter.",
      "param_docs": {
        "LD": "is the lookahead delay in seconds, known at compile-time",
        "ceiling": "is the linear amplitude output limit",
        "attack": "is the attack time in seconds",
        "hold": "is the hold time in seconds",
        "release": "is the release time in seconds"
      },
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_lad_quad_test = (os.osc(220), os.osc(330), os.osc(440), os.osc(550)) : co.limiter_lad_quad(0.01, 1, 0.01, 0.05, 0.2);"
    },
    "co.limiter_lad_bw": {
      "prefix": "co",
      "name": "limiter_lad_bw",
      "full_name": "co.limiter_lad_bw",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Specialised case of `limiter_lad_N` and ready-to-use unit-amplitude mono limiting function. This implementation, in particular, uses `2PI*tau` time constant filters for attack and release smoothing wi",
      "param_docs": {},
      "example": "co = library(\"compressors.lib\");\nos = library(\"oscillators.lib\");\nlimiter_lad_bw_test = os.osc(440) : co.limiter_lad_bw;"
    },
    "de.delay": {
      "prefix": "de",
      "name": "delay",
      "full_name": "de.delay",
      "args": [
        "n",
        "d"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple `d` samples delay where `n` is the maximum delay length as a number of samples. Unlike the `@` delay operator, here the delay signal `d` is explicitly bounded to the interval [0..n]. The conseq",
      "param_docs": {
        "n": "the max delay length in samples",
        "d": "the delay length in samples (integer)"
      },
      "example": "de = library(\"delays.lib\");\nos = library(\"oscillators.lib\");\ndelay_test = os.osc(440) : de.delay(44100, 22050);"
    },
    "de.fdelay": {
      "prefix": "de",
      "name": "fdelay",
      "full_name": "de.fdelay",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Delay lines interpolated using Thiran allpass interpolation.",
      "param_docs": {
        "n": "the max delay length in samples",
        "d": "the delay length in samples"
      },
      "example": "de = library(\"delays.lib\");\nos = library(\"oscillators.lib\");\nfdelay2a_test = os.osc(440) : de.fdelay2a(44100, 22050.5);"
    },
    "de.sdelay": {
      "prefix": "de",
      "name": "sdelay",
      "full_name": "de.sdelay",
      "args": [
        "n",
        "it",
        "d"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "s(mooth)delay: a mono delay that doesn't click and doesn't transpose when the delay time is changed.",
      "param_docs": {
        "n": "the max delay length in samples",
        "it": "interpolation time (in samples), for example 1024",
        "d": "the delay length in samples (float)"
      },
      "example": "de = library(\"delays.lib\");\nos = library(\"oscillators.lib\");\nsdelay_test = os.osc(440) : de.sdelay(44100, 1024, 22050.5);"
    },
    "de.prime_power_delays": {
      "prefix": "de",
      "name": "prime_power_delays",
      "full_name": "de.prime_power_delays",
      "args": [
        "N",
        "pathmin",
        "pathmax"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 2,
      "description": "Prime Power Delay Line Lengths.",
      "param_docs": {
        "N": "positive integer up to 16 (for higher powers of 2, extend 'primes' array below)",
        "pathmin": "minimum acoustic ray length in the reverberator (in meters)",
        "pathmax": "maximum acoustic ray length (meters) - think \"room size\""
      },
      "example": "de = library(\"delays.lib\");\nprime_power_delays_test = de.prime_power_delays(4, 1, 10);"
    },
    "de.fdelaylti": {
      "prefix": "de",
      "name": "fdelaylti",
      "full_name": "de.fdelaylti",
      "args": [
        "N",
        "n",
        "d",
        "x"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Fractional delay line using Lagrange interpolation.",
      "param_docs": {
        "n": "the max delay length in samples",
        "d": "the delay length in samples"
      },
      "example": "de = library(\"delays.lib\");\nos = library(\"oscillators.lib\");\nfdelaylti_test = os.osc(440) : de.fdelaylti(3, 44100, 22050.5);\nfdelayltv_test = os.osc(440) : de.fdelayltv(3, 44100, 22050.5);"
    },
    "de.fdelay1": {
      "prefix": "de",
      "name": "fdelay1",
      "full_name": "de.fdelay1",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "For convenience, `fdelay1`, `fdelay2`, `fdelay3`, `fdelay4`, `fdelay5` are also available where `N` is the order of the interpolation, built using `fdelayltv`. Thiran Allpass Interpolation.",
      "param_docs": {},
      "example": ""
    },
    "de.multiTapSincDelay": {
      "prefix": "de",
      "name": "multiTapSincDelay",
      "full_name": "de.multiTapSincDelay",
      "args": [
        "K",
        "MaxDelay",
        "tau1",
        "tau2",
        "alpha"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Variable delay line using multi-tap sinc interpolation.",
      "param_docs": {
        "MaxDelay": "maximum allowable delay in samples (buffer size)",
        "tau1": "initial delay in samples (can be fractional)",
        "tau2": "target delay in samples (can be fractional)",
        "alpha": "interpolation factor between tau1 and tau2 (in [0,1] with 0 = tau1, 1 = tau2)"
      },
      "example": "de = library(\"delays.lib\");\nos = library(\"oscillators.lib\");\nmultiTapSincDelay_test = os.osc(440) : de.multiTapSincDelay(2, 4096, 1024.0, 1536.0, 0.5);"
    },
    "dm.mth_octave_spectral_level_demo": {
      "prefix": "dm",
      "name": "mth_octave_spectral_level_demo",
      "full_name": "dm.mth_octave_spectral_level_demo",
      "args": [
        "BandsPerOctave"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Demonstrate mth_octave_spectral_level in a standalone GUI.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nmth_octave_spectral_level_demo_test = no.noise : dm.mth_octave_spectral_level_demo(1.5);\nspectral_level_demo_test = no.noise : dm.spectral_level_demo;"
    },
    "dm.parametric_eq_demo": {
      "prefix": "dm",
      "name": "parametric_eq_demo",
      "full_name": "dm.parametric_eq_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "A parametric equalizer application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nparametric_eq_demo_test = no.noise : dm.parametric_eq_demo;"
    },
    "dm.spectral_tilt_demo": {
      "prefix": "dm",
      "name": "spectral_tilt_demo",
      "full_name": "dm.spectral_tilt_demo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "A spectral tilt application.",
      "param_docs": {
        "N": "filter order (integer)"
      },
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nspectral_tilt_demo_test = no.noise : dm.spectral_tilt_demo(4);"
    },
    "dm.mth_octave_filterbank_demo": {
      "prefix": "dm",
      "name": "mth_octave_filterbank_demo",
      "full_name": "dm.mth_octave_filterbank_demo",
      "args": [
        "M"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Graphic Equalizer: each filter-bank output signal routes through a fader.",
      "param_docs": {
        "M": "number of bands per octave"
      },
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nmth_octave_filterbank_demo_test = no.noise : dm.mth_octave_filterbank_demo(1);\nfilterbank_demo_test = no.noise : dm.filterbank_demo;"
    },
    "dm.cubicnl_demo": {
      "prefix": "dm",
      "name": "cubicnl_demo",
      "full_name": "dm.cubicnl_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Distortion demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\ncubicnl_demo_test = no.noise : dm.cubicnl_demo;"
    },
    "dm.gate_demo": {
      "prefix": "dm",
      "name": "gate_demo",
      "full_name": "dm.gate_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Gate demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\ngate_demo_test = no.noise, no.noise : dm.gate_demo;"
    },
    "dm.compressor_demo": {
      "prefix": "dm",
      "name": "compressor_demo",
      "full_name": "dm.compressor_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Compressor demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\ncompressor_demo_test = no.noise, no.noise : dm.compressor_demo;"
    },
    "dm.moog_vcf_demo": {
      "prefix": "dm",
      "name": "moog_vcf_demo",
      "full_name": "dm.moog_vcf_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Illustrate and compare all three Moog VCF implementations above.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nmoog_vcf_demo_test = os.osc(440) : dm.moog_vcf_demo;"
    },
    "dm.wah4_demo": {
      "prefix": "dm",
      "name": "wah4_demo",
      "full_name": "dm.wah4_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Wah pedal application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nwah4_demo_test = os.osc(440) : dm.wah4_demo;"
    },
    "dm.crybaby_demo": {
      "prefix": "dm",
      "name": "crybaby_demo",
      "full_name": "dm.crybaby_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Crybaby effect application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\ncrybaby_demo_test = os.osc(440) : dm.crybaby_demo;"
    },
    "dm.flanger_demo": {
      "prefix": "dm",
      "name": "flanger_demo",
      "full_name": "dm.flanger_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Flanger effect application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nflanger_demo_test = os.osc(440), os.osc(442) : dm.flanger_demo;"
    },
    "dm.phaser2_demo": {
      "prefix": "dm",
      "name": "phaser2_demo",
      "full_name": "dm.phaser2_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Phaser effect demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nphaser2_demo_test = os.osc(440), os.osc(442) : dm.phaser2_demo;"
    },
    "dm.tapeStop_demo": {
      "prefix": "dm",
      "name": "tapeStop_demo",
      "full_name": "dm.tapeStop_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo tape-stop effect.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\ntapeStop_demo_test = os.osc(440), os.osc(442) : dm.tapeStop_demo;"
    },
    "dm.freeverb_demo": {
      "prefix": "dm",
      "name": "freeverb_demo",
      "full_name": "dm.freeverb_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Freeverb demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nfreeverb_demo_test = os.osc(440), os.osc(442) : dm.freeverb_demo;"
    },
    "dm.springreverb_demo": {
      "prefix": "dm",
      "name": "springreverb_demo",
      "full_name": "dm.springreverb_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono spring-inspired reverb demo using `re.springreverb`.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nspringreverb_demo_test = os.osc(220) : dm.springreverb_demo;"
    },
    "dm.stereo_reverb_tester": {
      "prefix": "dm",
      "name": "stereo_reverb_tester",
      "full_name": "dm.stereo_reverb_tester",
      "args": [
        "gui_group"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Handy test inputs for reverberator demos below.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nstereo_reverb_tester_test = no.noise, no.noise : dm.stereo_reverb_tester(!);"
    },
    "dm.fdnrev0_demo": {
      "prefix": "dm",
      "name": "fdnrev0_demo",
      "full_name": "dm.fdnrev0_demo",
      "args": [
        "N",
        "NB",
        "BBSO"
      ],
      "arg_count": 3,
      "inputs": 4,
      "outputs": 2,
      "description": "A reverb application using `fdnrev0`.",
      "param_docs": {
        "N": "feedback Delay Network (FDN) order / number of delay lines used =",
        "NB": "number of frequency bands / Number of (nearly) independent T60 controls",
        "BBSO": "butterworth band-split order / order of lowpass/highpass bandsplit"
      },
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nfdnrev0_demo_test = no.noise, no.noise : dm.fdnrev0_demo(16, 5, 3);"
    },
    "dm.zita_rev_fdn_demo": {
      "prefix": "dm",
      "name": "zita_rev_fdn_demo",
      "full_name": "dm.zita_rev_fdn_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 3,
      "description": "Reverb demo application based on `zita_rev_fdn`.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nzita_rev_fdn_demo_test = par(i, 8, os.osc(440 + i)) : dm.zita_rev_fdn_demo;"
    },
    "dm.zita_light": {
      "prefix": "dm",
      "name": "zita_light",
      "full_name": "dm.zita_light",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Light version of `dm.zita_rev1` with only 2 UI elements.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nzita_light_test = os.osc(440), os.osc(442) : dm.zita_light;"
    },
    "dm.zita_rev1": {
      "prefix": "dm",
      "name": "zita_rev1",
      "full_name": "dm.zita_rev1",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `zita_rev1_stereo` (mostly following the Linux `zita-rev1` GUI).",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nzita_rev1_test = os.osc(440), os.osc(442) : dm.zita_rev1;"
    },
    "dm.vital_rev_demo": {
      "prefix": "dm",
      "name": "vital_rev_demo",
      "full_name": "dm.vital_rev_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `vital_rev` with all parameters exposed.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nvital_rev_demo_test = os.osc(440), os.osc(442) : dm.vital_rev_demo;"
    },
    "dm.reverbTank_demo": {
      "prefix": "dm",
      "name": "reverbTank_demo",
      "full_name": "dm.reverbTank_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "This is a stereo reverb following the \"ReverbTank\" example in [1], although some parameter ranges and scaling have been adjusted. It is an unofficial version of the Spin Semiconductor\u00ae Reverb.",
      "param_docs": {
        "outerDelay": "a delay function with one input and one output",
        "MAXLEN": "constant maximum delay in samples of the inner allpass filter",
        "curDel": "current delay in samples of the inner allpass filter",
        "outerG": "allpass minus-gain coefficient [-1..1]",
        "innerG": "allpass minus-gain coefficient [-1..1]"
      },
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nreverbTank_demo_test = os.osc(440), os.osc(442) : dm.reverbTank_demo;"
    },
    "dm.kb_rom_rev1_demo": {
      "prefix": "dm",
      "name": "kb_rom_rev1_demo",
      "full_name": "dm.kb_rom_rev1_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Keith Barr reverb effect rom_rev1 demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nkb_rom_rev1_demo_test = os.osc(440), os.osc(442) : dm.kb_rom_rev1_demo;"
    },
    "dm.dattorro_rev_demo": {
      "prefix": "dm",
      "name": "dattorro_rev_demo",
      "full_name": "dm.dattorro_rev_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `dattorro_rev` with all parameters exposed and additional dry/wet and output gain control.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\ndattorro_rev_demo_test = os.osc(440), os.osc(442) : dm.dattorro_rev_demo;"
    },
    "dm.jprev_demo": {
      "prefix": "dm",
      "name": "jprev_demo",
      "full_name": "dm.jprev_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `jprev` with all parameters exposed.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\njprev_demo_test = os.osc(440), os.osc(442) : dm.jprev_demo;"
    },
    "dm.greyhole_demo": {
      "prefix": "dm",
      "name": "greyhole_demo",
      "full_name": "dm.greyhole_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Example GUI for `greyhole` with all parameters exposed.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\ngreyhole_demo_test = os.osc(440), os.osc(442) : dm.greyhole_demo;"
    },
    "dm.sawtooth_demo": {
      "prefix": "dm",
      "name": "sawtooth_demo",
      "full_name": "dm.sawtooth_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "An application demonstrating the different sawtooth oscillators of Faust.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nsawtooth_demo_test = dm.sawtooth_demo;"
    },
    "dm.virtual_analog_oscillator_demo": {
      "prefix": "dm",
      "name": "virtual_analog_oscillator_demo",
      "full_name": "dm.virtual_analog_oscillator_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Virtual analog oscillator demo application.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nvirtual_analog_oscillator_demo_test = dm.virtual_analog_oscillator_demo;"
    },
    "dm.velvet_noise_demo": {
      "prefix": "dm",
      "name": "velvet_noise_demo",
      "full_name": "dm.velvet_noise_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Listen to velvet_noise!",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nvelvet_noise_demo_test = dm.velvet_noise_demo;"
    },
    "dm.latch_demo": {
      "prefix": "dm",
      "name": "latch_demo",
      "full_name": "dm.latch_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Illustrate latch operation.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nlatch_demo_test = dm.latch_demo;"
    },
    "dm.envelopes_demo": {
      "prefix": "dm",
      "name": "envelopes_demo",
      "full_name": "dm.envelopes_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Illustrate various envelopes overlaid, including their gate * 1.1.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nenvelopes_demo_test = dm.envelopes_demo;"
    },
    "dm.fft_spectral_level_demo": {
      "prefix": "dm",
      "name": "fft_spectral_level_demo",
      "full_name": "dm.fft_spectral_level_demo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 3,
      "description": "Make a real-time spectrum analyzer using FFT from analyzers.lib.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nfft_spectral_level_demo_test = dm.fft_spectral_level_demo(256);"
    },
    "dm.pospass_demo": {
      "prefix": "dm",
      "name": "pospass_demo",
      "full_name": "dm.pospass_demo",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Use Positive-Pass Filter pospass() to frequency-shift a sine tone. First, a real sinusoid is converted to its analytic-signal form using pospass() to filter out its negative frequency component.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\npospass_demo_test = os.osc(440) : dm.pospass_demo;"
    },
    "dm.exciter": {
      "prefix": "dm",
      "name": "exciter",
      "full_name": "dm.exciter",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Psychoacoustic harmonic exciter, with GUI.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nno = library(\"noises.lib\");\nexciter_test = no.noise : dm.exciter;"
    },
    "dm.vocoder_demo": {
      "prefix": "dm",
      "name": "vocoder_demo",
      "full_name": "dm.vocoder_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Use example of the vocoder function where an impulse train is used as excitation.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nos = library(\"oscillators.lib\");\nno = library(\"noises.lib\");\nvocoder_demo_test = no.noise : dm.vocoder_demo;"
    },
    "dm.colored_noise_demo": {
      "prefix": "dm",
      "name": "colored_noise_demo",
      "full_name": "dm.colored_noise_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A coloured noise signal generator.",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\ncolored_noise_demo_test = dm.colored_noise_demo;"
    },
    "dm.shock_trigger_demo": {
      "prefix": "dm",
      "name": "shock_trigger_demo",
      "full_name": "dm.shock_trigger_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Debounced shock trigger driving a tone. UI:",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nshock_trigger_demo_test = dm.shock_trigger_demo;"
    },
    "dm.projected_gravity_demo": {
      "prefix": "dm",
      "name": "projected_gravity_demo",
      "full_name": "dm.projected_gravity_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Gravity projection mapped to a low-pass filter sweep. UI:",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nprojected_gravity_demo_test = dm.projected_gravity_demo;"
    },
    "dm.total_accel_demo": {
      "prefix": "dm",
      "name": "total_accel_demo",
      "full_name": "dm.total_accel_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Total acceleration envelope mapped to noise amplitude. UI:",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\ntotal_accel_demo_test = dm.total_accel_demo;"
    },
    "dm.orientation6_demo": {
      "prefix": "dm",
      "name": "orientation6_demo",
      "full_name": "dm.orientation6_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 6,
      "description": "Six-axis orientation weights mapped to six tonal channels. UI:",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\norientation6_demo_test = dm.orientation6_demo;"
    },
    "dm.motion_wrapper_demo": {
      "prefix": "dm",
      "name": "motion_wrapper_demo",
      "full_name": "dm.motion_wrapper_demo",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "End-to-end motion feature monitor built on motion.lib:",
      "param_docs": {},
      "example": "dm = library(\"demos.lib\");\nmotion_wrapper_demo_test = dm.motion_wrapper_demo;"
    },
    "en.ar": {
      "prefix": "en",
      "name": "ar",
      "full_name": "en.ar",
      "args": [
        "at",
        "rt",
        "t"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "AR (Attack, Release) envelope generator (useful to create percussion envelopes). `ar` is a standard Faust function.",
      "param_docs": {
        "at": "attack (sec)",
        "rt": "release (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nar_test = no.noise * en.ar(0.02, 0.3, button(\"gate\"));"
    },
    "en.asr": {
      "prefix": "en",
      "name": "asr",
      "full_name": "en.asr",
      "args": [
        "at",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "ASR (Attack, Sustain, Release) envelope generator. `asr` is a standard Faust function.",
      "param_docs": {
        "at": "attack (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nasr_test = no.noise * en.asr(0.05, 0.7, 0.4, button(\"gate\"));"
    },
    "en.adsr": {
      "prefix": "en",
      "name": "adsr",
      "full_name": "en.adsr",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSR (Attack, Decay, Sustain, Release) envelope generator. `adsr` is a standard Faust function.",
      "param_docs": {
        "at": "attack time (sec)",
        "dt": "decay time (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release time (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nadsr_test = no.noise * en.adsr(0.05, 0.1, 0.6, 0.3, button(\"gate\"));"
    },
    "en.adsrf_bias": {
      "prefix": "en",
      "name": "adsrf_bias",
      "full_name": "en.adsrf_bias",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "final",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSR (Attack, Decay, Sustain, Release, Final) envelope generator with control over bias on each segment, and toggle for legato.",
      "param_docs": {
        "at": "attack time (sec)",
        "dt": "decay time (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release time (sec)",
        "final": "final level (between 0..1) but less than or equal to `sl`",
        "b_att": "bias during attack (between 0..1) where 0.5 is no bias.",
        "b_dec": "bias during decay (between 0..1) where 0.5 is no bias.",
        "b_rel": "bias during release (between 0..1) where 0.5 is no bias.",
        "legato": "toggle for legato. If disabled, envelopes \"re-trigger\" from zero.",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nadsrf_bias_test = no.noise * en.adsrf_bias(\n0.05, 0.1, 0.6, 0.4, 0.2,\n0.4, 0.6, 0.5,\ncheckbox(\"legato\"), button(\"gate\")\n);"
    },
    "en.adsr_bias": {
      "prefix": "en",
      "name": "adsr_bias",
      "full_name": "en.adsr_bias",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSR (Attack, Decay, Sustain, Release) envelope generator with control over bias on each segment, and toggle for legato.",
      "param_docs": {
        "at": "attack time (sec)",
        "dt": "decay time (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release time (sec)",
        "b_att": "bias during attack (between 0..1) where 0.5 is no bias.",
        "b_dec": "bias during decay (between 0..1) where 0.5 is no bias.",
        "b_rel": "bias during release (between 0..1) where 0.5 is no bias.",
        "legato": "toggle for legato. If disabled, envelopes \"re-trigger\" from zero.",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nadsr_bias_test = no.noise * en.adsr_bias(\n0.05, 0.1, 0.6, 0.4,\n0.4, 0.6, 0.5,\ncheckbox(\"legato\"), button(\"gate\")\n);"
    },
    "en.ahdsrf_bias": {
      "prefix": "en",
      "name": "ahdsrf_bias",
      "full_name": "en.ahdsrf_bias",
      "args": [
        "at",
        "ht",
        "dt",
        "sl",
        "rt",
        "final",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 11,
      "inputs": 0,
      "outputs": 1,
      "description": "AHDSR (Attack, Hold, Decay, Sustain, Release, Final) envelope generator with control over bias on each segment, and toggle for legato.",
      "param_docs": {
        "at": "attack time (sec)",
        "ht": "hold time (sec)",
        "dt": "decay time (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release time (sec)",
        "final": "final level (between 0..1) but less than or equal to `sl`",
        "b_att": "bias during attack (between 0..1) where 0.5 is no bias.",
        "b_dec": "bias during decay (between 0..1) where 0.5 is no bias.",
        "b_rel": "bias during release (between 0..1) where 0.5 is no bias.",
        "legato": "toggle for legato. If disabled, envelopes \"re-trigger\" from zero.",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nahdsrf_bias_test = no.noise * en.ahdsrf_bias(\n0.05, 0.05, 0.1, 0.6, 0.4, 0.2,\n0.4, 0.6, 0.5,\ncheckbox(\"legato\"), button(\"gate\")\n);"
    },
    "en.ahdsr_bias": {
      "prefix": "en",
      "name": "ahdsr_bias",
      "full_name": "en.ahdsr_bias",
      "args": [
        "at",
        "ht",
        "dt",
        "sl",
        "rt",
        "final",
        "b_att",
        "b_dec",
        "b_rel",
        "legato",
        "t"
      ],
      "arg_count": 11,
      "inputs": 0,
      "outputs": 1,
      "description": "AHDSR (Attack, Hold, Decay, Sustain, Release) envelope generator with control over bias on each segment, and toggle for legato.",
      "param_docs": {
        "at": "attack time (sec)",
        "ht": "hold time (sec)",
        "dt": "decay time (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release time (sec)",
        "final": "final level (between 0..1) but less than or equal to `sl`",
        "b_att": "bias during attack (between 0..1) where 0.5 is no bias.",
        "b_dec": "bias during decay (between 0..1) where 0.5 is no bias.",
        "b_rel": "bias during release (between 0..1) where 0.5 is no bias.",
        "legato": "toggle for legato. If disabled, envelopes \"re-trigger\" from zero.",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nahdsr_bias_test = no.noise * en.ahdsr_bias(\n0.05, 0.05, 0.1, 0.6, 0.4,\n0.4, 0.6, 0.5,\ncheckbox(\"legato\"), button(\"gate\")\n);"
    },
    "en.smoothEnvelope": {
      "prefix": "en",
      "name": "smoothEnvelope",
      "full_name": "en.smoothEnvelope",
      "args": [
        "ar",
        "t"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "An envelope with an exponential attack and release. `smoothEnvelope` is a standard Faust function.",
      "param_docs": {
        "ar": "attack and release duration (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nsmoothEnvelope_test = no.noise * en.smoothEnvelope(0.2, button(\"gate\"));"
    },
    "en.arfe": {
      "prefix": "en",
      "name": "arfe",
      "full_name": "en.arfe",
      "args": [
        "at",
        "rt",
        "fl",
        "t"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "ARFE (Attack and Release-to-Final-value Exponentially) envelope generator. Approximately equal to `smoothEnvelope(Attack/6.91)` when Attack == Release.",
      "param_docs": {
        "at": "attack (sec)",
        "rt": "release (sec)",
        "fl": "final level to approach upon release (such as 0)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\narfe_test = no.noise * en.arfe(0.2, 0.4, 0, button(\"gate\"));"
    },
    "en.are": {
      "prefix": "en",
      "name": "are",
      "full_name": "en.are",
      "args": [
        "at",
        "rt",
        "t"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "ARE (Attack, Release) envelope generator with Exponential segments. Approximately equal to `smoothEnvelope(Attack/6.91)` when Attack == Release.",
      "param_docs": {
        "at": "attack (sec)",
        "rt": "release (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nare_test = no.noise * en.are(0.2, 0.4, button(\"gate\"));"
    },
    "en.asre": {
      "prefix": "en",
      "name": "asre",
      "full_name": "en.asre",
      "args": [
        "at",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "ASRE (Attack, Sustain, Release) envelope generator with Exponential segments.",
      "param_docs": {
        "at": "attack (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nasre_test = no.noise * en.asre(0.2, 0.6, 0.4, button(\"gate\"));"
    },
    "en.adsre": {
      "prefix": "en",
      "name": "adsre",
      "full_name": "en.adsre",
      "args": [
        "at",
        "dt",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "ADSRE (Attack, Decay, Sustain, Release) envelope generator with Exponential segments.",
      "param_docs": {
        "at": "attack (sec)",
        "dt": "decay (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nadsre_test = no.noise * en.adsre(0.2, 0.1, 0.6, 0.4, button(\"gate\"));"
    },
    "en.ahdsre": {
      "prefix": "en",
      "name": "ahdsre",
      "full_name": "en.ahdsre",
      "args": [
        "at",
        "ht",
        "dt",
        "sl",
        "rt",
        "t"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "AHDSRE (Attack, Hold, Decay, Sustain, Release) envelope generator with Exponential segments.",
      "param_docs": {
        "at": "attack (sec)",
        "ht": "hold (sec)",
        "dt": "decay (sec)",
        "sl": "sustain level (between 0..1)",
        "rt": "release (sec)",
        "t": "trigger signal (attack is triggered when `t>0`, release is triggered"
      },
      "example": "en = library(\"envelopes.lib\");\nno = library(\"noises.lib\");\nahdsre_test = no.noise * en.ahdsre(0.2, 0.05, 0.1, 0.6, 0.4, button(\"gate\"));"
    },
    "en.dx7envelope": {
      "prefix": "en",
      "name": "dx7envelope",
      "full_name": "en.dx7envelope",
      "args": [
        "R1",
        "R2",
        "R3",
        "R4",
        "L1",
        "L2",
        "L3",
        "L4",
        "t"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "DX7 operator envelope generator with 4 independent rates and levels. It is essentially a 4 points BPF.",
      "param_docs": {
        "RN": "rates in seconds",
        "LN": "levels (0-1)",
        "t": "trigger signal"
      },
      "example": "en = library(\"envelopes.lib\");\nos = library(\"oscillators.lib\");\ndx7envelope_test = en.dx7envelope(\n0.05, 0.1, 0.1, 0.2,\n1, 0.8, 0.6, 0,\nbutton(\"gate\")\n) * os.osc(440);"
    },
    "en.adsr_bias_env.bias_curve": {
      "prefix": "en",
      "name": "adsr_bias_env.bias_curve",
      "full_name": "en.adsr_bias_env.bias_curve",
      "args": [
        "b",
        "x"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "adsr_bias_env bias_curve filter",
      "param_docs": {},
      "example": ""
    },
    "en.adsr_bias_env.bias_curve_d_dx": {
      "prefix": "en",
      "name": "adsr_bias_env.bias_curve_d_dx",
      "full_name": "en.adsr_bias_env.bias_curve_d_dx",
      "args": [
        "b",
        "x"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "adsr_bias_env bias_curve_d_dx filter",
      "param_docs": {},
      "example": ""
    },
    "en.adsr_bias_env.bias_curve_inverse": {
      "prefix": "en",
      "name": "adsr_bias_env.bias_curve_inverse",
      "full_name": "en.adsr_bias_env.bias_curve_inverse",
      "args": [
        "b",
        "y"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "adsr_bias_env bias_curve_inverse filter",
      "param_docs": {},
      "example": ""
    },
    "en.adsr_bias_env.adsr_bias": {
      "prefix": "en",
      "name": "adsr_bias_env.adsr_bias",
      "full_name": "en.adsr_bias_env.adsr_bias",
      "args": [
        "att",
        "dec",
        "sus",
        "rel",
        "final",
        "bias_att",
        "bias_dec",
        "bias_rel",
        "legato",
        "gate"
      ],
      "arg_count": 10,
      "inputs": 1,
      "outputs": 1,
      "description": "adsr_bias_env adsr_bias filter",
      "param_docs": {},
      "example": ""
    },
    "en.adsr_bias_env.fb": {
      "prefix": "en",
      "name": "adsr_bias_env.fb",
      "full_name": "en.adsr_bias_env.fb",
      "args": [
        "_state",
        "_y"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "adsr_bias_env fb filter",
      "param_docs": {},
      "example": ""
    },
    "en.adsr_bias_env.ahdsr_bias": {
      "prefix": "en",
      "name": "adsr_bias_env.ahdsr_bias",
      "full_name": "en.adsr_bias_env.ahdsr_bias",
      "args": [
        "att",
        "hol",
        "dec",
        "sus",
        "rel",
        "final",
        "bias_att",
        "bias_dec",
        "bias_rel",
        "legato",
        "gate"
      ],
      "arg_count": 11,
      "inputs": 1,
      "outputs": 1,
      "description": "adsr_bias_env ahdsr_bias filter",
      "param_docs": {},
      "example": ""
    },
    "fd.model1D": {
      "prefix": "fd",
      "name": "model1D",
      "full_name": "fd.model1D",
      "args": [
        "points",
        "R",
        "T",
        "scheme"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "This function can be used to obtain a physical model in 1 dimension. Takes a force input signal for each point and outputs the state of each point.",
      "param_docs": {
        "points": "size of the mesh in points",
        "R": "neighbourhood radius, indicates how many side points are needed (i.e.",
        "T": "time coefficient, indicates how much steps back in time are needed (i.",
        "scheme": "coefficients scheme"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nscheme = 0, 0;\nmodel1D_test = si.bus(2)\n: fd.model1D(2, 0, 0, scheme)\n: si.bus(2);"
    },
    "fd.model2D": {
      "prefix": "fd",
      "name": "model2D",
      "full_name": "fd.model2D",
      "args": [
        "pointsX",
        "pointsY",
        "R",
        "T",
        "scheme"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "This function can be used to obtain a physical model in 2 dimension. Takes a force input signal for each point and outputs the state of each point.",
      "param_docs": {
        "pointsX": "horizontal size of the mesh in points",
        "pointsY": "vertical size of the mesh in points",
        "R": "neighbourhood radius, indicates how many side points are needed (i.e.",
        "T": "time coefficient, indicates how much steps back in time are needed (i.",
        "scheme": "coefficients scheme"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nscheme = 0, 0, 0, 0;\nmodel2D_test = si.bus(4)\n: fd.model2D(2, 2, 0, 0, scheme)\n: si.bus(4);"
    },
    "fd.stairsInterp1D": {
      "prefix": "fd",
      "name": "stairsInterp1D",
      "full_name": "fd.stairsInterp1D",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Stairs interpolator in 1 dimension. Takes a number of signals and outputs the same number of signals, where each one is multiplied by zero except the one specified by the argument. This can vary at ru",
      "param_docs": {
        "points": "total number of points in the mesh",
        "point": "number of the desired nonzero signal"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nstairsInterp1D_test = si.bus(4)\n: fd.stairsInterp1D(4, 1);"
    },
    "fd.stairsInterp2D": {
      "prefix": "fd",
      "name": "stairsInterp2D",
      "full_name": "fd.stairsInterp2D",
      "args": [
        "pointsX",
        "pointsY",
        "pointX",
        "pointY"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Stairs interpolator in 2 dimensions. Similar to the 1-D version.",
      "param_docs": {
        "pointsX": "total number of points in the X direction",
        "pointsY": "total number of points in the Y direction",
        "pointX": "horizontal index of the desired nonzero signal",
        "pointY": "vertical index of the desired nonzero signal"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nstairsInterp2D_test = si.bus(4)\n: fd.stairsInterp2D(2, 2, 1, 0);"
    },
    "fd.linInterp1D": {
      "prefix": "fd",
      "name": "linInterp1D",
      "full_name": "fd.linInterp1D",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 1 dimension. Takes a number of signals and outputs the same number of signals, where each one is multiplied by zero except two signals around a floating point index. This is ess",
      "param_docs": {
        "points": "total number of points in the mesh",
        "point": "floating point index"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nlinInterp1D_test = si.bus(4)\n: fd.linInterp1D(4, 1.25);"
    },
    "fd.linInterp2D": {
      "prefix": "fd",
      "name": "linInterp2D",
      "full_name": "fd.linInterp2D",
      "args": [
        "pointsX",
        "pointsY",
        "pointX",
        "pointY"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 2 dimensions. Similar to the 1 D version.",
      "param_docs": {
        "pointsX": "total number of points in the X direction",
        "pointsY": "total number of points in the Y direction",
        "pointX": "horizontal float index",
        "pointY": "vertical float index"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nlinInterp2D_test = si.bus(4)\n: fd.linInterp2D(2, 2, 0.6, 1.2);"
    },
    "fd.stairsInterp1DOut": {
      "prefix": "fd",
      "name": "stairsInterp1DOut",
      "full_name": "fd.stairsInterp1DOut",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Stairs interpolator in 1 dimension. Similar to `stairsInterp1D`, except it outputs only the desired signal.",
      "param_docs": {
        "points": "total number of points in the mesh",
        "point": "number of the desired nonzero signal"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nstairsInterp1DOut_test = si.bus(4)\n: fd.stairsInterp1DOut(4, 2);"
    },
    "fd.stairsInterp2DOut": {
      "prefix": "fd",
      "name": "stairsInterp2DOut",
      "full_name": "fd.stairsInterp2DOut",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 2 dimensions which outputs only one signal.",
      "param_docs": {
        "pointsX": "total number of points in the X direction",
        "pointsY": "total number of points in the Y direction",
        "pointX": "horizontal float index",
        "pointY": "vertical float index"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nlinInterp2DOut_test = si.bus(4)\n: fd.linInterp2DOut(2, 2, 0.6, 1.2);"
    },
    "fd.linInterp1DOut": {
      "prefix": "fd",
      "name": "linInterp1DOut",
      "full_name": "fd.linInterp1DOut",
      "args": [
        "points",
        "point"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator in 1 dimension. Similar to `stairsInterp1D`, except it sums each output signal and provides only one output value.",
      "param_docs": {
        "points": "total number of points in the mesh",
        "point": "floating point index"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nlinInterp1DOut_test = si.bus(4)\n: fd.linInterp1DOut(4, 1.5);"
    },
    "fd.route1D": {
      "prefix": "fd",
      "name": "route1D",
      "full_name": "fd.route1D",
      "args": [
        "points",
        "R",
        "T"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Routing function for 1 dimensional schemes.",
      "param_docs": {
        "points": "total number of points in the mesh",
        "R": "neighbourhood radius",
        "T": "time coefficient"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nroute1D_test = par(i, 3, 0)\n: fd.route1D(1, 0, 0)\n: si.bus(3);"
    },
    "fd.route2D": {
      "prefix": "fd",
      "name": "route2D",
      "full_name": "fd.route2D",
      "args": [
        "pointsX",
        "pointsY",
        "R",
        "T"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Routing function for 2 dimensional schemes.",
      "param_docs": {
        "pointsX": "total number of points in the X direction",
        "pointsY": "total number of points in the Y direction",
        "R": "neighbourhood radius",
        "T": "time coefficient"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nroute2D_test = par(i, 3, 0)\n: fd.route2D(1, 1, 0, 0)\n: si.bus(3);"
    },
    "fd.schemePoint": {
      "prefix": "fd",
      "name": "schemePoint",
      "full_name": "fd.schemePoint",
      "args": [
        "R",
        "T",
        "D"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "This function calculates the next state for each mesh point, in order to form a scheme, several of these blocks need to be stacked in parallel. This function takes in input, in order, the force, the c",
      "param_docs": {
        "R": "neighbourhood radius",
        "T": "time coefficient",
        "D": "scheme spatial dimensions (i.e. 1 if 1-D, 2 if 2-D)"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nschemePoint_test = par(i, 3, 0)\n: fd.schemePoint(0, 0, 1);"
    },
    "fd.buildScheme1D": {
      "prefix": "fd",
      "name": "buildScheme1D",
      "full_name": "fd.buildScheme1D",
      "args": [
        "points",
        "R",
        "T"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "This function is used to stack in parallel several schemePoint functions in 1 dimension, according to the number of points.",
      "param_docs": {
        "points": "total number of points in the mesh",
        "R": "neighbourhood radius",
        "T": "time coefficient"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nbuildScheme1D_test = par(i, 3, 0)\n: fd.buildScheme1D(1, 0, 0);"
    },
    "fd.buildScheme2D": {
      "prefix": "fd",
      "name": "buildScheme2D",
      "full_name": "fd.buildScheme2D",
      "args": [
        "pointsX",
        "pointsY",
        "R",
        "T"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "This function is used to stack in parallel several schemePoint functions in 2 dimensions, according to the number of points in the X and Y directions.",
      "param_docs": {
        "pointsX": "total number of points in the X direction",
        "pointsY": "total number of points in the Y direction",
        "R": "neighbourhood radius",
        "T": "time coefficient"
      },
      "example": "fd = library(\"fds.lib\");\nsi = library(\"signals.lib\");\nbuildScheme2D_test = par(i, 3, 0)\n: fd.buildScheme2D(1, 1, 0, 0);"
    },
    "fd.hammer": {
      "prefix": "fd",
      "name": "hammer",
      "full_name": "fd.hammer",
      "args": [
        "coeff",
        "omega0Sqr",
        "sigma0",
        "kH",
        "alpha",
        "k",
        "offset",
        "fIn"
      ],
      "arg_count": 8,
      "inputs": 1,
      "outputs": 1,
      "description": "Implementation of a nonlinear collision model. The hammer is essentially a finite difference scheme of a linear damped oscillator, which is coupled with the mesh through the collision model (see Stefa",
      "param_docs": {
        "coeff": "output force scaling coefficient",
        "omega0Sqr": "squared angular frequency of the hammer oscillator",
        "sigma0": "damping coefficient of the hammer oscillator",
        "kH": "hammer stiffness coefficient",
        "alpha": "nonlinearity parameter",
        "k": "time sampling step (the same as for the mesh)",
        "offset": "distance between the string and the hammer at rest in meters",
        "fIn": "hammer excitation signal (i.e. a button)"
      },
      "example": "fd = library(\"fds.lib\");\nos = library(\"oscillators.lib\");\nhammer_test = os.osc(5)\n: fd.hammer(\n0.1,\n1000,\n0.01,\n1e5,\n2.0,\n1.0/48000,\n0.001,\nbutton(\"hammer:trigger\")\n);"
    },
    "fd.bow": {
      "prefix": "fd",
      "name": "bow",
      "full_name": "fd.bow",
      "args": [
        "coeff",
        "alpha",
        "k",
        "vb"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Implementation of a nonlinear friction based interaction model that induces Helmholtz motion. (see Stefan Bilbao's book, Numerical Sound Synthesis).",
      "param_docs": {
        "coeff": "output force scaling coefficient",
        "alpha": "nonlinearity parameter",
        "k": "time sampling step (the same as for the mesh)",
        "vb": "bow velocity [m/s]"
      },
      "example": "fd = library(\"fds.lib\");\nos = library(\"oscillators.lib\");\nbow_test = os.osc(5)\n: fd.bow(0.05, 2.0, 1.0/48000, 0.1);"
    },
    "fi.zero": {
      "prefix": "fi",
      "name": "zero",
      "full_name": "fi.zero",
      "args": [
        "z"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One zero filter. Difference equation: \\(y(n) = x(n) - zx(n-1)\\).",
      "param_docs": {
        "z": "location of zero along real axis in z-plane"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nzero_test = os.osc(440) : fi.zero(0.5);"
    },
    "fi.pole": {
      "prefix": "fi",
      "name": "pole",
      "full_name": "fi.pole",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One pole filter. Could also be called a \"leaky integrator\". Difference equation: \\(y(n) = x(n) + py(n-1)\\).",
      "param_docs": {
        "p": "pole location = feedback coefficient"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\npole_test = os.osc(440) : fi.pole(0.9);"
    },
    "fi.integrator": {
      "prefix": "fi",
      "name": "integrator",
      "full_name": "fi.integrator",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Same as `pole(1)` [implemented separately for block-diagram clarity].",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nintegrator_test = os.osc(440) : fi.integrator;"
    },
    "fi.dcblockerat": {
      "prefix": "fi",
      "name": "dcblockerat",
      "full_name": "fi.dcblockerat",
      "args": [
        "fb"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "DC blocker with configurable \"break frequency\". The amplitude response is substantially flat above `fb`, and sloped at about +6 dB/octave below `fb`.",
      "param_docs": {
        "fb": "\"break frequency\" in Hz, i.e., -3 dB gain frequency (see 2nd reference below)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ndcblockerat_test = os.osc(440) : fi.dcblockerat(30);"
    },
    "fi.dcblocker": {
      "prefix": "fi",
      "name": "dcblocker",
      "full_name": "fi.dcblocker",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "DC blocker. Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz) and high-frequency gain near 1.0025 (due to no scaling). `dcblocker` is as standard Faust function.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ndcblocker_test = os.osc(440) : fi.dcblocker;"
    },
    "fi.lptN": {
      "prefix": "fi",
      "name": "lptN",
      "full_name": "fi.lptN",
      "args": [
        "N",
        "tN"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass filter with arbitrary dis/charging factors set in dB and times set in seconds.",
      "param_docs": {
        "N": "is the attenuation factor in dB",
        "tN": "is the filter period in seconds, that is, the time for the"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlptN_test = os.osc(440) : fi.lptN(60, 0.1);"
    },
    "fi.lptau": {
      "prefix": "fi",
      "name": "lptau",
      "full_name": "fi.lptau",
      "args": [
        "tN"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass with a tau time constant (1/e attenuation after `tN` seconds).",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlptau_test = os.osc(440) : fi.lptau(0.1);"
    },
    "fi.lpt60": {
      "prefix": "fi",
      "name": "lpt60",
      "full_name": "fi.lpt60",
      "args": [
        "tN"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass with a T60 time constant (60 dB attenuation after `tN` seconds).",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlpt60_test = os.osc(440) : fi.lpt60(0.3);"
    },
    "fi.lpt19": {
      "prefix": "fi",
      "name": "lpt19",
      "full_name": "fi.lpt19",
      "args": [
        "tN"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "One-pole lowpass with a T19 time constant (approx. 19 dB attenuation after `tN` seconds).",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlpt19_test = os.osc(440) : fi.lpt19(0.2);"
    },
    "fi.ff_comb": {
      "prefix": "fi",
      "name": "ff_comb",
      "full_name": "fi.ff_comb",
      "args": [
        "maxdel",
        "intdel",
        "b0",
        "bM"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Forward Comb Filter. Note that `ff_comb` requires integer delays (uses `delay`  internally). `ff_comb` is a standard Faust function.",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "intdel": "current (integer) comb-filter delay between 0 and maxdel",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "b0": "gain applied to delay-line input",
        "bM": "gain applied to delay-line output and then summed with input"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nff_comb_test = os.osc(440) : fi.ff_comb(2048, 64, 1, 0.7);"
    },
    "fi.ff_fcomb": {
      "prefix": "fi",
      "name": "ff_fcomb",
      "full_name": "fi.ff_fcomb",
      "args": [
        "maxdel",
        "del",
        "b0",
        "bM"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Forward Comb Filter. Note that `ff_fcomb` takes floating-point delays (uses `fdelay` internally). `ff_fcomb` is a standard Faust function.",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "b0": "gain applied to delay-line input",
        "bM": "gain applied to delay-line output and then summed with input"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nff_fcomb_test = os.osc(440) : fi.ff_fcomb(2048, 64.5, 1, 0.7);"
    },
    "fi.ffcombfilter": {
      "prefix": "fi",
      "name": "ffcombfilter",
      "full_name": "fi.ffcombfilter",
      "args": [
        "maxdel",
        "del",
        "g"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Typical special case of `ff_comb()` where: `b0 = 1`.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nffcombfilter_test = os.osc(440) : fi.ffcombfilter(2048, 64, 0.7);"
    },
    "fi.fb_comb_common": {
      "prefix": "fi",
      "name": "fb_comb_common",
      "full_name": "fi.fb_comb_common",
      "args": [
        "dop",
        "N",
        "b0",
        "aN"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "A generic feedback comb filter.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfb_comb_common_test = os.osc(440) : fi.fb_comb_common(@, 64, 0.8, 0.6);"
    },
    "fi.fb_comb": {
      "prefix": "fi",
      "name": "fb_comb",
      "full_name": "fi.fb_comb",
      "args": [
        "maxdel",
        "del",
        "b0",
        "aN"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Back Comb Filter (integer delay).",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "b0": "gain applied to delay-line input and forwarded to output",
        "aN": "minus the gain applied to delay-line output before summing with the input"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfb_comb_test = os.osc(440) : fi.fb_comb(2048, 64, 0.7, 0.6);"
    },
    "fi.fb_fcomb": {
      "prefix": "fi",
      "name": "fb_fcomb",
      "full_name": "fi.fb_fcomb",
      "args": [
        "maxdel",
        "del",
        "b0",
        "aN"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Feed-Back Comb Filter (floating point delay).",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "b0": "gain applied to delay-line input and forwarded to output",
        "aN": "minus the gain applied to delay-line output before summing with the input"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfb_fcomb_test = os.osc(440) : fi.fb_fcomb(2048, 64.5, 0.7, 0.6);"
    },
    "fi.rev1": {
      "prefix": "fi",
      "name": "rev1",
      "full_name": "fi.rev1",
      "args": [
        "maxdel",
        "N",
        "g"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Special case of `fb_comb` (`rev1(maxdel,N,g)`). The \"rev1 section\" dates back to the 1960s in computer-music reverberation. See the `jcrev` and `brassrev` in `reverbs.lib` for usage examples.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nrev1_test = os.osc(440) : fi.rev1(2048, 64, 0.6);"
    },
    "fi.fbcombfilter": {
      "prefix": "fi",
      "name": "fbcombfilter",
      "full_name": "fi.fbcombfilter",
      "args": [
        "maxdel",
        "intdel",
        "g"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Other special cases of Feed-Back Comb Filter.",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "intdel": "current (integer) comb-filter delay between 0 and maxdel",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "g": "feedback gain"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfbcombfilter_test = os.osc(440) : fi.fbcombfilter(2048, 64, 0.6);\nffbcombfilter_test = os.osc(440) : fi.ffbcombfilter(2048, 64.5, 0.6);"
    },
    "fi.allpass_comb": {
      "prefix": "fi",
      "name": "allpass_comb",
      "full_name": "fi.allpass_comb",
      "args": [
        "maxdel",
        "intdel",
        "aN"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Schroeder Allpass Comb Filter. Note that:",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "intdel": "current (integer) comb-filter delay between 0 and maxdel",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "aN": "minus the feedback gain"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpass_comb_test = os.osc(440) : fi.allpass_comb(2048, 64, 0.6);"
    },
    "fi.allpass_fcomb": {
      "prefix": "fi",
      "name": "allpass_fcomb",
      "full_name": "fi.allpass_fcomb",
      "args": [
        "maxdel",
        "intdel",
        "aN"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Schroeder Allpass Comb Filter. Note that:",
      "param_docs": {
        "maxdel": "maximum delay (a power of 2)",
        "intdel": "current (float) comb-filter delay between 0 and maxdel",
        "del": "current (float) comb-filter delay between 0 and maxdel",
        "aN": "minus the feedback gain"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpass_fcomb_test = os.osc(440) : fi.allpass_fcomb(2048, 64.5, 0.6);"
    },
    "fi.rev2": {
      "prefix": "fi",
      "name": "rev2",
      "full_name": "fi.rev2",
      "args": [
        "maxlen",
        "len",
        "g"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Special case of `allpass_comb` (`rev2(maxlen,len,g)`). The \"rev2 section\" dates back to the 1960s in computer-music reverberation. See the `jcrev` and `brassrev` in `reverbs.lib` for usage examples.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nrev2_test = os.osc(440) : fi.rev2(2048, 64, 0.6);"
    },
    "fi.allpass_fcomb5": {
      "prefix": "fi",
      "name": "allpass_fcomb5",
      "full_name": "fi.allpass_fcomb5",
      "args": [
        "maxdel",
        "N",
        "aN"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as `allpass_fcomb` but use `fdelay5` and `fdelay1a` internally (Interpolation helps - look at an fft of faust2octave on: `1-1' <: allpass_fcomb(1024,10.5,0.95), allpass_fcomb5(1024,10.5,0.95);`)",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpass_fcomb5_test = os.osc(440) : fi.allpass_fcomb5(2048, 64.5, 0.6);\nallpass_fcomb1a_test = os.osc(440) : fi.allpass_fcomb1a(2048, 64.5, 0.6);"
    },
    "fi.iir": {
      "prefix": "fi",
      "name": "iir",
      "full_name": "fi.iir",
      "args": [
        "bcoeffs",
        "acoeffs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Nth-order Infinite-Impulse-Response (IIR) digital filter, implemented in terms of the Transfer-Function (TF) coefficients. Such filter structures are termed \"direct form\".",
      "param_docs": {
        "bcoeffs": "(b0,b1,...,b_order) = TF numerator coefficients",
        "acoeffs": "(a1,...,a_order) = TF denominator coeffs (a0=1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\niir_test = os.osc(440) : fi.iir((0.5, 0.5), (0.3));"
    },
    "fi.fir": {
      "prefix": "fi",
      "name": "fir",
      "full_name": "fi.fir",
      "args": [
        "bv"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "FIR filter (convolution of FIR filter coefficients with a signal). `fir` is standard Faust function.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfir_test = os.osc(440) : fi.fir((0.2, 0.2, 0.2, 0.2, 0.2));"
    },
    "fi.conv": {
      "prefix": "fi",
      "name": "conv",
      "full_name": "fi.conv",
      "args": [
        "N",
        "(k1",
        "k2",
        "k3",
        "..."
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Convolution of input signal with given coefficients.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsi = library(\"signals.lib\");\nconvN_test = (os.osc(440) <: si.bus(3)) : fi.convN(3, (0.3, 0.2, 0.1, 0.05));\nconv_test = os.osc(440) : fi.conv((0.25, 0.25, 0.25, 0.25));"
    },
    "fi.tf1": {
      "prefix": "fi",
      "name": "tf1",
      "full_name": "fi.tf1",
      "args": [
        "b0",
        "b1",
        "a1"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "tfN = N'th-order direct-form digital filter.",
      "param_docs": {
        "b": "transfer-function numerator",
        "a": "transfer-function denominator (monic)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ntf1_test = os.osc(440) : fi.tf1(0.5, 0.25, -0.4);\ntf2_test = os.osc(440) : fi.tf2(0.1, 0.2, 0.1, -0.5, 0.06);\ntf3_test = os.osc(440) : fi.tf3(0.1, 0.3, 0.3, 0.1, -0.9, 0.26, -0.024);"
    },
    "fi.notchw": {
      "prefix": "fi",
      "name": "notchw",
      "full_name": "fi.notchw",
      "args": [
        "width",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple notch filter based on a biquad (`tf2`). `notchw` is a standard Faust function.",
      "param_docs": {
        "width": "\"notch width\" in Hz (approximate)",
        "freq": "\"notch frequency\" in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nnotchw_test = os.osc(440) : fi.notchw(200, 1000);"
    },
    "fi.tf21": {
      "prefix": "fi",
      "name": "tf21",
      "full_name": "fi.tf21",
      "args": [
        "b0",
        "b1",
        "b2",
        "a1",
        "a2"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "tfN = N'th-order direct-form digital filter where:",
      "param_docs": {
        "b": "transfer-function numerator",
        "a": "transfer-function denominator (monic)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ntf21_test = os.osc(440) : fi.tf21(0.1, 0.2, 0.1, -0.5, 0.06);\ntf22_test = os.osc(440) : fi.tf22(0.1, 0.2, 0.1, -0.5, 0.06);\ntf22t_test = os.osc(440) : fi.tf22t(0.1, 0.2, 0.1, -0.5, 0.06);\ntf21t_test = os.osc(440) : fi.tf21t(0.1, 0.2, 0.1, -0.5, 0.06);"
    },
    "fi.av2sv": {
      "prefix": "fi",
      "name": "av2sv",
      "full_name": "fi.av2sv",
      "args": [
        "av"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Compute reflection coefficients sv from transfer-function denominator av.",
      "param_docs": {
        "av": "parallel signal bank `a1,...,aN`",
        "sv": "parallel signal bank `s1,...,sN`"
      },
      "example": "fi = library(\"filters.lib\");\nsi = library(\"signals.lib\");\nav2sv_test = fi.av2sv((-0.4, 0.1)) : si.bus(2);"
    },
    "fi.bvav2nuv": {
      "prefix": "fi",
      "name": "bvav2nuv",
      "full_name": "fi.bvav2nuv",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Compute lattice tap coefficients from transfer-function coefficients.",
      "param_docs": {
        "av": "parallel signal bank `a1,...,aN`",
        "bv": "parallel signal bank `b0,b1,...,aN`",
        "nuv": "parallel signal bank  `nu1,...,nuN`"
      },
      "example": "fi = library(\"filters.lib\");\nsi = library(\"signals.lib\");\nbvav2nuv_test = fi.bvav2nuv((0.1, 0.2, 0.3), (-0.4, 0.1)) : si.bus(3);"
    },
    "fi.iir_lat2": {
      "prefix": "fi",
      "name": "iir_lat2",
      "full_name": "fi.iir_lat2",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-multiply lattice IIR filter of arbitrary order.",
      "param_docs": {
        "bv": "transfer-function numerator",
        "av": "transfer-function denominator (monic)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\niir_lat2_test = os.osc(440) : fi.iir_lat2((0.1, 0.2, 0.3), (-0.4, 0.1));"
    },
    "fi.allpassnt": {
      "prefix": "fi",
      "name": "allpassnt",
      "full_name": "fi.allpassnt",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-multiply lattice allpass (nested order-1 direct-form-ii allpasses), with taps.",
      "param_docs": {
        "n": "the order of the filter",
        "sv": "the reflection coefficients (-1 1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsi = library(\"signals.lib\");\nallpassnt_test = os.osc(440) : fi.allpassnt(2, (0.3, -0.2)) : si.bus(3);"
    },
    "fi.iir_kl": {
      "prefix": "fi",
      "name": "iir_kl",
      "full_name": "fi.iir_kl",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Kelly-Lochbaum ladder IIR filter of arbitrary order.",
      "param_docs": {
        "bv": "transfer-function numerator",
        "av": "transfer-function denominator (monic)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\niir_kl_test = os.osc(440) : fi.iir_kl((0.1, 0.2, 0.3), (-0.4, 0.1));"
    },
    "fi.allpassnklt": {
      "prefix": "fi",
      "name": "allpassnklt",
      "full_name": "fi.allpassnklt",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Kelly-Lochbaum ladder allpass.",
      "param_docs": {
        "n": "the order of the filter",
        "sv": "the reflection coefficients (-1 1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsi = library(\"signals.lib\");\nallpassnklt_test = os.osc(440) : fi.allpassnklt(2, (0.3, -0.2)) : si.bus(3);"
    },
    "fi.iir_lat1": {
      "prefix": "fi",
      "name": "iir_lat1",
      "full_name": "fi.iir_lat1",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-multiply lattice IIR filter of arbitrary order.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\niir_lat1_test = os.osc(440) : fi.iir_lat1((0.1, 0.2, 0.3), (-0.4, 0.1));"
    },
    "fi.allpassn1mt": {
      "prefix": "fi",
      "name": "allpassn1mt",
      "full_name": "fi.allpassn1mt",
      "args": [
        "N",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-multiply lattice allpass with tap lines.",
      "param_docs": {
        "N": "the order of the filter (fixed at compile time)",
        "sv": "the reflection coefficients (-1 1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsi = library(\"signals.lib\");\nallpassn1mt_test = os.osc(440) : fi.allpassn1mt(2, (0.3, -0.2)) : si.bus(3);"
    },
    "fi.iir_nl": {
      "prefix": "fi",
      "name": "iir_nl",
      "full_name": "fi.iir_nl",
      "args": [
        "bv",
        "av"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Normalized ladder filter of arbitrary order.",
      "param_docs": {
        "bv": "transfer-function numerator",
        "av": "transfer-function denominator (monic)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\niir_nl_test = os.osc(440) : fi.iir_nl((0.1, 0.2, 0.3), (-0.4, 0.1));"
    },
    "fi.allpassnnlt": {
      "prefix": "fi",
      "name": "allpassnnlt",
      "full_name": "fi.allpassnnlt",
      "args": [
        "N",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Normalized ladder allpass filter of arbitrary order.",
      "param_docs": {
        "N": "the order of the filter (fixed at compile time)",
        "sv": "the reflection coefficients (-1 1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsi = library(\"signals.lib\");\nallpassnnlt_test = os.osc(440) : fi.allpassnnlt(2, (0.3, -0.2)) : si.bus(3);"
    },
    "fi.tf2np": {
      "prefix": "fi",
      "name": "tf2np",
      "full_name": "fi.tf2np",
      "args": [
        "b0",
        "b1",
        "b2",
        "a1",
        "a2"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Biquad based on a stable second-order Normalized Ladder Filter (more robust to modulation than `tf2` and protected against instability).",
      "param_docs": {
        "b": "transfer-function numerator",
        "a": "transfer-function denominator (monic)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ntf2np_test = os.osc(440) : fi.tf2np(0.6, 0.3, 0.2, -0.5, 0.2);"
    },
    "fi.wgr": {
      "prefix": "fi",
      "name": "wgr",
      "full_name": "fi.wgr",
      "args": [
        "f",
        "r"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order transformer-normalized digital waveguide resonator.",
      "param_docs": {
        "f": "resonance frequency (Hz)",
        "r": "loss factor for exponential decay (set to 1 to make a numerically stable oscillator)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nwgr_test = fi.wgr(440, 0.995, os.osc(440));"
    },
    "fi.nlf2": {
      "prefix": "fi",
      "name": "nlf2",
      "full_name": "fi.nlf2",
      "args": [
        "f",
        "r"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Second order normalized digital waveguide resonator.",
      "param_docs": {
        "f": "resonance frequency (Hz)",
        "r": "loss factor for exponential decay (set to 1 to make a sinusoidal oscillator)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nnlf2_test = fi.nlf2(440, 0.995, os.osc(440));"
    },
    "fi.apnl": {
      "prefix": "fi",
      "name": "apnl",
      "full_name": "fi.apnl",
      "args": [
        "a1",
        "a2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Passive Nonlinear Allpass based on Pierce switching springs idea. Switch between allpass coefficient `a1` and `a2` at signal zero crossings.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\napnl_test = fi.apnl(0.5, -0.5, os.osc(440));"
    },
    "fi.scatN": {
      "prefix": "fi",
      "name": "scatN",
      "full_name": "fi.scatN",
      "args": [
        "N",
        "av",
        "filter"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "N-port scattering junction.",
      "param_docs": {
        "N": "number of incoming/outgoing waves",
        "av": "vector (list) of `N` alpha parameters (each between 0 and 2, and normally summing to 2): <https://ccrma.stanford.edu/~jos/pasp/Alpha_Parameters.html>",
        "filter": "optional junction filter to apply (`_` for none, see below)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nscatN_test = (os.osc(440), os.osc(660)) : fi.scatN(2, (1, 1), _);"
    },
    "fi.scat": {
      "prefix": "fi",
      "name": "scat",
      "full_name": "fi.scat",
      "args": [
        "s",
        "r"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Scatter off of reflectance r with reflection coefficient s.",
      "param_docs": {
        "s": "reflection coefficient between -1 and 1 for stability",
        "r": "single-input, single-output block diagram,"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nscat_test = os.osc(440) : fi.scat(0.5, _);"
    },
    "fi.allpassn": {
      "prefix": "fi",
      "name": "allpassn",
      "full_name": "fi.allpassn",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-multiply lattice filter.",
      "param_docs": {
        "n": "the order of the filter",
        "sv": "the reflection coefficients  (s1,s2,...,sN), each between -1 and 1."
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpassn_test = os.osc(440) : fi.allpassn(3, (0.3, 0.2, 0.1));"
    },
    "fi.allpassnn": {
      "prefix": "fi",
      "name": "allpassnn",
      "full_name": "fi.allpassnn",
      "args": [
        "n",
        "tv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Normalized form - four multiplies and two adds per section, but coefficients can be time varying and nonlinear without \"parametric amplification\" (modulation of signal energy).",
      "param_docs": {
        "n": "the order of the filter",
        "tv": "the reflection coefficients (-PI PI)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpassnn_test = os.osc(440) : fi.allpassnn(3, (0.3, 0.2, 0.1));"
    },
    "fi.allpassnkl": {
      "prefix": "fi",
      "name": "allpassnkl",
      "full_name": "fi.allpassnkl",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Kelly-Lochbaum form - four multiplies and two adds per section, but all signals have an immediate physical interpretation as traveling pressure waves, etc.",
      "param_docs": {
        "n": "the order of the filter",
        "sv": "the reflection coefficients (-1 1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpassnkl_test = os.osc(440) : fi.allpassnkl(3, (0.3, 0.2, 0.1));"
    },
    "fi.allpass1m": {
      "prefix": "fi",
      "name": "allpass1m",
      "full_name": "fi.allpass1m",
      "args": [
        "n",
        "sv"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One-multiply form - one multiply and three adds per section. Normally the most efficient in special-purpose hardware.",
      "param_docs": {
        "n": "the order of the filter",
        "sv": "the reflection coefficients (-1 1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nallpassn1m_test = os.osc(440) : fi.allpassn1m(3, (0.3, 0.2, 0.1));"
    },
    "fi.tf2s": {
      "prefix": "fi",
      "name": "tf2s",
      "full_name": "fi.tf2s",
      "args": [
        "b2",
        "b1",
        "b0",
        "a1",
        "a0",
        "w1"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "Second-order direct-form digital filter, specified by ANALOG transfer-function polynomials B(s)/A(s), and a frequency-scaling parameter. Digitization via the",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\ntf2s_test = os.osc(440) : fi.tf2s(0, 0, 1, sqrt(2), 1, ma.PI*ma.SR/2);"
    },
    "fi.tf1snp": {
      "prefix": "fi",
      "name": "tf1snp",
      "full_name": "fi.tf1snp",
      "args": [
        "b1",
        "b0",
        "a0"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order special case of tf2snp above.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\ntf1snp_test = os.osc(440) : fi.tf1snp(0, 1, 1, ma.PI*ma.SR/2);"
    },
    "fi.tf3slf": {
      "prefix": "fi",
      "name": "tf3slf",
      "full_name": "fi.tf3slf",
      "args": [
        "b3",
        "b2",
        "b1",
        "b0",
        "a3",
        "a2",
        "a1",
        "a0"
      ],
      "arg_count": 8,
      "inputs": 1,
      "outputs": 1,
      "description": "Analogous to `tf2s` above, but third order, and using the typical low-frequency-matching bilinear-transform constant 2/T (\"lf\" series) instead of the specific-frequency-matching value used in `tf2s` a",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ntf3slf_test = os.osc(440) : fi.tf3slf(0, 0, 0, 1, 1, 2, 2, 1);"
    },
    "fi.tf1s": {
      "prefix": "fi",
      "name": "tf1s",
      "full_name": "fi.tf1s",
      "args": [
        "b1",
        "b0",
        "a0",
        "w1"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order direct-form digital filter, specified by ANALOG transfer-function polynomials B(s)/A(s), and a frequency-scaling parameter.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\ntf1s_test = os.osc(440) : fi.tf1s(0, 1, 1, ma.PI*ma.SR/2);"
    },
    "fi.tf2sb": {
      "prefix": "fi",
      "name": "tf2sb",
      "full_name": "fi.tf2sb",
      "args": [
        "b2",
        "b1",
        "b0",
        "a1",
        "a0",
        "w1",
        "wc"
      ],
      "arg_count": 7,
      "inputs": 1,
      "outputs": 1,
      "description": "Bandpass mapping of `tf2s`: In addition to a frequency-scaling parameter `w1` (set to HALF the desired passband width in rad/sec), there is a desired center-frequency parameter wc (also in rad/s).",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\ntf2sb_test = os.osc(440) : fi.tf2sb(0, 0, 1, sqrt(2), 1, 2*ma.PI*200, 2*ma.PI*1000);"
    },
    "fi.tf1sb": {
      "prefix": "fi",
      "name": "tf1sb",
      "full_name": "fi.tf1sb",
      "args": [
        "b1",
        "b0",
        "a0",
        "w1",
        "wc"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "First-to-second-order lowpass-to-bandpass section mapping, analogous to tf2sb above.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\ntf1sb_test = os.osc(440) : fi.tf1sb(0, 1, 1, 2*ma.PI*200, 2*ma.PI*1000);"
    },
    "fi.resonlp": {
      "prefix": "fi",
      "name": "resonlp",
      "full_name": "fi.resonlp",
      "args": [
        "fc",
        "Q",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple resonant lowpass filter based on `tf2s` (virtual analog). `resonlp` is a standard Faust function.",
      "param_docs": {
        "fc": "center frequency (Hz)",
        "Q": "q",
        "gain": "gain (0-1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nresonlp_test = os.osc(440) : fi.resonlp(1000, 2, 0.8);"
    },
    "fi.resonhp": {
      "prefix": "fi",
      "name": "resonhp",
      "full_name": "fi.resonhp",
      "args": [
        "fc",
        "Q",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple resonant highpass filters based on `tf2s` (virtual analog). `resonhp` is a standard Faust function.",
      "param_docs": {
        "fc": "center frequency (Hz)",
        "Q": "q",
        "gain": "gain (0-1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nresonhp_test = fi.resonhp(1000, 2, 0.8, os.osc(440));"
    },
    "fi.resonbp": {
      "prefix": "fi",
      "name": "resonbp",
      "full_name": "fi.resonbp",
      "args": [
        "fc",
        "Q",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Simple resonant bandpass filters based on `tf2s` (virtual analog). `resonbp` is a standard Faust function.",
      "param_docs": {
        "fc": "center frequency (Hz)",
        "Q": "q",
        "gain": "gain (0-1)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nresonbp_test = os.osc(440) : fi.resonbp(1000, 2, 0.8);"
    },
    "fi.lowpass": {
      "prefix": "fi",
      "name": "lowpass",
      "full_name": "fi.lowpass",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Nth-order Butterworth lowpass filter. `lowpass` is a standard Faust function.",
      "param_docs": {
        "N": "filter order (number of poles), nonnegative constant numerical expression",
        "fc": "desired cut-off frequency (-3dB frequency) in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlowpass_test = os.osc(440) : fi.lowpass(4, 2000);"
    },
    "fi.highpass": {
      "prefix": "fi",
      "name": "highpass",
      "full_name": "fi.highpass",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Nth-order Butterworth highpass filter. `highpass` is a standard Faust function.",
      "param_docs": {
        "N": "filter order (number of poles), nonnegative constant numerical expression",
        "fc": "desired cut-off frequency (-3dB frequency) in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass_test = os.osc(440) : fi.highpass(4, 500);"
    },
    "fi.lowpass0_highpass1": {
      "prefix": "fi",
      "name": "lowpass0_highpass1",
      "full_name": "fi.lowpass0_highpass1",
      "args": [
        "s",
        "N",
        "fc"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlowpass0_highpass1_test = os.osc(440) : fi.lowpass0_highpass1(0, 2, 1000);"
    },
    "fi.highpass_plus_lowpass": {
      "prefix": "fi",
      "name": "highpass_plus_lowpass",
      "full_name": "fi.highpass_plus_lowpass",
      "args": [
        "1",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass_plus_lowpass_test = os.osc(440) : fi.highpass_plus_lowpass(3, 1000);"
    },
    "fi.highpass_minus_lowpass": {
      "prefix": "fi",
      "name": "highpass_minus_lowpass",
      "full_name": "fi.highpass_minus_lowpass",
      "args": [
        "3",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass_minus_lowpass_test = os.osc(440) : fi.highpass_minus_lowpass(3, 1000);"
    },
    "fi.highpass_plus_lowpass_even": {
      "prefix": "fi",
      "name": "highpass_plus_lowpass_even",
      "full_name": "fi.highpass_plus_lowpass_even",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass_minus_lowpass_even_test = os.osc(440) : fi.highpass_minus_lowpass_even(4, 1000);"
    },
    "fi.highpass_minus_lowpass_odd": {
      "prefix": "fi",
      "name": "highpass_minus_lowpass_odd",
      "full_name": "fi.highpass_minus_lowpass_odd",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass_minus_lowpass_odd_test = os.osc(440) : fi.highpass_minus_lowpass_odd(3, 1000);"
    },
    "fi.lowpass3e": {
      "prefix": "fi",
      "name": "lowpass3e",
      "full_name": "fi.lowpass3e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Third-order Elliptic (Cauer) lowpass filter.",
      "param_docs": {
        "fc": "-3dB frequency in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlowpass3e_test = os.osc(440) : fi.lowpass3e(1000);"
    },
    "fi.lowpass6e": {
      "prefix": "fi",
      "name": "lowpass6e",
      "full_name": "fi.lowpass6e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sixth-order Elliptic/Cauer lowpass filter.",
      "param_docs": {
        "fc": "-3dB frequency in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlowpass6e_test = os.osc(440) : fi.lowpass6e(1000);"
    },
    "fi.highpass3e": {
      "prefix": "fi",
      "name": "highpass3e",
      "full_name": "fi.highpass3e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Third-order Elliptic (Cauer) highpass filter. Inversion of `lowpass3e` wrt unit circle in s plane (s <- 1/s).",
      "param_docs": {
        "fc": "-3dB frequency in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass3e_test = os.osc(440) : fi.highpass3e(1000);"
    },
    "fi.highpass6e": {
      "prefix": "fi",
      "name": "highpass6e",
      "full_name": "fi.highpass6e",
      "args": [
        "fc"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sixth-order Elliptic/Cauer highpass filter. Inversion of `lowpass3e` wrt unit circle in s plane (s <- 1/s).",
      "param_docs": {
        "fc": "-3dB frequency in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpass6e_test = os.osc(440) : fi.highpass6e(1000);"
    },
    "fi.bandpass": {
      "prefix": "fi",
      "name": "bandpass",
      "full_name": "fi.bandpass",
      "args": [
        "Nh",
        "fl",
        "fu"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Order 2*Nh Butterworth bandpass filter made using the transformation `s <- s + wc^2/s` on `lowpass(Nh)`, where `wc` is the desired bandpass center frequency.  The `lowpass(Nh)` cutoff `w1` is half the",
      "param_docs": {
        "Nh": "HALF the desired bandpass order (which is therefore even)",
        "fl": "lower -3dB frequency in Hz",
        "fu": "upper -3dB frequency in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nbandpass_test = os.osc(440) : fi.bandpass(2, 500, 1500);"
    },
    "fi.bandstop": {
      "prefix": "fi",
      "name": "bandstop",
      "full_name": "fi.bandstop",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nbandpass0_bandstop1_test = os.osc(440) : fi.bandpass0_bandstop1(0, 2, 500, 1500);"
    },
    "fi.bandpass6e": {
      "prefix": "fi",
      "name": "bandpass6e",
      "full_name": "fi.bandpass6e",
      "args": [
        "fl",
        "fu"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Order 12 elliptic bandpass filter analogous to `bandpass(6)`.",
      "param_docs": {},
      "example": ""
    },
    "fi.bandpass12e": {
      "prefix": "fi",
      "name": "bandpass12e",
      "full_name": "fi.bandpass12e",
      "args": [
        "fl",
        "fu"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Order 24 elliptic bandpass filter analogous to `bandpass(6)`.",
      "param_docs": {},
      "example": ""
    },
    "fi.pospass": {
      "prefix": "fi",
      "name": "pospass",
      "full_name": "fi.pospass",
      "args": [
        "N",
        "fc"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 2,
      "description": "Positive-Pass Filter (single-side-band filter).",
      "param_docs": {},
      "example": ""
    },
    "fi.lowshelf": {
      "prefix": "fi",
      "name": "lowshelf",
      "full_name": "fi.lowshelf",
      "args": [
        "N",
        "L0",
        "fx"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "First-order \"low shelf\" filter (gain boost|cut between dc and some frequency) `low_shelf` is a standard Faust function.",
      "param_docs": {
        "N": "filter order 1, 3, 5, ... (odd only, default should be 3, a constant numerical expression)",
        "L0": "desired level (dB) between dc and fx (boost `L0>0` or cut `L0<0`)",
        "fx": "-3dB frequency of lowpass band (`L0>0`) or upper band (`L0<0`)"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlowshelf_test = os.osc(440) : fi.lowshelf(3, 6, 500);"
    },
    "fi.low_shelf": {
      "prefix": "fi",
      "name": "low_shelf",
      "full_name": "fi.low_shelf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlow_shelf_test = os.osc(440) : fi.low_shelf(6, 500);"
    },
    "fi.low_shelf1_l": {
      "prefix": "fi",
      "name": "low_shelf1_l",
      "full_name": "fi.low_shelf1_l",
      "args": [
        "G0",
        "fx",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlow_shelf1_l_test = fi.low_shelf1_l(2, 500, os.osc(440));"
    },
    "fi.lowshelf_other_freq": {
      "prefix": "fi",
      "name": "lowshelf_other_freq",
      "full_name": "fi.lowshelf_other_freq",
      "args": [
        "N",
        "L0",
        "fx"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); lowshelf_other_freq_test = fi.lowshelf_other_freq(3, 6, 500);",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nlowshelf_other_freq_test = fi.lowshelf_other_freq(3, 6, 500);"
    },
    "fi.high_shelf": {
      "prefix": "fi",
      "name": "high_shelf",
      "full_name": "fi.high_shelf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhigh_shelf_test = os.osc(440) : fi.high_shelf(6, 2000);"
    },
    "fi.high_shelf1": {
      "prefix": "fi",
      "name": "high_shelf1",
      "full_name": "fi.high_shelf1",
      "args": [
        "Lpi",
        "fx",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhigh_shelf1_test = fi.high_shelf1(6, 2000, os.osc(440));"
    },
    "fi.high_shelf1_l": {
      "prefix": "fi",
      "name": "high_shelf1_l",
      "full_name": "fi.high_shelf1_l",
      "args": [
        "Gpi",
        "fx",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhigh_shelf1_l_test = fi.high_shelf1_l(2, 2000, os.osc(440));"
    },
    "fi.highshelf_other_freq": {
      "prefix": "fi",
      "name": "highshelf_other_freq",
      "full_name": "fi.highshelf_other_freq",
      "args": [
        "N",
        "Lpi",
        "fx"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); highshelf_other_freq_test = fi.highshelf_other_freq(3, 6, 2000);",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nhighshelf_other_freq_test = fi.highshelf_other_freq(3, 6, 2000);"
    },
    "fi.peak_eq": {
      "prefix": "fi",
      "name": "peak_eq",
      "full_name": "fi.peak_eq",
      "args": [
        "Lfx",
        "fx",
        "B"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Second order \"peaking equalizer\" section (gain boost or cut near some frequency) Also called a \"parametric equalizer\" section. `peak_eq` is a standard Faust function.",
      "param_docs": {
        "Lfx": "level (dB) at fx (boost Lfx>0 or cut Lfx<0)",
        "fx": "peak frequency (Hz)",
        "B": "bandwidth (B) of peak in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\npeak_eq_test = os.osc(440) : fi.peak_eq(6, 1000, 200);"
    },
    "fi.peak_eq_cq": {
      "prefix": "fi",
      "name": "peak_eq_cq",
      "full_name": "fi.peak_eq_cq",
      "args": [
        "Lfx",
        "fx",
        "Q"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Constant-Q second order peaking equalizer section.",
      "param_docs": {
        "Lfx": "level (dB) at fx",
        "fx": "boost or cut frequency (Hz)",
        "Q": "\"Quality factor\" = fx/B where B = bandwidth of peak in Hz"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\npeak_eq_cq_test = os.osc(440) : fi.peak_eq_cq(6, 1000, 4);"
    },
    "fi.peak_eq_rm": {
      "prefix": "fi",
      "name": "peak_eq_rm",
      "full_name": "fi.peak_eq_rm",
      "args": [
        "Lfx",
        "fx",
        "tanPiBT"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Regalia-Mitra second order peaking equalizer section.",
      "param_docs": {
        "Lfx": "level (dB) at fx",
        "fx": "boost or cut frequency (Hz)",
        "tanPiBT": "`tan(PI*B/SR)`, where B = -3dB bandwidth (Hz) when 10^(Lfx/20) = 0"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\npeak_eq_rm_test = os.osc(440) : fi.peak_eq_rm(6, 1000, ma.tan(ma.PI*200/ma.SR));"
    },
    "fi.spectral_tilt": {
      "prefix": "fi",
      "name": "spectral_tilt",
      "full_name": "fi.spectral_tilt",
      "args": [
        "N",
        "f0",
        "bw",
        "alpha"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Spectral tilt filter, providing an arbitrary spectral rolloff factor alpha in (-1,1), where -1 corresponds to one pole (-6 dB per octave), and",
      "param_docs": {
        "N": "desired integer filter order (fixed at compile time)",
        "f0": "lower frequency limit for desired roll-off band > 0",
        "bw": "bandwidth of desired roll-off band",
        "alpha": "slope of roll-off desired in nepers per neper,"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nspectral_tilt_test = os.osc(440) : fi.spectral_tilt(4, 200, 2000, -0.5);"
    },
    "fi.levelfilter": {
      "prefix": "fi",
      "name": "levelfilter",
      "full_name": "fi.levelfilter",
      "args": [
        "L",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Dynamic level lowpass filter. `levelfilter` is a standard Faust function.",
      "param_docs": {
        "L": "desired level (in dB) at Nyquist limit (SR/2), e.g., -60",
        "freq": "corner frequency (-3dB point) usually set to fundamental freq",
        "N": "Number of filters in series where L = L/N"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlevelfilter_test = fi.levelfilter(0.1, 200, os.osc(440));"
    },
    "fi.levelfilterN": {
      "prefix": "fi",
      "name": "levelfilterN",
      "full_name": "fi.levelfilterN",
      "args": [
        "N",
        "freq",
        "L"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Dynamic level lowpass filter.",
      "param_docs": {
        "N": "Number of filters in series where L = L/N, a constant numerical expression",
        "freq": "corner frequency (-3dB point) usually set to fundamental freq",
        "L": "desired level (in dB) at Nyquist limit (SR/2), e.g., -60"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlevelfilterN_test = os.osc(440) : fi.levelfilterN(3, 200, 0.1);"
    },
    "fi.O": {
      "prefix": "fi",
      "name": "O",
      "full_name": "fi.O",
      "args": [
        "O",
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Allpass-complementary filter banks based on Butterworth band-splitting. For Butterworth band-splits, the needed delay equalizer is easily found.",
      "param_docs": {
        "O": "order of filter used to split each frequency band into two, a constant numerical expression",
        "M": "number of band-slices per octave, a constant numerical expression",
        "ftop": "highest band-split crossover frequency (e.g., 20 kHz)",
        "N": "total number of bands (including dc and Nyquist), a constant numerical expression"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_filterbank_test = os.osc(440) : fi.mth_octave_filterbank(3, 2, 8000, 2);"
    },
    "fi.mth_octave_filterbank_alt": {
      "prefix": "fi",
      "name": "mth_octave_filterbank_alt",
      "full_name": "fi.mth_octave_filterbank_alt",
      "args": [
        "O",
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_filterbank_alt_test = os.osc(440) : fi.mth_octave_filterbank_alt(3, 2, 8000, 2);"
    },
    "fi.mth_octave_filterbank3": {
      "prefix": "fi",
      "name": "mth_octave_filterbank3",
      "full_name": "fi.mth_octave_filterbank3",
      "args": [
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_filterbank3_test = os.osc(440) : fi.mth_octave_filterbank3(2, 8000, 2);"
    },
    "fi.mth_octave_filterbank5": {
      "prefix": "fi",
      "name": "mth_octave_filterbank5",
      "full_name": "fi.mth_octave_filterbank5",
      "args": [
        "M",
        "ftop",
        "N"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_filterbank5_test = os.osc(440) : fi.mth_octave_filterbank5(2, 8000, 2);"
    },
    "fi.mth_octave_filterbank_default": {
      "prefix": "fi",
      "name": "mth_octave_filterbank_default",
      "full_name": "fi.mth_octave_filterbank_default",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "``` fi = library(\"filters.lib\"); os = library(\"oscillators.lib\");",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nmth_octave_filterbank_default_test = os.osc(440) : fi.mth_octave_filterbank_default(2, 8000, 2);"
    },
    "fi.filterbank": {
      "prefix": "fi",
      "name": "filterbank",
      "full_name": "fi.filterbank",
      "args": [
        "O",
        "freqs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Filter bank. `filterbank` is a standard Faust function.",
      "param_docs": {
        "O": "band-split filter order (odd integer required for filterbank[i], a constant numerical expression)",
        "freqs": "(fc1,fc2,...,fcNs) [in numerically ascending order], where"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfilterbank_test = os.osc(440) : fi.filterbank(3, (500, 2000));"
    },
    "fi.filterbanki": {
      "prefix": "fi",
      "name": "filterbanki",
      "full_name": "fi.filterbanki",
      "args": [
        "O",
        "freqs"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Inverted-dc filter bank.",
      "param_docs": {
        "O": "band-split filter order (odd integer required for `filterbank[i]`, a constant numerical expression)",
        "freqs": "(fc1,fc2,...,fcNs) [in numerically ascending order], where"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nfilterbanki_test = os.osc(440) : fi.filterbanki(3, (500, 2000));"
    },
    "fi.svf": {
      "prefix": "fi",
      "name": "svf",
      "full_name": "fi.svf",
      "args": [
        "T",
        "F",
        "Q",
        "G"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "An environment with `lp`, `bp`, `hp`, `notch`, `peak`, `ap`, `bell`, `ls`, `hs` SVF based filters. All filters have `freq` and `Q` parameters, the `bell`, `ls`, `hs` ones also have a `gain` third para",
      "param_docs": {
        "freq": "cut frequency",
        "Q": "quality factor"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsvf_lp_test = fi.svf.lp(1000, 0.707, os.osc(440));\nsvf_bp_test = fi.svf.bp(1000, 0.707, os.osc(440));\nsvf_hp_test = fi.svf.hp(1000, 0.707, os.osc(440));\nsvf_notch_test = fi.svf.notch(1000, 0.707, os.osc(440));\nsvf_peak_test = fi.svf.peak(1000, 0.707, os.osc(440));\nsvf_ap_test = fi.svf.ap(1000, 0.707, os.osc(440));\nsvf_bell_test = fi.svf.bell(1000, 0.707, 6, os.osc(440));\nsvf_ls_test = fi.svf.ls(500, 0.707, 6, os.osc(440));\nsvf_hs_test"
    },
    "fi.svf_morph": {
      "prefix": "fi",
      "name": "svf_morph",
      "full_name": "fi.svf_morph",
      "args": [
        "freq",
        "Q",
        "blend"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "An SVF-based filter that can smoothly morph between being lowpass, bandpass, and highpass.",
      "param_docs": {
        "freq": "cutoff frequency",
        "Q": "quality factor",
        "blend": "[0..2] continuous, where 0 is `lowpass`, 1 is `bandpass`, and 2 is `highpass`. For performance, the value is not clamped to [0..2]."
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsvf_morph_test = fi.svf_morph(1000, 0.707, 1, os.osc(440));"
    },
    "fi.svf_notch_morph": {
      "prefix": "fi",
      "name": "svf_notch_morph",
      "full_name": "fi.svf_notch_morph",
      "args": [
        "freq",
        "Q",
        "blend"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "An SVF-based notch-filter that can smoothly morph between being lowpass, notch, and highpass.",
      "param_docs": {
        "freq": "cutoff frequency",
        "Q": "quality factor",
        "blend": "[0..2] continuous, where 0 is `lowpass`, 1 is `notch`, and 2 is `highpass`. For performance, the value is not clamped to [0..2]."
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nsvf_notch_morph_test = fi.svf_notch_morph(1000, 0.707, 1, os.osc(440));"
    },
    "fi.SVFTPT": {
      "prefix": "fi",
      "name": "SVFTPT",
      "full_name": "fi.SVFTPT",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Topology-preserving transform implementation following Zavalishin's method.",
      "param_docs": {
        "CF": "cutoff in Hz",
        "Q": "resonance"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nSVFTPT_SVF_test = fi.SVFTPT.SVF(1000, 0.707, os.osc(440));\nSVFTPT_LP2_test = fi.SVFTPT.LP2(1000, 0.707, os.osc(440));\nSVFTPT_HP2_test = fi.SVFTPT.HP2(1000, 0.707, os.osc(440));\nSVFTPT_BP2_test = fi.SVFTPT.BP2(1000, 0.707, os.osc(440));\nSVFTPT_BP2Norm_test = fi.SVFTPT.BP2Norm(1000, 0.707, os.osc(440));\nSVFTPT_Notch2_test = fi.SVFTPT.Notch2(1000, 0.707, os.osc(440));\nSVFTPT_AP2_test = fi.SVFTPT.AP2(1000, 0.707, os.osc(440));\nSVFTPT_Peak"
    },
    "fi.dynamicSmoothing": {
      "prefix": "fi",
      "name": "dynamicSmoothing",
      "full_name": "fi.dynamicSmoothing",
      "args": [
        "sensitivity",
        "baseCF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Adaptive smoother based on Andy Simper's paper.",
      "param_docs": {
        "sensitivity": "sensitivity to changes in the input signal.",
        "baseCF": "cutoff frequency, in Hz, when there is no variation in the"
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ndynamicSmoothing_test = fi.dynamicSmoothing(0.5, 500, os.osc(440));"
    },
    "fi.oneEuro": {
      "prefix": "fi",
      "name": "oneEuro",
      "full_name": "fi.oneEuro",
      "args": [
        "derivativeCutoff",
        "beta",
        "minCutoff"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "The One Euro Filter (1\u20ac Filter) is an adaptive lowpass filter. This kind of filter is commonly used in object-tracking, not necessarily audio processing.",
      "param_docs": {
        "derivativeCutoff": "Used to filter the first derivative of the input. 1 Hz is a good default.",
        "beta": "\"Speed\" parameter where higher values reduce latency.",
        "minCutoff": "Minimum cutoff frequency in Hz. Lower values remove more jitter."
      },
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\noneEuro_test = os.osc(440) : fi.oneEuro(1, 0.5, 5);"
    },
    "fi.lowpassLR4": {
      "prefix": "fi",
      "name": "lowpassLR4",
      "full_name": "fi.lowpassLR4",
      "args": [
        "cf"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "4th-order Linkwitz-Riley lowpass.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nlowpassLR4_test = os.osc(440) : fi.lowpassLR4(1000);"
    },
    "fi.highpassLR4": {
      "prefix": "fi",
      "name": "highpassLR4",
      "full_name": "fi.highpassLR4",
      "args": [
        "cf"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "4th-order Linkwitz-Riley highpass.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nhighpassLR4_test = os.osc(440) : fi.highpassLR4(1000);"
    },
    "fi.crossover2LR4": {
      "prefix": "fi",
      "name": "crossover2LR4",
      "full_name": "fi.crossover2LR4",
      "args": [
        "cf"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Two-way 4th-order Linkwitz-Riley crossover.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ncrossover2LR4_test = os.osc(440) : fi.crossover2LR4(1000);"
    },
    "fi.crossover3LR4": {
      "prefix": "fi",
      "name": "crossover3LR4",
      "full_name": "fi.crossover3LR4",
      "args": [
        "cf1",
        "cf2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Three-way 4th-order Linkwitz-Riley crossover.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ncrossover3LR4_test = os.osc(440) : fi.crossover3LR4(500, 2000);"
    },
    "fi.crossover4LR4": {
      "prefix": "fi",
      "name": "crossover4LR4",
      "full_name": "fi.crossover4LR4",
      "args": [
        "cf1",
        "cf2",
        "cf3"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Four-way 4th-order Linkwitz-Riley crossover.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ncrossover4LR4_test = os.osc(440) : fi.crossover4LR4(300, 1000, 3000);"
    },
    "fi.crossover8LR4": {
      "prefix": "fi",
      "name": "crossover8LR4",
      "full_name": "fi.crossover8LR4",
      "args": [
        "cf1",
        "cf2",
        "cf3",
        "cf4",
        "cf5",
        "cf6",
        "cf7"
      ],
      "arg_count": 7,
      "inputs": 1,
      "outputs": 1,
      "description": "Eight-way 4th-order Linkwitz-Riley crossover.",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\ncrossover8LR4_test = os.osc(440) : fi.crossover8LR4(100, 200, 400, 800, 1600, 3200, 6400);"
    },
    "fi.itu_r_bs_1770_4_kfilter": {
      "prefix": "fi",
      "name": "itu_r_bs_1770_4_kfilter",
      "full_name": "fi.itu_r_bs_1770_4_kfilter",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "The prefilter from Recommendation ITU-R BS.1770-4 for loudness measurement. Also known as \"K-filter\". The recommendation defines biquad filter coefficients for a fixed sample rate of 48kHz (page",
      "param_docs": {},
      "example": "fi = library(\"filters.lib\");\nos = library(\"oscillators.lib\");\nitu_r_bs_1770_4_kfilter_test = os.osc(440) : fi.itu_r_bs_1770_4_kfilter;"
    },
    "fi.avg_rect": {
      "prefix": "fi",
      "name": "avg_rect",
      "full_name": "fi.avg_rect",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Moving average.",
      "param_docs": {},
      "example": ""
    },
    "fi.avg_tau": {
      "prefix": "fi",
      "name": "avg_tau",
      "full_name": "fi.avg_tau",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Averaging function based on a one-pole filter and the tau response time. Tau represents the effective length of the one-pole impulse response, that is, tau is the integral of the filter's impulse resp",
      "param_docs": {},
      "example": ""
    },
    "fi.avg_t60": {
      "prefix": "fi",
      "name": "avg_t60",
      "full_name": "fi.avg_t60",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Averaging function based on a one-pole filter and the t60 response time. This response is particularly useful when the system is required to reach the final value after about `period` seconds.",
      "param_docs": {},
      "example": ""
    },
    "fi.avg_t19": {
      "prefix": "fi",
      "name": "avg_t19",
      "full_name": "fi.avg_t19",
      "args": [
        "period"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Averaging function based on a one-pole filter and the t19 response time. This response is close to the moving-average algorithm as it roughly reaches the final value after `period` seconds and shows a",
      "param_docs": {},
      "example": ""
    },
    "fi.kalman": {
      "prefix": "fi",
      "name": "kalman",
      "full_name": "fi.kalman",
      "args": [
        "N",
        "M",
        "B",
        "R",
        "H",
        "Q",
        "F",
        "reset",
        "u",
        "z"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "The Kalman filter. It returns the state (a bus of size `N`). Note that the only compile-time constant arguments are `N` and `M`. Other arguments are capitalized because they're matrices, and it makes",
      "param_docs": {
        "N": "State size (constant int)",
        "M": "Measurement size (constant int)",
        "B": "Control input matrix (NxM)",
        "R": "Measurement noise covariance matrix (MxM)",
        "H": "Observation matrix (MxN)",
        "Q": "Process noise covariance matrix (NxN)",
        "F": "State transition matrix (NxN)",
        "reset": "Reset trigger. Whenever `reset>0`, the internal state `x` and covariance matrix `P` are reset.",
        "u": "Control input (Mx1)",
        "z": "Measurement signal (Mx1)"
      },
      "example": ""
    },
    "fi.svf.lp": {
      "prefix": "fi",
      "name": "svf.lp",
      "full_name": "fi.svf.lp",
      "args": [
        "f",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "svf lp filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.bp": {
      "prefix": "fi",
      "name": "svf.bp",
      "full_name": "fi.svf.bp",
      "args": [
        "f",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "svf bp filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.hp": {
      "prefix": "fi",
      "name": "svf.hp",
      "full_name": "fi.svf.hp",
      "args": [
        "f",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "svf hp filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.notch": {
      "prefix": "fi",
      "name": "svf.notch",
      "full_name": "fi.svf.notch",
      "args": [
        "f",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "svf notch filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.peak": {
      "prefix": "fi",
      "name": "svf.peak",
      "full_name": "fi.svf.peak",
      "args": [
        "f",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "svf peak filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.ap": {
      "prefix": "fi",
      "name": "svf.ap",
      "full_name": "fi.svf.ap",
      "args": [
        "f",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "svf ap filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.bell": {
      "prefix": "fi",
      "name": "svf.bell",
      "full_name": "fi.svf.bell",
      "args": [
        "f",
        "q",
        "g"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "svf bell filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.ls": {
      "prefix": "fi",
      "name": "svf.ls",
      "full_name": "fi.svf.ls",
      "args": [
        "f",
        "q",
        "g"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "svf ls filter",
      "param_docs": {},
      "example": ""
    },
    "fi.svf.hs": {
      "prefix": "fi",
      "name": "svf.hs",
      "full_name": "fi.svf.hs",
      "args": [
        "f",
        "q",
        "g"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "svf hs filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.SVF": {
      "prefix": "fi",
      "name": "SVFTPT.SVF",
      "full_name": "fi.SVFTPT.SVF",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT SVF filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.f": {
      "prefix": "fi",
      "name": "SVFTPT.f",
      "full_name": "fi.SVFTPT.f",
      "args": [
        "s0",
        "s1"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT f filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.LP2": {
      "prefix": "fi",
      "name": "SVFTPT.LP2",
      "full_name": "fi.SVFTPT.LP2",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT LP2 filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.HP2": {
      "prefix": "fi",
      "name": "SVFTPT.HP2",
      "full_name": "fi.SVFTPT.HP2",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT HP2 filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.BP2": {
      "prefix": "fi",
      "name": "SVFTPT.BP2",
      "full_name": "fi.SVFTPT.BP2",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT BP2 filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.BP2Norm": {
      "prefix": "fi",
      "name": "SVFTPT.BP2Norm",
      "full_name": "fi.SVFTPT.BP2Norm",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT BP2Norm filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.Notch2": {
      "prefix": "fi",
      "name": "SVFTPT.Notch2",
      "full_name": "fi.SVFTPT.Notch2",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT Notch2 filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.AP2": {
      "prefix": "fi",
      "name": "SVFTPT.AP2",
      "full_name": "fi.SVFTPT.AP2",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT AP2 filter",
      "param_docs": {},
      "example": ""
    },
    "fi.SVFTPT.Peaking2": {
      "prefix": "fi",
      "name": "SVFTPT.Peaking2",
      "full_name": "fi.SVFTPT.Peaking2",
      "args": [
        "CF",
        "Q",
        "x"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "SVFTPT Peaking2 filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.predictState": {
      "prefix": "fi",
      "name": "kalmanEnv.predictState",
      "full_name": "fi.kalmanEnv.predictState",
      "args": [
        "N",
        "M",
        "F",
        "B"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv predictState filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.predictCovariance": {
      "prefix": "fi",
      "name": "kalmanEnv.predictCovariance",
      "full_name": "fi.kalmanEnv.predictCovariance",
      "args": [
        "N",
        "F",
        "Q",
        "P"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv predictCovariance filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.kalmanGain": {
      "prefix": "fi",
      "name": "kalmanEnv.kalmanGain",
      "full_name": "fi.kalmanEnv.kalmanGain",
      "args": [
        "N",
        "M",
        "H",
        "R"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv kalmanGain filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.updateState": {
      "prefix": "fi",
      "name": "kalmanEnv.updateState",
      "full_name": "fi.kalmanEnv.updateState",
      "args": [
        "N",
        "M",
        "H"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv updateState filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.mySwap": {
      "prefix": "fi",
      "name": "kalmanEnv.mySwap",
      "full_name": "fi.kalmanEnv.mySwap",
      "args": [
        "N",
        "M"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv mySwap filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.K_mul_residual": {
      "prefix": "fi",
      "name": "kalmanEnv.K_mul_residual",
      "full_name": "fi.kalmanEnv.K_mul_residual",
      "args": [
        "N",
        "M",
        "H"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv K_mul_residual filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.updateCovariance": {
      "prefix": "fi",
      "name": "kalmanEnv.updateCovariance",
      "full_name": "fi.kalmanEnv.updateCovariance",
      "args": [
        "N",
        "M",
        "H",
        "K",
        "P_pred"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv updateCovariance filter",
      "param_docs": {},
      "example": ""
    },
    "fi.kalmanEnv.kalmanFilter": {
      "prefix": "fi",
      "name": "kalmanEnv.kalmanFilter",
      "full_name": "fi.kalmanEnv.kalmanFilter",
      "args": [
        "N",
        "M",
        "B",
        "R",
        "H",
        "Q",
        "F",
        "reset"
      ],
      "arg_count": 8,
      "inputs": 1,
      "outputs": 1,
      "description": "kalmanEnv kalmanFilter filter",
      "param_docs": {},
      "example": ""
    },
    "ho.encoder": {
      "prefix": "ho",
      "name": "encoder",
      "full_name": "ho.encoder",
      "args": [
        "N",
        "x",
        "a"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Ambisonic encoder. Encodes a signal in the circular harmonics domain depending on an order of decomposition and an angle.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "x": "the signal",
        "a": "the angle"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nencoder_test = ho.encoder(1, os.osc(440), 0.0);"
    },
    "ho.rEncoder": {
      "prefix": "ho",
      "name": "rEncoder",
      "full_name": "ho.rEncoder",
      "args": [
        "N",
        "sp",
        "a",
        "it"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 2,
      "description": "Ambisonic encoder in 2D including source rotation. A mono signal is encoded at a certain ambisonic order with two possible modes: either rotation with an angular speed, or static with a fixed angle (w",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "sp": "the azimuth speed expressed as angular speed (2PI/sec), positive or negative",
        "a": "the fixed azimuth when the rotation stops (sp = 0) in radians",
        "it": "interpolation time (in milliseconds) between the rotation and the fixed modes"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nrEncoder_test = os.osc(440) : ho.rEncoder(1, 0.5, 0.0, 0.05);"
    },
    "ho.stereoEncoder": {
      "prefix": "ho",
      "name": "stereoEncoder",
      "full_name": "ho.stereoEncoder",
      "args": [
        "N",
        "a"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Encoding of a stereo pair of channels with symetric angles (a/2, -a/2).",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "a": "opening angle in radians, left channel at a/2 angle, right channel at -a/2 angle"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nstereoEncoder_test = os.osc(440), os.osc(660) : ho.stereoEncoder(1, 1.0);"
    },
    "ho.multiEncoder": {
      "prefix": "ho",
      "name": "multiEncoder",
      "full_name": "ho.multiEncoder",
      "args": [
        "N",
        "lspeed",
        "langle",
        "it"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Encoding of a set of P signals distributed on the unit circle according to a list of P speeds and P angles.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "lspeed": "a list of P speeds in turns by second (one speed per input signal, positive or negative)",
        "langle": "a list of P angles in radians on the unit circle to localize the sources (one angle per input signal)",
        "it": "interpolation time (in milliseconds) between the rotation and the fixed modes."
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nmultiEncoder_test = os.osc(440), os.osc(660) : ho.multiEncoder(1, (0.0, 0.0), (0.0, 1.57), 0.05);"
    },
    "ho.decoder": {
      "prefix": "ho",
      "name": "decoder",
      "full_name": "ho.decoder",
      "args": [
        "N",
        "P"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Decodes an ambisonics sound field for a circular array of loudspeakers.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "P": "the number of speakers (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\ndecoder_test = ambi : ho.decoder(1, 4);"
    },
    "ho.decoderStereo": {
      "prefix": "ho",
      "name": "decoderStereo",
      "full_name": "ho.decoderStereo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Decodes an ambisonic sound field for stereophonic configuration. An \"home made\" ambisonic decoder for stereophonic restitution (30\u00b0 - 330\u00b0): Sound field lose energy around 180\u00b0. You should",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\ndecoderStereo_test = ambi : ho.decoderStereo(1);"
    },
    "ho.iBasicDecoder": {
      "prefix": "ho",
      "name": "iBasicDecoder",
      "full_name": "ho.iBasicDecoder",
      "args": [
        "N",
        "la",
        "direct",
        "shift"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "The irregular basic decoder is a simple decoder that projects the incoming ambisonic situation to the loudspeaker situation (P loudspeakers) whatever it is, without compensation. When there is a stron",
      "param_docs": {
        "N": "the ambisonic order (there are 2*N+1 inputs to this function)",
        "la": "the list of P angles in degrees, for instance (0, 85, 182, 263) for four loudspeakers",
        "direct": "1 for direct mode, -1 for the indirect mode (changes the rotation direction)",
        "shift": "angular shift in degrees to easily adjust angles"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\niBasicDecoder_test = ambi : ho.iBasicDecoder(1, (0, 120, 240), 1, 0);"
    },
    "ho.circularScaledVBAP": {
      "prefix": "ho",
      "name": "circularScaledVBAP",
      "full_name": "ho.circularScaledVBAP",
      "args": [
        "l",
        "t"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 2,
      "description": "The function provides a circular scaled VBAP with all loudspeakers and the virtual source on the unit-circle.",
      "param_docs": {
        "l": "the list of angles of the loudspeakers in degrees, for instance (0, 85, 182, 263) for four loudspeakers",
        "t": "the current angle of the virtual source in degrees"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\ncircularScaledVBAP_test = os.osc(440) : ho.circularScaledVBAP((0, 120, 240), 60);"
    },
    "ho.imlsDecoder": {
      "prefix": "ho",
      "name": "imlsDecoder",
      "full_name": "ho.imlsDecoder",
      "args": [
        "N",
        "la",
        "direct",
        "shift"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Irregular decoder in 2D for an irregular configuration of P loudspeakers using 2D VBAP for compensation.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "la": "the list of P angles in degrees, for instance (0, 85, 182, 263) for four loudspeakers",
        "direct": "1 for direct mode, -1 for the indirect mode (changes the rotation direction)",
        "shift": "angular shift in degrees to easily adjust angles"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\nimlsDecoder_test = ambi : ho.imlsDecoder(1, (0, 90, 180, 270), 1, 0);"
    },
    "ho.iDecoder": {
      "prefix": "ho",
      "name": "iDecoder",
      "full_name": "ho.iDecoder",
      "args": [
        "N",
        "la",
        "direct",
        "st",
        "g"
      ],
      "arg_count": 5,
      "inputs": 2,
      "outputs": 2,
      "description": "General decoder in 2D enabling an irregular multi-loudspeaker configuration and to switch between multi-channel and stereo.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "la": "the list of angles in degrees",
        "direct": "1 for direct mode, -1 for the indirect mode (changes the rotation direction)",
        "shift": "angular shift in degrees to easily adjust angles",
        "st": "1 for stereo, 0 for multi-loudspeaker configuration. When 1, stereo sounds goes through the first two channels",
        "g": "gain between 0 and 1"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\niDecoder_test = (ambi, 0.0) : ho.iDecoder(1, (0, 120, 240), 1, 0, 0.8);"
    },
    "ho.optimBasic": {
      "prefix": "ho",
      "name": "optimBasic",
      "full_name": "ho.optimBasic",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The basic optimization has no effect and should be used for a perfect circle of loudspeakers with one listener at the perfect center loudspeakers array.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\noptimBasic_test = ambi : ho.optimBasic(1);"
    },
    "ho.optimMaxRe": {
      "prefix": "ho",
      "name": "optimMaxRe",
      "full_name": "ho.optimMaxRe",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The maxRe optimization optimizes energy vector. It should be used for an auditory confined in the center of the loudspeakers array.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\noptimMaxRe_test = ambi : ho.optimMaxRe(1);"
    },
    "ho.optimInPhase": {
      "prefix": "ho",
      "name": "optimInPhase",
      "full_name": "ho.optimInPhase",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The inPhase optimization optimizes energy vector and put all loudspeakers signals in phase. It should be used for an auditory.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\noptimInPhase_test = ambi : ho.optimInPhase(1);"
    },
    "ho.optim": {
      "prefix": "ho",
      "name": "optim",
      "full_name": "ho.optim",
      "args": [
        "N",
        "ot"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Ambisonic optimizer including the three elementary optimizers: `(ho).optimBasic`, `(ho).optimMaxRe` and `(ho.)optimInPhase`.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "ot": "optimization type (0 for `optimBasic`, 1 for `optimMaxRe`, 2 for `optimInPhase`)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\noptim_test = ambi : ho.optim(1, 1);"
    },
    "ho.wider": {
      "prefix": "ho",
      "name": "wider",
      "full_name": "ho.wider",
      "args": [
        "N",
        "w"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Can be used to wide the diffusion of a localized sound. The order depending signals are weighted and appear in a logarithmic way to have linear changes.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "w": "the width value between 0 - 1"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\nwider_test = ambi : ho.wider(1, 0.5);"
    },
    "ho.mirror": {
      "prefix": "ho",
      "name": "mirror",
      "full_name": "ho.mirror",
      "args": [
        "N",
        "fa"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Mirroring effect on the sound field.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "fa": "mirroring type (1 = original sound field, 0 = original+mirrored sound field, -1 = mirrored sound field)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi = ho.encoder(1, os.osc(440), 0.0);\nmirror_test = ambi : ho.mirror(1, -1);"
    },
    "ho.map": {
      "prefix": "ho",
      "name": "map",
      "full_name": "ho.map",
      "args": [
        "N",
        "x",
        "r",
        "a"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "It simulates the distance of the source by applying a gain on the signal and a wider processing on the soundfield.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "x": "the signal",
        "r": "the radius",
        "a": "the angle in radian"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nmap_test = ho.map(1, os.osc(440), 0.5, 0.0);"
    },
    "ho.rotate": {
      "prefix": "ho",
      "name": "rotate",
      "full_name": "ho.rotate",
      "args": [
        "N",
        "a"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Rotates the sound field.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "a": "the angle in radian"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nrotate_test = ho.encoder(1, os.osc(440), 0.0) : ho.rotate(1, 0.78);"
    },
    "ho.scope": {
      "prefix": "ho",
      "name": "scope",
      "full_name": "ho.scope",
      "args": [
        "N",
        "rt"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Produces an XY pair of signals representing the ambisonic sound field.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "rt": "refreshment time in milliseconds"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nscope_test = ho.encoder(1, os.osc(440), 0.0) : ho.scope(1, 0.1);"
    },
    "ho.fxDecorrelation": {
      "prefix": "ho",
      "name": "fxDecorrelation",
      "full_name": "ho.fxDecorrelation",
      "args": [
        "N",
        "d",
        "wf",
        "fa",
        "fd",
        "tf"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ambisonic decorrelation in fx mode.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "d": "the maximum delay applied (in samples)",
        "wf": "window frequency (in Hz) for the overlapped delay",
        "fa": "decorrelation factor (between 0 and 1)",
        "fd": "feedback / level of reinjection (between 0 and 1)",
        "tf": "type of function of delay distribution (integer, between 0 and 21)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nfxDecorrelation_test = ho.encoder(1, os.osc(440), 0.0) : ho.fxDecorrelation(1, 64, 5, 0.5, 0.2, 0);"
    },
    "ho.synDecorrelation": {
      "prefix": "ho",
      "name": "synDecorrelation",
      "full_name": "ho.synDecorrelation",
      "args": [
        "N",
        "d",
        "wf",
        "fa",
        "fd",
        "tf"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ambisonic decorrelation in syn mode.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "d": "the maximum delay applied (in samples)",
        "wf": "window frequency (in Hz) for the overlapped delay",
        "fa": "decorrelation factor (between 0 and 1)",
        "fd": "feedback / level of reinjection (between 0 and 1)",
        "tf": "type of function of delay distribution (integer, between 0 and 21)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nsynDecorrelation_test = os.osc(440) : ho.synDecorrelation(1, 64, 5, 0.5, 0.2, 0);"
    },
    "ho.fxRingMod": {
      "prefix": "ho",
      "name": "fxRingMod",
      "full_name": "ho.fxRingMod",
      "args": [
        "N",
        "f0",
        "fa",
        "tf"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ring modulation in syn mode.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "f0": "the maximum delay applied (in samples)",
        "fa": "decorrelation factor (between 0 and 1)",
        "tf": "type of function of delay distribution (integer, between 0 and 21)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nfxRingMod_test = ho.encoder(1, os.osc(440), 0.0) : ho.fxRingMod(1, 200, 0.5, 0);"
    },
    "ho.synRingMod": {
      "prefix": "ho",
      "name": "synRingMod",
      "full_name": "ho.synRingMod",
      "args": [
        "N",
        "f0",
        "fa",
        "tf"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Spatial ring modulation in syn mode.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "f0": "the maximum delay applied (in samples)",
        "fa": "decorrelation factor (between 0 and 1)",
        "tf": "type of function of delay distribution (integer, between 0 and 21)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nsynRingMod_test = os.osc(440) : ho.synRingMod(1, 200, 0.5, 0);"
    },
    "ho.encoder3D": {
      "prefix": "ho",
      "name": "encoder3D",
      "full_name": "ho.encoder3D",
      "args": [
        "N",
        "x",
        "a",
        "e"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Ambisonic encoder. Encodes a signal in the circular harmonics domain depending on an order of decomposition, an angle and an elevation.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "x": "the signal",
        "a": "the angle",
        "e": "the elevation"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nencoder3D_test = ho.encoder3D(1, os.osc(440), 0.0, 0.0);"
    },
    "ho.rEncoder3D": {
      "prefix": "ho",
      "name": "rEncoder3D",
      "full_name": "ho.rEncoder3D",
      "args": [
        "N",
        "azsp",
        "elsp",
        "az",
        "el",
        "it"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 2,
      "description": "Ambisonic encoder in 3D including source rotation. A mono signal is encoded at at certain ambisonic order with two possible modes: either rotation with 2 angular speeds (azimuth and elevation), or sta",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "azsp": "the azimuth speed expressed as angular speed (2PI/sec), positive or negative",
        "elsp": "the elevation speed expressed as angular speed (2PI/sec), positive or negative",
        "az": "the fixed azimuth when the azimuth rotation stops (azsp = 0) in radians",
        "el": "the fixed elevation when the elevation rotation stops (elsp = 0) in radians",
        "it": "interpolation time (in milliseconds) between the rotation and the fixed modes"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nrEncoder3D_test = os.osc(440) : ho.rEncoder3D(1, 0.5, 0.3, 0.0, 0.0, 0.05);"
    },
    "ho.optimBasic3D": {
      "prefix": "ho",
      "name": "optimBasic3D",
      "full_name": "ho.optimBasic3D",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The basic optimization has no effect and should be used for a perfect sphere of loudspeakers with one listener at the perfect center loudspeakers array.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi3D = ho.encoder3D(1, os.osc(440), 0.0, 0.0);\noptimBasic3D_test = ambi3D : ho.optimBasic3D(1);"
    },
    "ho.optimMaxRe3D": {
      "prefix": "ho",
      "name": "optimMaxRe3D",
      "full_name": "ho.optimMaxRe3D",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The maxRe optimization optimize energy vector. It should be used for an auditory confined in the center of the loudspeakers array.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi3D = ho.encoder3D(1, os.osc(440), 0.0, 0.0);\noptimMaxRe3D_test = ambi3D : ho.optimMaxRe3D(1);"
    },
    "ho.optimInPhase3D": {
      "prefix": "ho",
      "name": "optimInPhase3D",
      "full_name": "ho.optimInPhase3D",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The inPhase Optimization optimizes energy vector and put all loudspeakers signals in phase. It should be used for an auditory.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi3D = ho.encoder3D(1, os.osc(440), 0.0, 0.0);\noptimInPhase3D_test = ambi3D : ho.optimInPhase3D(1);"
    },
    "ho.optim3D": {
      "prefix": "ho",
      "name": "optim3D",
      "full_name": "ho.optim3D",
      "args": [
        "N",
        "ot"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Ambisonic optimizer including the three elementary optimizers: `(ho).optimBasic3D`, `(ho).optimMaxRe3D` and `(ho.)optimInPhase3D`.",
      "param_docs": {
        "N": "the ambisonic order (constant numerical expression)",
        "ot": "optimization type (0 for optimBasic, 1 for optimMaxRe, 2 for optimInPhase)"
      },
      "example": "ho = library(\"hoa.lib\");\nos = library(\"oscillators.lib\");\nambi3D = ho.encoder3D(1, os.osc(440), 0.0, 0.0);\noptim3D_test = ambi3D : ho.optim3D(1, 2);"
    },
    "it.interpolate_linear": {
      "prefix": "it",
      "name": "interpolate_linear",
      "full_name": "it.interpolate_linear",
      "args": [
        "dv",
        "v0",
        "v1"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolation between 2 values.",
      "param_docs": {
        "dv": "in the fractional value in [0..1] range",
        "v0": "is the first value",
        "v1": "is the second value"
      },
      "example": "it = library(\"interpolators.lib\");\ninterpolate_linear_test = it.interpolate_linear(0.5, 0.0, 1.0);"
    },
    "it.interpolate_cosine": {
      "prefix": "it",
      "name": "interpolate_cosine",
      "full_name": "it.interpolate_cosine",
      "args": [
        "dv",
        "v0",
        "v1"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine interpolation between 2 values.",
      "param_docs": {
        "dv": "in the fractional value in [0..1] range",
        "v0": "is the first value",
        "v1": "is the second value"
      },
      "example": "it = library(\"interpolators.lib\");\ninterpolate_cosine_test = it.interpolate_cosine(0.5, 0.0, 1.0);"
    },
    "it.interpolate_cubic": {
      "prefix": "it",
      "name": "interpolate_cubic",
      "full_name": "it.interpolate_cubic",
      "args": [
        "dv",
        "v0",
        "v1",
        "v2",
        "v3"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Cubic interpolation between 4 values.",
      "param_docs": {
        "dv": "in the fractional value in [0..1] range",
        "v0": "is the first value",
        "v1": "is the second value",
        "v2": "is the third value",
        "v3": "is the fourth value"
      },
      "example": "it = library(\"interpolators.lib\");\ninterpolate_cubic_test = it.interpolate_cubic(0.5, -1.0, 2.0, 1.0, 4.0);"
    },
    "it.interpolator_two_points": {
      "prefix": "it",
      "name": "interpolator_two_points",
      "full_name": "it.interpolator_two_points",
      "args": [
        "gen",
        "idv",
        "interpolate_two_points"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic interpolator on two points (current and next index), assuming an increasing index.",
      "param_docs": {
        "gen": "a circuit with an 'idv' reader input that produces N outputs",
        "idv": "a fractional read index expressed as a float value, or a (int,frac) pair",
        "interpolate_two_points": "a two points interpolation function"
      },
      "example": "it = library(\"interpolators.lib\");\nma = library(\"maths.lib\");\ninterpolator_two_points_test = it.interpolator_two_points(gen, idv, it.interpolate_linear)\nwith {\ngen(idx) = waveform {0.0, 1.0, 4.0, 9.0, 16.0}, int(ma.modulo(idx, 5)) : rdtable;\nstep = 0.25;\nidxFloat = ma.modulo((+(step)~_) - step, 4.0);\nidv = it.make_idv(idxFloat);\n};"
    },
    "it.interpolator_linear": {
      "prefix": "it",
      "name": "interpolator_linear",
      "full_name": "it.interpolator_linear",
      "args": [
        "gen",
        "idv"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolator for a 'gen' circuit triggered by an 'idv' input to generate values.",
      "param_docs": {
        "gen": "a circuit with an 'idv' reader input that produces N outputs",
        "idv": "a fractional read index expressed as a float value, or a (int,frac) pair"
      },
      "example": "it = library(\"interpolators.lib\");\nma = library(\"maths.lib\");\ninterpolator_linear_test = it.interpolator_linear(gen, idv)\nwith {\ngen(idx) = waveform {0.0, 1.0, 4.0, 9.0, 16.0}, int(ma.modulo(idx, 5)) : rdtable;\nstep = 0.25;\nidxFloat = ma.modulo((+(step)~_) - step, 4.0);\nidv = it.make_idv(idxFloat);\n};"
    },
    "it.interpolator_cosine": {
      "prefix": "it",
      "name": "interpolator_cosine",
      "full_name": "it.interpolator_cosine",
      "args": [
        "gen",
        "idv"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine interpolator for a 'gen' circuit triggered by an 'idv' input to generate values.",
      "param_docs": {
        "gen": "a circuit with an 'idv' reader input that produces N outputs",
        "idv": "a fractional read index expressed as a float value, or a (int,frac) pair"
      },
      "example": "it = library(\"interpolators.lib\");\nma = library(\"maths.lib\");\ninterpolator_cosine_test = it.interpolator_cosine(gen, idv)\nwith {\ngen(idx) = waveform {0.0, 1.0, 4.0, 9.0, 16.0}, int(ma.modulo(idx, 5)) : rdtable;\nstep = 0.25;\nidxFloat = ma.modulo((+(step)~_) - step, 4.0);\nidv = it.make_idv(idxFloat);\n};"
    },
    "it.interpolator_four_points": {
      "prefix": "it",
      "name": "interpolator_four_points",
      "full_name": "it.interpolator_four_points",
      "args": [
        "gen",
        "idv",
        "interpolate_four_points"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic interpolator on interpolator_four_points points (previous, current and two next indexes), assuming an increasing index.",
      "param_docs": {
        "gen": "a circuit with an 'idv' reader input that produces N outputs",
        "idv": "a fractional read index expressed as a float value, or a (int,frac) pair",
        "interpolate_four_points": "a four points interpolation function"
      },
      "example": "it = library(\"interpolators.lib\");\nma = library(\"maths.lib\");\ninterpolator_four_points_test = it.interpolator_four_points(gen, idv, it.interpolate_cubic)\nwith {\ngen(idx) = waveform {-1.0, 2.0, 1.0, 4.0, 7.0, 3.0}, int(ma.modulo(idx, 6)) : rdtable;\nstep = 0.25;\nidxFloat = ma.modulo((+(step)~_) - step, 5.0);\nidv = it.make_idv(idxFloat);\n};"
    },
    "it.interpolator_cubic": {
      "prefix": "it",
      "name": "interpolator_cubic",
      "full_name": "it.interpolator_cubic",
      "args": [
        "gen",
        "idv"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cubic interpolator for a 'gen' circuit triggered by an 'idv' input to generate values.",
      "param_docs": {
        "gen": "a circuit with an 'idv' reader input that produces N outputs",
        "idv": "a fractional read index expressed as a float value, or a (int,frac) pair"
      },
      "example": "it = library(\"interpolators.lib\");\nma = library(\"maths.lib\");\ninterpolator_cubic_test = it.interpolator_cubic(gen, idv)\nwith {\ngen(idx) = waveform {-1.0, 2.0, 1.0, 4.0, 7.0, 3.0}, int(ma.modulo(idx, 6)) : rdtable;\nstep = 0.25;\nidxFloat = ma.modulo((+(step)~_) - step, 5.0);\nidv = it.make_idv(idxFloat);\n};"
    },
    "it.interpolator_select": {
      "prefix": "it",
      "name": "interpolator_select",
      "full_name": "it.interpolator_select",
      "args": [
        "gen",
        "idv",
        "sel"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic configurable interpolator (with selector between in [0..3]). The value 3 is used for no interpolation.",
      "param_docs": {
        "gen": "a circuit with an 'idv' reader input that produces N outputs",
        "idv": "a fractional read index expressed as a float value, or a (int,frac) pair",
        "sel": "an interpolation algorithm selector in [0..3] (0 = linear, 1 = cosine, 2 = cubic, 3 = nointerp)"
      },
      "example": "it = library(\"interpolators.lib\");\nma = library(\"maths.lib\");\ninterpolator_select_test = it.interpolator_select(gen, idv, 2)\nwith {\ngen(idx) = waveform {-1.0, 2.0, 1.0, 4.0, 7.0, 3.0}, int(ma.modulo(idx, 6)) : rdtable;\nstep = 0.25;\nidxFloat = ma.modulo((+(step)~_) - step, 5.0);\nidv = it.make_idv(idxFloat);\n};"
    },
    "it.lerp": {
      "prefix": "it",
      "name": "lerp",
      "full_name": "it.lerp",
      "args": [
        "x0",
        "x1",
        "y0",
        "y1",
        "x"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear interpolation between two points.",
      "param_docs": {
        "x0": "x-coordinate origin",
        "x1": "x-coordinate destination",
        "y0": "y-coordinate origin",
        "y1": "y-coordinate destination",
        "x": "x-coordinate input"
      },
      "example": "it = library(\"interpolators.lib\");\nlerp_test = it.lerp(0.0, 10.0, -5.0, 5.0, 2.5);"
    },
    "it.piecewise": {
      "prefix": "it",
      "name": "piecewise",
      "full_name": "it.piecewise",
      "args": [
        "xList",
        "yList",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear piecewise interpolation between N points.",
      "param_docs": {
        "xList": "x-coordinates list",
        "yList": "y-coordinates list",
        "x": "x-coordinate input"
      },
      "example": "it = library(\"interpolators.lib\");\npiecewise_test = it.piecewise((-5, -2, 0, 3), (1, 0, 4, -1), os.osc(0.1));"
    },
    "it.lagrangeCoeffs": {
      "prefix": "it",
      "name": "lagrangeCoeffs",
      "full_name": "it.lagrangeCoeffs",
      "args": [
        "N",
        "xCoordsList",
        "x"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "This is a function to generate N + 1 coefficients for an Nth-order Lagrange basis polynomial with arbitrary spacing of the points.",
      "param_docs": {
        "N": "order of the interpolation filter, known at compile-time",
        "xCoordsList": "a list of N + 1 elements determining the x-axis coordinates of N + 1 values, known at compile-time",
        "x": "a fractional position on the x-axis to obtain the interpolated y-value"
      },
      "example": "it = library(\"interpolators.lib\");\nlagrangeCoeffs_test = it.lagrangeCoeffs(2, (0.0, 0.5, 1.0), 0.25);"
    },
    "it.lagrangeInterpolation": {
      "prefix": "it",
      "name": "lagrangeInterpolation",
      "full_name": "it.lagrangeInterpolation",
      "args": [
        "N",
        "xCoordsList"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Nth-order Lagrange interpolator to interpolate between a set of arbitrarily spaced N + 1 points.",
      "param_docs": {
        "N": "order of the interpolator, known at compile-time",
        "xCoordsList": "a list of N + 1 elements determining the x-axis spacing of the points, known at compile-time",
        "x": "an x-axis position to interpolate between the y-values",
        "yCoords": "N + 1 elements determining the values of the interpolation points"
      },
      "example": "it = library(\"interpolators.lib\");\nlagrangeInterpolation_test = (lagrange_x, lagrange_y0, lagrange_y1, lagrange_y2, lagrange_y3) : it.lagrangeInterpolation(3, (0, 1, 2, 3))\nwith {\nlagrange_x = 1.5;\nlagrange_y0 = 2.0;\nlagrange_y1 = 5.0;\nlagrange_y2 = -1.0;\nlagrange_y3 = 3.0;\n};"
    },
    "it.frdtable": {
      "prefix": "it",
      "name": "frdtable",
      "full_name": "it.frdtable",
      "args": [
        "N",
        "S",
        "init",
        "idx"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Look-up circular table with Nth-order Lagrange interpolation for fractional indexes. The index is wrapped-around and the table is cycles for an index span of size S, which is the table size in samples",
      "param_docs": {
        "N": "Lagrange interpolation order, known at compile-time",
        "S": "table size in samples, known at compile-time",
        "init": "the initial table content, known at compile-time",
        "idx": "fractional index wrapped-around 0 and S"
      },
      "example": "it = library(\"interpolators.lib\");\nos = library(\"oscillators.lib\");\nfrdtable_test = it.frdtable(3, 16, os.sinwaveform(16), os.phasor(16, 200));"
    },
    "it.frwtable": {
      "prefix": "it",
      "name": "frwtable",
      "full_name": "it.frwtable",
      "args": [
        "N",
        "S",
        "init",
        "w_idx",
        "x",
        "r_idx"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Look-up updatable circular table with Nth-order Lagrange interpolation for fractional indexes. The index is wrapped-around and the table is circular indexes ranging from 0 to S, which is the table siz",
      "param_docs": {
        "N": "Lagrange interpolation order, known at compile-time",
        "S": "table size in samples, known at compile-time",
        "init": "the initial table content, known at compile-time",
        "w_idx": "it should be an INT between 0 and S - 1",
        "x": "input signal written on the w_idx positions",
        "r_idx": "fractional index wrapped-around 0 and S"
      },
      "example": "it = library(\"interpolators.lib\");\nos = library(\"oscillators.lib\");\nba = library(\"basics.lib\");\nfrwtable_test = it.frwtable(3, 16, os.sinwaveform(16), ba.period(16), os.osc(220), os.phasor(16, 150));"
    },
    "it.remap": {
      "prefix": "it",
      "name": "remap",
      "full_name": "it.remap",
      "args": [
        "from1",
        "from2",
        "to1",
        "to2"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Linearly map from an input domain to an output range.",
      "param_docs": {
        "from1": "the domain's lower bound.",
        "from2": "the domain's upper bound.",
        "to1": "the range's lower bound.",
        "to2": "the range's upper bound."
      },
      "example": "it = library(\"interpolators.lib\");\nos = library(\"oscillators.lib\");\nremap_test = it.remap(-1.0, 1.0, 100.0, 1000.0, os.osc(0.5));"
    },
    "la.determinant": {
      "prefix": "la",
      "name": "determinant",
      "full_name": "la.determinant",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Calculates the determinant of a bus that represents an `NxN` matrix.",
      "param_docs": {
        "N": "the size of each axis of the matrix."
      },
      "example": "la = library(\"linearalgebra.lib\");\ndeterminant_test = (1, 2, 3, 4) : la.determinant(2);"
    },
    "la.minor": {
      "prefix": "la",
      "name": "minor",
      "full_name": "la.minor",
      "args": [
        "N",
        "ROW",
        "COL"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "An utility for finding the matrix minor when inverting a matrix. It returns the determinant of the submatrix formed by deleting the row at index `ROW` and column at index `COL`.",
      "param_docs": {
        "N": "the size of each axis of the matrix.",
        "ROW": "the selected position on 0th dimension of the matrix (`0 <= ROW < N`)",
        "COL": "the selected position on the 1st dimension of the matrix (`0 <= COL < N`)"
      },
      "example": "la = library(\"linearalgebra.lib\");\nminor_test = (1, 2, 3, 0, 4, 5, 7, 8, 9) : la.minor(3, 1, 1);"
    },
    "la.inverse": {
      "prefix": "la",
      "name": "inverse",
      "full_name": "la.inverse",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Inverts a matrix. The incoming bus represents an `NxN` matrix. Note, this is an unsafe operation since not all matrices are invertible.",
      "param_docs": {
        "N": "the size of each axis of the matrix."
      },
      "example": "la = library(\"linearalgebra.lib\");\ninverse_test = (4, 7, 2, 6) : la.inverse(2);"
    },
    "la.transpose2": {
      "prefix": "la",
      "name": "transpose2",
      "full_name": "la.transpose2",
      "args": [
        "N",
        "M"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Transposes an `NxM` matrix stored in row-major order, resulting in an `MxN` matrix stored in row-major order.",
      "param_docs": {
        "N": "the number of rows in the input matrix",
        "M": "the number of columns in the input matrix"
      },
      "example": "la = library(\"linearalgebra.lib\");\ntranspose2_test = (1, 2, 3, 4, 5, 6) : la.transpose2(2, 3);"
    },
    "la.matMul": {
      "prefix": "la",
      "name": "matMul",
      "full_name": "la.matMul",
      "args": [
        "J",
        "K",
        "L",
        "M",
        "si.bus(J*K"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Multiply a `JxK` matrix (mat1) and an `LxM` matrix (mat2) to produce a `JxM` matrix. Note that `K==L`. Both matrices should use row-major order.",
      "param_docs": {
        "J": "the number of rows in `mat1`",
        "K": "the number of columns in `mat1`",
        "L": "the number of rows in `mat2`",
        "M": "the number of columns in `mat2`"
      },
      "example": "la = library(\"linearalgebra.lib\");\nmatMul_test = (1, 2, 3, 4), (5, 6, 7, 8) : la.matMul(2, 2, 2, 2);"
    },
    "la.identity": {
      "prefix": "la",
      "name": "identity",
      "full_name": "la.identity",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates an `NxN` identity matrix.",
      "param_docs": {
        "N": "The size of each axis of the identity matrix."
      },
      "example": "la = library(\"linearalgebra.lib\");\nidentity_test = la.identity(3);"
    },
    "la.diag": {
      "prefix": "la",
      "name": "diag",
      "full_name": "la.diag",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a diagonal matrix of size `NxN` with specified values along the diagonal.",
      "param_docs": {
        "N": "The size of each axis of the matrix."
      },
      "example": "la = library(\"linearalgebra.lib\");\ndiag_test = (1, 2, 3) : la.diag(3);"
    },
    "ma.SR": {
      "prefix": "ma",
      "name": "SR",
      "full_name": "ma.SR",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current sampling rate given at init time. Constant during program execution.",
      "param_docs": {
        "SR": "initialization-time sampling rate constant"
      },
      "example": "ma = library(\"maths.lib\");\nSR_test = ma.SR;"
    },
    "ma.T": {
      "prefix": "ma",
      "name": "T",
      "full_name": "ma.T",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current sample duration in seconds computed from the sampling rate given at init time. Constant during program execution.",
      "param_docs": {
        "T": "sample duration (`1/SR`) constant"
      },
      "example": "ma = library(\"maths.lib\");\nT_test = ma.T;"
    },
    "ma.BS": {
      "prefix": "ma",
      "name": "BS",
      "full_name": "ma.BS",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current block-size. Can change during the execution at each block.",
      "param_docs": {
        "BS": "current processing block size"
      },
      "example": "ma = library(\"maths.lib\");\nBS_test = ma.BS;"
    },
    "ma.PI": {
      "prefix": "ma",
      "name": "PI",
      "full_name": "ma.PI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant PI in double precision.",
      "param_docs": {
        "PI": "double-precision \u03c0 constant"
      },
      "example": "ma = library(\"maths.lib\");\nPI_test = ma.PI;"
    },
    "ma.deg2rad": {
      "prefix": "ma",
      "name": "deg2rad",
      "full_name": "ma.deg2rad",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Convert degrees to radians.",
      "param_docs": {},
      "example": "ma = library(\"maths.lib\");\ndeg2rad_test = 45.0 : ma.deg2rad;"
    },
    "ma.rad2deg": {
      "prefix": "ma",
      "name": "rad2deg",
      "full_name": "ma.rad2deg",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Convert radians to degrees.",
      "param_docs": {},
      "example": "ma = library(\"maths.lib\");\nrad2deg_test = ma.PI : ma.rad2deg;"
    },
    "ma.E": {
      "prefix": "ma",
      "name": "E",
      "full_name": "ma.E",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant e in double precision.",
      "param_docs": {
        "E": "double-precision Euler's number constant"
      },
      "example": "ma = library(\"maths.lib\");\nE_test = ma.E;"
    },
    "ma.EPSILON": {
      "prefix": "ma",
      "name": "EPSILON",
      "full_name": "ma.EPSILON",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant EPSILON available in simple/double/quad precision, as defined in the [floating-point standard](https://en.wikipedia.org/wiki/IEEE_754) and [machine epsilon](https://en.wikipedia.org/wiki/Mach",
      "param_docs": {
        "EPSILON": "machine epsilon constant for the current floating-point precision"
      },
      "example": "ma = library(\"maths.lib\");\nEPSILON_test = ma.EPSILON;"
    },
    "ma.MIN": {
      "prefix": "ma",
      "name": "MIN",
      "full_name": "ma.MIN",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant MIN available in simple/double/quad precision (minimal positive value).",
      "param_docs": {
        "MIN": "minimal positive normalized value for the current precision"
      },
      "example": "ma = library(\"maths.lib\");\nMIN_test = ma.MIN;"
    },
    "ma.MAX": {
      "prefix": "ma",
      "name": "MAX",
      "full_name": "ma.MAX",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant MAX available in simple/double/quad precision (maximal positive value).",
      "param_docs": {
        "MAX": "maximal finite value for the current precision"
      },
      "example": "ma = library(\"maths.lib\");\nMAX_test = ma.MAX;"
    },
    "ma.FTZ": {
      "prefix": "ma",
      "name": "FTZ",
      "full_name": "ma.FTZ",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Flush to zero: force samples under the \"maximum subnormal number\" to be zero. Usually not needed in C++ because the architecture file take care of this, but can be useful in JavaScript for instance.",
      "param_docs": {
        "x": "input signal to flush if its magnitude is subnormal"
      },
      "example": "ma = library(\"maths.lib\");\nFTZ_test = (ma.MIN * 0.5) : ma.FTZ;"
    },
    "ma.copysign": {
      "prefix": "ma",
      "name": "copysign",
      "full_name": "ma.copysign",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Changes the sign of x (first input) to that of y (second input).",
      "param_docs": {
        "x": "value whose magnitude is preserved",
        "y": "value providing the sign"
      },
      "example": "ma = library(\"maths.lib\");\ncopysign_test = (-1.0, 2.0) : ma.copysign;"
    },
    "ma.neg": {
      "prefix": "ma",
      "name": "neg",
      "full_name": "ma.neg",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Invert the sign (-x) of a signal.",
      "param_docs": {
        "x": "value to negate"
      },
      "example": "ma = library(\"maths.lib\");\nneg_test = 3.5 : ma.neg;"
    },
    "ma.not": {
      "prefix": "ma",
      "name": "not",
      "full_name": "ma.not",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Bitwise `not` implemented with [xor](https://faustdoc.grame.fr/manual/syntax/#xor-primitive) as `not(x) = x xor -1;`. So working regardless of the size of the integer, assuming negative numbers in two",
      "param_docs": {
        "x": "integer input value"
      },
      "example": "ma = library(\"maths.lib\");\nnot_test = 5 : ma.not;"
    },
    "ma.x": {
      "prefix": "ma",
      "name": "x",
      "full_name": "ma.x",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Subtract `x` and `y`.",
      "param_docs": {
        "x": "first operand",
        "y": "second operand"
      },
      "example": "ma = library(\"maths.lib\");\nsub_test = (3, 10) : ma.sub;"
    },
    "ma.inv": {
      "prefix": "ma",
      "name": "inv",
      "full_name": "ma.inv",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Compute the inverse (1/x) of the input signal.",
      "param_docs": {
        "x": "denominator input (non-zero)"
      },
      "example": "ma = library(\"maths.lib\");\ninv_test = 4.0 : ma.inv;"
    },
    "ma.cbrt": {
      "prefix": "ma",
      "name": "cbrt",
      "full_name": "ma.cbrt",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the cube root of of the input signal.",
      "param_docs": {
        "x": "value whose cube root is computed"
      },
      "example": "ma = library(\"maths.lib\");\ncbrt_test = 8.0 : ma.cbrt;"
    },
    "ma.hypot": {
      "prefix": "ma",
      "name": "hypot",
      "full_name": "ma.hypot",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Computes the euclidian distance of the two input signals sqrt(x*x+y*y) without undue overflow or underflow.",
      "param_docs": {
        "x": "first operand",
        "y": "second operand"
      },
      "example": "ma = library(\"maths.lib\");\nhypot_test = (3.0, 4.0) : ma.hypot;"
    },
    "ma.ldexp": {
      "prefix": "ma",
      "name": "ldexp",
      "full_name": "ma.ldexp",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Takes two input signals: x and n, and multiplies x by 2 to the power n.",
      "param_docs": {
        "x": "significand input",
        "n": "exponent (integer) input"
      },
      "example": "ma = library(\"maths.lib\");\nldexp_test = (1.5, 3) : ma.ldexp;"
    },
    "ma.scalb": {
      "prefix": "ma",
      "name": "scalb",
      "full_name": "ma.scalb",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Takes two input signals: x and n, and multiplies x by 2 to the power n.",
      "param_docs": {
        "x": "significand input",
        "n": "exponent (integer) input"
      },
      "example": "ma = library(\"maths.lib\");\nscalb_test = (2.0, -1) : ma.scalb;"
    },
    "ma.log1p": {
      "prefix": "ma",
      "name": "log1p",
      "full_name": "ma.log1p",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes log(1 + x) without undue loss of accuracy when x is nearly zero.",
      "param_docs": {
        "x": "offset used in `log(1 + x)` (must be greater than -1)"
      },
      "example": "ma = library(\"maths.lib\");\nlog1p_test = 0.5 : ma.log1p;"
    },
    "ma.logb": {
      "prefix": "ma",
      "name": "logb",
      "full_name": "ma.logb",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Return exponent of the input signal as a floating-point number.",
      "param_docs": {
        "x": "positive value whose exponent part is returned"
      },
      "example": "ma = library(\"maths.lib\");\nlogb_test = 8.0 : ma.logb;"
    },
    "ma.ilogb": {
      "prefix": "ma",
      "name": "ilogb",
      "full_name": "ma.ilogb",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Return exponent of the input signal as an integer number.",
      "param_docs": {
        "x": "positive value whose exponent part is returned"
      },
      "example": "ma = library(\"maths.lib\");\nilogb_test = 8.0 : ma.ilogb;"
    },
    "ma.log2": {
      "prefix": "ma",
      "name": "log2",
      "full_name": "ma.log2",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Returns the base 2 logarithm of x.",
      "param_docs": {
        "x": "positive value whose base-2 logarithm is computed"
      },
      "example": "ma = library(\"maths.lib\");\nlog2_test = 8.0 : ma.log2;"
    },
    "ma.expm1": {
      "prefix": "ma",
      "name": "expm1",
      "full_name": "ma.expm1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Return exponent of the input signal minus 1 with better precision.",
      "param_docs": {
        "x": "input value used for the `exp(x) - 1` computation"
      },
      "example": "ma = library(\"maths.lib\");\nexpm1_test = 0.5 : ma.expm1;"
    },
    "ma.acosh": {
      "prefix": "ma",
      "name": "acosh",
      "full_name": "ma.acosh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the principle value of the inverse hyperbolic cosine of the input signal.",
      "param_docs": {
        "x": "input value (greater than or equal to 1)"
      },
      "example": "ma = library(\"maths.lib\");\nacosh_test = 1.5 : ma.acosh;"
    },
    "ma.asinh": {
      "prefix": "ma",
      "name": "asinh",
      "full_name": "ma.asinh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the inverse hyperbolic sine of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nasinh_test = 0.5 : ma.asinh;"
    },
    "ma.atanh": {
      "prefix": "ma",
      "name": "atanh",
      "full_name": "ma.atanh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the inverse hyperbolic tangent of the input signal.",
      "param_docs": {
        "x": "input value in (-1, 1)"
      },
      "example": "ma = library(\"maths.lib\");\natanh_test = 0.5 : ma.atanh;"
    },
    "ma.sinh": {
      "prefix": "ma",
      "name": "sinh",
      "full_name": "ma.sinh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the hyperbolic sine of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nsinh_test = 0.5 : ma.sinh;"
    },
    "ma.cosh": {
      "prefix": "ma",
      "name": "cosh",
      "full_name": "ma.cosh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the hyperbolic cosine of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\ncosh_test = 0.5 : ma.cosh;"
    },
    "ma.tanh": {
      "prefix": "ma",
      "name": "tanh",
      "full_name": "ma.tanh",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the hyperbolic tangent of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\ntanh_test = 0.5 : ma.tanh;"
    },
    "ma.erf": {
      "prefix": "ma",
      "name": "erf",
      "full_name": "ma.erf",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the error function of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nerf_test = 0.5 : ma.erf;"
    },
    "ma.erfc": {
      "prefix": "ma",
      "name": "erfc",
      "full_name": "ma.erfc",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the complementary error function of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nerfc_test = 0.5 : ma.erfc;"
    },
    "ma.gamma": {
      "prefix": "ma",
      "name": "gamma",
      "full_name": "ma.gamma",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the gamma function of the input signal.",
      "param_docs": {
        "x": "positive input value"
      },
      "example": "ma = library(\"maths.lib\");\ngamma_test = 3.0 : ma.gamma;"
    },
    "ma.lgamma": {
      "prefix": "ma",
      "name": "lgamma",
      "full_name": "ma.lgamma",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Calculates the natural logorithm of the absolute value of the gamma function of the input signal.",
      "param_docs": {
        "x": "positive input value"
      },
      "example": "ma = library(\"maths.lib\");\nlgamma_test = 3.0 : ma.lgamma;"
    },
    "ma.J0": {
      "prefix": "ma",
      "name": "J0",
      "full_name": "ma.J0",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the Bessel function of the first kind of order 0 of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nJ0_test = 1.0 : ma.J0;"
    },
    "ma.J1": {
      "prefix": "ma",
      "name": "J1",
      "full_name": "ma.J1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the Bessel function of the first kind of order 1 of the input signal.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nJ1_test = 1.0 : ma.J1;"
    },
    "ma.Jn": {
      "prefix": "ma",
      "name": "Jn",
      "full_name": "ma.Jn",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Computes the Bessel function of the first kind of order n (first input signal) of the second input signal.",
      "param_docs": {
        "n": "integer order",
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nJn_test = (2, 1.0) : ma.Jn;"
    },
    "ma.Y0": {
      "prefix": "ma",
      "name": "Y0",
      "full_name": "ma.Y0",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the linearly independent Bessel function of the second kind of order 0 of the input signal.",
      "param_docs": {
        "x": "positive input value"
      },
      "example": "ma = library(\"maths.lib\");\nY0_test = 1.0 : ma.Y0;"
    },
    "ma.Y1": {
      "prefix": "ma",
      "name": "Y1",
      "full_name": "ma.Y1",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Computes the linearly independent Bessel function of the second kind of order 1 of the input signal.",
      "param_docs": {
        "x": "positive input value"
      },
      "example": "ma = library(\"maths.lib\");\nY1_test = 1.0 : ma.Y1;"
    },
    "ma.Yn": {
      "prefix": "ma",
      "name": "Yn",
      "full_name": "ma.Yn",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 1,
      "description": "Computes the linearly independent Bessel function of the second kind of order n (first input signal) of the second input signal.",
      "param_docs": {
        "n": "integer order",
        "x": "positive input value"
      },
      "example": "ma = library(\"maths.lib\");\nYn_test = (2, 1.0) : ma.Yn;"
    },
    "ma.fabs": {
      "prefix": "ma",
      "name": "fabs",
      "full_name": "ma.fabs",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Just for compatibility...",
      "param_docs": {},
      "example": ""
    },
    "ma.np2": {
      "prefix": "ma",
      "name": "np2",
      "full_name": "ma.np2",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Gives the next power of 2 of x.",
      "param_docs": {
        "n": "an integer"
      },
      "example": "ma = library(\"maths.lib\");\nnp2_test = 5 : ma.np2;"
    },
    "ma.frac": {
      "prefix": "ma",
      "name": "frac",
      "full_name": "ma.frac",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Gives the fractional part of n.",
      "param_docs": {
        "n": "a decimal number"
      },
      "example": "ma = library(\"maths.lib\");\nfrac_test = 3.75 : ma.frac;"
    },
    "ma.modulo": {
      "prefix": "ma",
      "name": "modulo",
      "full_name": "ma.modulo",
      "args": [
        "x",
        "y"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Modulus operation using the `(x%y+y)%y` formula to ensures the result is always non-negative, even if `x` is negative.",
      "param_docs": {
        "x": "the numerator",
        "y": "the denominator"
      },
      "example": "ma = library(\"maths.lib\");\nmodulo_test = (-3, 4) : ma.modulo;"
    },
    "ma.isnan": {
      "prefix": "ma",
      "name": "isnan",
      "full_name": "ma.isnan",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Return non-zero if x is a NaN.",
      "param_docs": {
        "x": "signal to analyse"
      },
      "example": "ma = library(\"maths.lib\");\nisnan_test = 1.0 : ma.isnan;"
    },
    "ma.isinf": {
      "prefix": "ma",
      "name": "isinf",
      "full_name": "ma.isinf",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Return non-zero if x is a positive or negative infinity.",
      "param_docs": {
        "x": "signal to analyse"
      },
      "example": "ma = library(\"maths.lib\");\nisinf_test = 1.0 : ma.isinf;"
    },
    "ma.chebychev": {
      "prefix": "ma",
      "name": "chebychev",
      "full_name": "ma.chebychev",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Chebychev transformation of order N.",
      "param_docs": {
        "N": "the order of the polynomial, a constant numerical expression"
      },
      "example": "ma = library(\"maths.lib\");\nchebychev_test = 0.5 : ma.chebychev(3);"
    },
    "ma.chebychevpoly": {
      "prefix": "ma",
      "name": "chebychevpoly",
      "full_name": "ma.chebychevpoly",
      "args": [
        "c0",
        "c1",
        "...",
        "cn"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Linear combination of the first Chebyshev polynomials.",
      "param_docs": {
        "cn": "the different Chebychevs polynomials such that:"
      },
      "example": "ma = library(\"maths.lib\");\nchebychevpoly_test = 0.5 : ma.chebychevpoly((1, 0, 1));"
    },
    "ma.diffn": {
      "prefix": "ma",
      "name": "diffn",
      "full_name": "ma.diffn",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Negated first-order difference.",
      "param_docs": {
        "x": "input signal"
      },
      "example": "ma = library(\"maths.lib\");\nos = library(\"oscillators.lib\");\ndiffn_test = os.osc(440) : ma.diffn;"
    },
    "ma.signum": {
      "prefix": "ma",
      "name": "signum",
      "full_name": "ma.signum",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "The signum function signum(x) is defined as -1 for x<0, 0 for x==0, and 1 for x>0.",
      "param_docs": {
        "x": "input value"
      },
      "example": "ma = library(\"maths.lib\");\nsignum_test = (-5.0) : ma.signum;"
    },
    "ma.nextpow2": {
      "prefix": "ma",
      "name": "nextpow2",
      "full_name": "ma.nextpow2",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "The nextpow2(x) returns the lowest integer m such that 2^m >= x.",
      "param_docs": {
        "n": "positive value whose next power-of-two exponent is computed"
      },
      "example": "ma = library(\"maths.lib\");\nnextpow2_test = 10.0 : ma.nextpow2;"
    },
    "ma.zc": {
      "prefix": "ma",
      "name": "zc",
      "full_name": "ma.zc",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 1,
      "description": "Indicator function for zero-crossing: it returns 1 if a zero-crossing occurs, 0 otherwise.",
      "param_docs": {
        "x": "input signal to monitor for zero crossings"
      },
      "example": "ma = library(\"maths.lib\");\nos = library(\"oscillators.lib\");\nzc_test = os.osc(440) : ma.zc;"
    },
    "ma.primes": {
      "prefix": "ma",
      "name": "primes",
      "full_name": "ma.primes",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Return the n-th prime using a waveform primitive. Note that primes(0) is 2, primes(1) is 3, and so on. The waveform is length 2048, so the largest precomputed prime is primes(2047) which is 17863.",
      "param_docs": {
        "x": "index of the prime number sequence (0-based)."
      },
      "example": "ma = library(\"maths.lib\");\nprimes_test = 10 : ma.primes;"
    },
    "mi.initState": {
      "prefix": "mi",
      "name": "initState",
      "full_name": "mi.initState",
      "args": [
        "x0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Used to set initial delayed position values that must be initialised at step 0 of the physics simulation.",
      "param_docs": {
        "x": "position value signal",
        "x0": "initial value for position"
      },
      "example": "mi = library(\"mi.lib\");\ninitState_test = button(\"impulse\") : mi.initState(1.0);"
    },
    "mi.mass": {
      "prefix": "mi",
      "name": "mass",
      "full_name": "mi.mass",
      "args": [
        "m",
        "grav",
        "x0",
        "xr0"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 2,
      "description": "Implementation of a punctual mass element. Takes an input force and produces output position.",
      "param_docs": {
        "m": "mass value",
        "grav": "gravity force value",
        "x0": "initial position",
        "xr0": "initial delayed position (inferred from initial velocity)"
      },
      "example": "mi = library(\"mi.lib\");\nmass_test = 0 : mi.mass(1.0, 0.0, 0.0, 0.0);"
    },
    "mi.oscil": {
      "prefix": "mi",
      "name": "oscil",
      "full_name": "mi.oscil",
      "args": [
        "m",
        "k",
        "z",
        "grav",
        "x0",
        "xr0"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 2,
      "description": "Implementation of a simple linear harmonic oscillator. Takes an input force and produces output position.",
      "param_docs": {
        "m": "mass value",
        "k": "stiffness value",
        "z": "damping value",
        "grav": "gravity force value",
        "x0": "initial position",
        "xr0": "initial delayed position (inferred from initial velocity)"
      },
      "example": "mi = library(\"mi.lib\");\noscil_test = 0 : mi.oscil(1.0, 0.5, 0.1, 0.0, 0.0, 0.0);"
    },
    "mi.ground": {
      "prefix": "mi",
      "name": "ground",
      "full_name": "mi.ground",
      "args": [
        "x0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Implementation of a fixed point element. The position output produced by this module never changes, however it still expects a force input signal (for compliance with connection",
      "param_docs": {
        "x0": "initial position"
      },
      "example": "mi = library(\"mi.lib\");\nground_test = 0 : mi.ground(0.0);"
    },
    "mi.posInput": {
      "prefix": "mi",
      "name": "posInput",
      "full_name": "mi.posInput",
      "args": [
        "x0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 3,
      "description": "Implementation of a position input module (driven by an outside signal). Takes two signal inputs: incoming force (which doesn't affect position) and the driving position signal.",
      "param_docs": {
        "x0": "initial position"
      },
      "example": "mi = library(\"mi.lib\");\nos = library(\"oscillators.lib\");\nposInput_test = 0, os.osc(1) : mi.posInput(0.0);"
    },
    "mi.spring": {
      "prefix": "mi",
      "name": "spring",
      "full_name": "mi.spring",
      "args": [
        "k",
        "x1r",
        "x2r"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a linear elastic spring interaction.",
      "param_docs": {
        "k": "stiffness value",
        "x1r": "initial delayed position of mass 1 (unused here)",
        "x2r": "initial delayed position of mass 2 (unused here)"
      },
      "example": "mi = library(\"mi.lib\");\nspring_test = mi.spring(10.0, 0.0, 0.0, 0.1, -0.1);"
    },
    "mi.damper": {
      "prefix": "mi",
      "name": "damper",
      "full_name": "mi.damper",
      "args": [
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a linear damper interaction. Beware: in 32bit precision mode, damping forces can become truncated if position values are not centered around zero!",
      "param_docs": {
        "z": "damping value",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\ndamper_test = mi.damper(0.5, 0.0, 0.0, 0.2, -0.2);"
    },
    "mi.springDamper": {
      "prefix": "mi",
      "name": "springDamper",
      "full_name": "mi.springDamper",
      "args": [
        "k",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a linear viscoelastic spring-damper interaction (a combination of the spring and damper modules).",
      "param_docs": {
        "k": "stiffness value",
        "z": "damping value",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nspringDamper_test = mi.springDamper(5.0, 0.3, 0.0, 0.0, 0.1, -0.1);"
    },
    "mi.nlSpringDamper2": {
      "prefix": "mi",
      "name": "nlSpringDamper2",
      "full_name": "mi.nlSpringDamper2",
      "args": [
        "k",
        "q",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear viscoelastic spring-damper interaction containing a quadratic term (function of squared distance). Beware: at high displacements, this interaction will break numerical",
      "param_docs": {
        "k": "linear stiffness value",
        "q": "quadratic stiffness value",
        "z": "damping value",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nnlSpringDamper2_test = mi.nlSpringDamper2(5.0, 1.0, 0.2, 0.0, 0.0, 0.1, -0.1);"
    },
    "mi.nlSpringDamper3": {
      "prefix": "mi",
      "name": "nlSpringDamper3",
      "full_name": "mi.nlSpringDamper3",
      "args": [
        "k",
        "q",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear viscoelastic spring-damper interaction containing a cubic term (function of distance^3). Beware: at high displacements, this interaction will break numerical",
      "param_docs": {
        "k": "linear stiffness value",
        "q": "cubic stiffness value",
        "z": "damping value",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nnlSpringDamper3_test = mi.nlSpringDamper3(5.0, 0.5, 0.2, 0.0, 0.0, 0.1, -0.1);"
    },
    "mi.nlSpringDamperClipped": {
      "prefix": "mi",
      "name": "nlSpringDamperClipped",
      "full_name": "mi.nlSpringDamperClipped",
      "args": [
        "s",
        "c",
        "k",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear viscoelastic spring-damper interaction containing a cubic term (function of distance^3), bound by an upper linear stiffness (hard-clipping).",
      "param_docs": {
        "s": "linear stiffness value",
        "c": "cubic stiffness value",
        "k": "upper-bound linear stiffness value",
        "z": "(linear) damping value",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nnlSpringDamperClipped_test = mi.nlSpringDamperClipped(5.0, 0.5, 8.0, 0.2, 0.0, 0.0, 0.1, -0.1);"
    },
    "mi.nlPluck": {
      "prefix": "mi",
      "name": "nlPluck",
      "full_name": "mi.nlPluck",
      "args": [
        "knl",
        "scale",
        "z",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a piecewise linear plucking interaction. The symmetric function provides a repulsive viscoelastic interaction upon contact, until a tipping point is reached (when the plucking occurs",
      "param_docs": {
        "knl": "stiffness scaling parameter (vertical stretch of the NL function)",
        "scale": "distance scaling parameter (horizontal stretch of the NL function)",
        "z": "(linear) damping value",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nnlPluck_test = mi.nlPluck(5.0, 0.1, 0.2, 0.0, 0.0, 0.05, -0.05);"
    },
    "mi.nlBow": {
      "prefix": "mi",
      "name": "nlBow",
      "full_name": "mi.nlBow",
      "args": [
        "znl",
        "scale",
        "type",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a non-linear friction based interaction that allows for stick-slip bowing behaviour. Two versions are proposed : a piecewise linear function (very",
      "param_docs": {
        "znl": "friction scaling parameter (vertical stretch of the NL function)",
        "scale": "velocity scaling parameter (horizontal stretch of the NL function)",
        "type": "interaction profile (0 = piecewise linear, 1 = smooth function)",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nnlBow_test = mi.nlBow(0.5, 0.1, 1.0, 0.0, 0.0, 0.05, -0.05);"
    },
    "mi.collision": {
      "prefix": "mi",
      "name": "collision",
      "full_name": "mi.collision",
      "args": [
        "k",
        "z",
        "thres",
        "x1r",
        "x2r"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a collision interaction, producing linear visco-elastic repulsion forces when two mass elements are interpenetrating.",
      "param_docs": {
        "k": "collision stiffness parameter",
        "z": "collision damping parameter",
        "thres": "threshold distance for the contact between elements",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\ncollision_test = mi.collision(5.0, 0.2, 0.01, 0.0, 0.0, 0.0, -0.02);"
    },
    "mi.nlCollisionClipped": {
      "prefix": "mi",
      "name": "nlCollisionClipped",
      "full_name": "mi.nlCollisionClipped",
      "args": [
        "s",
        "c",
        "k",
        "z",
        "thres",
        "x1r",
        "x2r"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 4,
      "description": "Implementation of a collision interaction, producing non-linear visco-elastic repulsion forces when two mass elements are interpenetrating. Bound by an upper stiffness value to maintain stability.",
      "param_docs": {
        "s": "collision linear stiffness parameter",
        "c": "collision cubic stiffness parameter",
        "k": "collision upper-bounding stiffness parameter",
        "z": "collision damping parameter",
        "thres": "threshold distance for the contact between elements",
        "x1r": "initial delayed position of mass 1",
        "x2r": "initial delayed position of mass 2"
      },
      "example": "mi = library(\"mi.lib\");\nnlCollisionClipped_test = mi.nlCollisionClipped(3.0, 0.5, 6.0, 0.2, 0.01, 0.0, 0.0, 0.0, -0.02);"
    },
    "ef.cubicnl": {
      "prefix": "ef",
      "name": "cubicnl",
      "full_name": "ef.cubicnl",
      "args": [
        "drive",
        "offset"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Cubic nonlinearity distortion. `cubicnl` is a standard Faust function.",
      "param_docs": {
        "drive": "distortion amount, between 0 and 1",
        "offset": "constant added before nonlinearity to give even harmonics. Note: offset"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ncubicnl_test = os.osc(440) : ef.cubicnl(0.5, 0.0);\ncubicnl_nodc_test = os.osc(440) : ef.cubicnl_nodc(0.5, 0.0);"
    },
    "ef.gate_mono": {
      "prefix": "ef",
      "name": "gate_mono",
      "full_name": "ef.gate_mono",
      "args": [
        "thresh",
        "att",
        "hold",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono signal gate. `gate_mono` is a standard Faust function.",
      "param_docs": {
        "thresh": "dB level threshold above which gate opens (e.g., -60 dB)",
        "att": "attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)",
        "hold": "hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)",
        "rel": "release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ngate_mono_test = os.osc(440) : ef.gate_mono(-60, 0.0001, 0.1, 0.02);"
    },
    "ef.gate_stereo": {
      "prefix": "ef",
      "name": "gate_stereo",
      "full_name": "ef.gate_stereo",
      "args": [
        "thresh",
        "att",
        "hold",
        "rel"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo signal gates. `gate_stereo` is a standard Faust function.",
      "param_docs": {
        "thresh": "dB level threshold above which gate opens (e.g., -60 dB)",
        "att": "attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)",
        "hold": "hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)",
        "rel": "release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ngate_stereo_test = os.osc(440), os.osc(441) : ef.gate_stereo(-60, 0.0001, 0.1, 0.02);"
    },
    "ef.fibonacci": {
      "prefix": "ef",
      "name": "fibonacci",
      "full_name": "ef.fibonacci",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Fibonacci system where the current output is the current input plus the sum of the previous N outputs.",
      "param_docs": {
        "N": "the Fibonacci system's order, where 2 is standard"
      },
      "example": "ef = library(\"misceffects.lib\");\nfibonacci_test = 0 : ef.fibonacci(2);"
    },
    "ef.fibonacciGeneral": {
      "prefix": "ef",
      "name": "fibonacciGeneral",
      "full_name": "ef.fibonacciGeneral",
      "args": [
        "wave"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Fibonacci system with customizable coefficients. The order of the system is inferred from the number of coefficients.",
      "param_docs": {
        "wave": "a waveform such as `waveform{1, 1}`"
      },
      "example": "ef = library(\"misceffects.lib\");\nfibonacciGeneral_test = 0 : ef.fibonacciGeneral(waveform{2, 3});"
    },
    "ef.fibonacciSeq": {
      "prefix": "ef",
      "name": "fibonacciSeq",
      "full_name": "ef.fibonacciSeq",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "First N numbers of the Fibonacci sequence [1, 1, 2, 3, 5, 8, ...] as parallel channels.",
      "param_docs": {
        "N": "The number of Fibonacci numbers to generate as channels."
      },
      "example": "ef = library(\"misceffects.lib\");\nfibonacciSeq_test = ef.fibonacciSeq(5);"
    },
    "ef.speakerbp": {
      "prefix": "ef",
      "name": "speakerbp",
      "full_name": "ef.speakerbp",
      "args": [
        "f1",
        "f2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Dirt-simple speaker simulator (overall bandpass eq with observed roll-offs above and below the passband). `speakerbp` is a standard Faust function.",
      "param_docs": {},
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nspeakerbp_test = os.osc(440) : ef.speakerbp(100.0, 5000.0);"
    },
    "ef.piano_dispersion_filter": {
      "prefix": "ef",
      "name": "piano_dispersion_filter",
      "full_name": "ef.piano_dispersion_filter",
      "args": [
        "M",
        "B",
        "f0"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Piano dispersion allpass filter in closed form.",
      "param_docs": {
        "M": "number of first-order allpass sections (compile-time only)",
        "B": "string inharmonicity coefficient (0.0001 is typical)",
        "f0": "fundamental frequency in Hz"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\npiano_dispersion_filter_test = os.osc(110) : ef.piano_dispersion_filter(4, 0.0001, 110);"
    },
    "ef.stereo_width": {
      "prefix": "ef",
      "name": "stereo_width",
      "full_name": "ef.stereo_width",
      "args": [
        "w"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo Width effect using the Blumlein Shuffler technique. `stereo_width` is a standard Faust function.",
      "param_docs": {
        "w": "stereo width between 0 and 1"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nstereo_width_test = os.osc(440), os.osc(550) : ef.stereo_width(0.5);"
    },
    "ef.mesh_square": {
      "prefix": "ef",
      "name": "mesh_square",
      "full_name": "ef.mesh_square",
      "args": [
        "4*N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Square Rectangular Digital Waveguide Mesh.",
      "param_docs": {
        "N": "number of nodes along each edge - a power of two (1,2,4,8,...)"
      },
      "example": "ef = library(\"misceffects.lib\");\nmesh_square_test = (0,0,0,0) : ef.mesh_square(1);"
    },
    "ef.dryWetMixer": {
      "prefix": "ef",
      "name": "dryWetMixer",
      "full_name": "ef.dryWetMixer",
      "args": [
        "wetAmount",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear dry-wet mixer for a N inputs and N outputs effect.",
      "param_docs": {
        "wetAmount": "the wet amount (0-1). 0 produces only the dry signal and 1 produces only the wet signal",
        "FX": "an arbitrary effect (N inputs and N outputs) to apply to the input bus"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ndryWetMixer_test = os.osc(440) : ef.dryWetMixer(0.5, fi.dcblocker);"
    },
    "ef.dryWetMixerConstantPower": {
      "prefix": "ef",
      "name": "dryWetMixerConstantPower",
      "full_name": "ef.dryWetMixerConstantPower",
      "args": [
        "wetAmount",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant-power dry-wet mixer for a N inputs and N outputs effect.",
      "param_docs": {
        "wetAmount": "the wet amount (0-1). 0 produces only the dry signal and 1 produces only the wet signal",
        "FX": "an arbitrary effect (N inputs and N outputs) to apply to the input bus"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ndryWetMixerConstantPower_test = os.osc(440) : ef.dryWetMixerConstantPower(0.5, fi.dcblocker);"
    },
    "ef.weightsPowerLoop": {
      "prefix": "ef",
      "name": "weightsPowerLoop",
      "full_name": "ef.weightsPowerLoop",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "\"Fan out\" an index into N weights between 0 and 1. At any given moment, two weights may be non-zero. Suppose they are N_m and N_{m+1}. Then `cos(N_m)^2+sin(N_{m+1})^2==0.5`.",
      "param_docs": {
        "N": "number of output weights",
        "m": "[0;N-1] (float) blend index. If m is outside [0;N-1], the behavior will loop."
      },
      "example": "ef = library(\"misceffects.lib\");\nweightsPowerLoop_test = ef.mixingEnv.weightsPowerLoop(4, 1.2);"
    },
    "ef.mixLinearClamp": {
      "prefix": "ef",
      "name": "mixLinearClamp",
      "full_name": "ef.mixLinearClamp",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear mixer for `N` buses, each with `C` channels. The output will be a sum of 2 buses determined by the mixing index `mix`. 0 produces the first bus, 1 produces the second, and so on. `mix` is clamp",
      "param_docs": {
        "N": "the number of input buses",
        "C": "the number of channels in each bus",
        "mix": "the mixing index, continuous in [0;N-1]."
      },
      "example": "ef = library(\"misceffects.lib\");\nmixLinearClamp_test = (1,0,0,0) : ef.mixLinearClamp(4, 1, 1.2);"
    },
    "ef.mixLinearLoop": {
      "prefix": "ef",
      "name": "mixLinearLoop",
      "full_name": "ef.mixLinearLoop",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Linear mixer for `N` buses, each with `C` channels. Refer to `mixLinearClamp`. `mix` will loop for multiples of `N`. For example, `mixLinearLoop(4, 1, 0)` has the same effect as `mixLinearLoop(4, 1, -",
      "param_docs": {
        "N": "the number of input buses",
        "C": "the number of channels in each bus",
        "mix": "the mixing index (N-1) selects the last bus, and 0 or N selects the 0th bus."
      },
      "example": "ef = library(\"misceffects.lib\");\nmixLinearLoop_test = (1,0,0,0) : ef.mixLinearLoop(4, 1, -0.3);"
    },
    "ef.mixPowerClamp": {
      "prefix": "ef",
      "name": "mixPowerClamp",
      "full_name": "ef.mixPowerClamp",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant-power mixer for `N` buses, each with `C` channels. The output will be a sum of 2 buses determined by the mixing index `mix`. 0 produces the first bus, 1 produces the second, and so on. `mix` ",
      "param_docs": {
        "N": "the number of input buses",
        "C": "the number of channels in each bus",
        "mix": "the mixing index, continuous in [0;N-1]."
      },
      "example": "ef = library(\"misceffects.lib\");\nmixPowerClamp_test = (1,0,0,0) : ef.mixPowerClamp(4, 1, 1.5);"
    },
    "ef.mixPowerLoop": {
      "prefix": "ef",
      "name": "mixPowerLoop",
      "full_name": "ef.mixPowerLoop",
      "args": [
        "N",
        "C",
        "mix"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Constant-power mixer for `N` buses, each with `C` channels. Refer to `mixPowerClamp`. `mix` will loop for multiples of `N`. For example, `mixPowerLoop(4, 1, 0)` has the same effect as `mixPowerLoop(4,",
      "param_docs": {
        "N": "the number of input buses",
        "C": "the number of channels in each bus",
        "mix": "the mixing index (N-1) selects the last bus, and 0 or N selects the 0th bus."
      },
      "example": "ef = library(\"misceffects.lib\");\nmixPowerLoop_test = (1,0,0,0) : ef.mixPowerLoop(4, 1, -0.5);"
    },
    "ef.echo": {
      "prefix": "ef",
      "name": "echo",
      "full_name": "ef.echo",
      "args": [
        "maxDuration",
        "duration",
        "feedback"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "A simple echo effect. `echo` is a standard Faust function.",
      "param_docs": {
        "maxDuration": "the max echo duration in seconds",
        "duration": "the echo duration in seconds",
        "feedback": "the feedback coefficient"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\necho_test = os.osc(440) : ef.echo(0.5, 0.25, 0.4);"
    },
    "ef.reverseEchoN": {
      "prefix": "ef",
      "name": "reverseEchoN",
      "full_name": "ef.reverseEchoN",
      "args": [
        "N",
        "delay"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Reverse echo effect.",
      "param_docs": {
        "N": "Number of output channels desired (1 or more), a constant numerical expression",
        "delay": "echo delay (integer power of 2)"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nreverseEchoN_test = os.osc(440) : ef.reverseEchoN(2, 32);"
    },
    "ef.reverseDelayRamped": {
      "prefix": "ef",
      "name": "reverseDelayRamped",
      "full_name": "ef.reverseDelayRamped",
      "args": [
        "delay",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Reverse delay with amplitude ramp.",
      "param_docs": {
        "delay": "echo delay (integer power of 2)",
        "phase": "float between 0 and 1 giving ramp delay phase*delay"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nreverseDelayRamped_test = os.osc(440) : ef.reverseDelayRamped(32, 0.6);"
    },
    "ef.uniformPanToStereo": {
      "prefix": "ef",
      "name": "uniformPanToStereo",
      "full_name": "ef.uniformPanToStereo",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Pan nChans channels to the stereo field, spread uniformly left to right.",
      "param_docs": {
        "N": "Number of input channels to pan down to stereo, a constant numerical expression"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nuniformPanToStereo_test = os.osc(440), os.osc(550), os.osc(660) : ef.uniformPanToStereo(3);"
    },
    "ef.tapeStop": {
      "prefix": "ef",
      "name": "tapeStop",
      "full_name": "ef.tapeStop",
      "args": [
        "2",
        "LAGRANGE_ORDER",
        "MAX_TIME_SAMP",
        "//               crossfade",
        "gainAlpha",
        "stopAlpha",
        "stopTime",
        "stop"
      ],
      "arg_count": 8,
      "inputs": 2,
      "outputs": 3,
      "description": "A tape-stop effect, like putting a finger on a vinyl record player.",
      "param_docs": {
        "C": "The number of input and output channels.",
        "LAGRANGE_ORDER": "The order of the Lagrange interpolation on the delay line. [2-3] recommended.",
        "MAX_TIME_SAMP": "Maximum stop time in samples",
        "crossfade": "A crossfade in samples to apply when resuming normal playback. Crossfade is not applied during the enabling of the tape-stop.",
        "gainAlpha": "During the tape-stop, lower alpha stays louder longer. Safe values are in the range [.01,2].",
        "stopAlpha": "`stopAlpha==1` represents a linear deceleration (constant force). `stopAlpha<1` represents an initially weaker, then stronger force. `stopAlpha>1` represents an initially stronger, then weaker force. Safe values are in the range [.01,2].",
        "stopTime": "Desired duration of the stop time, in samples.",
        "stop": "When `stop` becomes positive, the tape-stop effect will start. When `stop` becomes zero, normal audio will resume via crossfade."
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ntapeStop_test = os.osc(440), os.osc(441) : ef.tapeStop(2, 3, 44100, 128, 1.0, 1.0, 22050, button(\"stop\"));"
    },
    "ef.transpose": {
      "prefix": "ef",
      "name": "transpose",
      "full_name": "ef.transpose",
      "args": [
        "w",
        "x",
        "s"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "A simple pitch shifter based on 2 delay lines. `transpose` is a standard Faust function.",
      "param_docs": {
        "w": "the window length (samples)",
        "x": "crossfade duration duration (samples)",
        "s": "shift (semitones)"
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\ntranspose_test = os.osc(440) : ef.transpose(1024, 512, 7);"
    },
    "ef.softclipQuadratic": {
      "prefix": "ef",
      "name": "softclipQuadratic",
      "full_name": "ef.softclipQuadratic",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Quadratic softclip nonlinearity.",
      "param_docs": {},
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nsoftclipQuadratic_test = os.osc(440) : ef.softclipQuadratic;"
    },
    "ef.wavefold": {
      "prefix": "ef",
      "name": "wavefold",
      "full_name": "ef.wavefold",
      "args": [
        "width"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Wavefolding nonlinearity.",
      "param_docs": {
        "width": "The width of the folded section [0..1] (float)."
      },
      "example": "ef = library(\"misceffects.lib\");\nos = library(\"oscillators.lib\");\nwavefold_test = os.osc(440) : ef.wavefold(0.5);"
    },
    "ef.mixingEnv.phaseLoop": {
      "prefix": "ef",
      "name": "mixingEnv.phaseLoop",
      "full_name": "ef.mixingEnv.phaseLoop",
      "args": [
        "N",
        "m",
        "i"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv phaseLoop filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.phaseClamp": {
      "prefix": "ef",
      "name": "mixingEnv.phaseClamp",
      "full_name": "ef.mixingEnv.phaseClamp",
      "args": [
        "N",
        "m",
        "i"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv phaseClamp filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.weightsPowerLoop": {
      "prefix": "ef",
      "name": "mixingEnv.weightsPowerLoop",
      "full_name": "ef.mixingEnv.weightsPowerLoop",
      "args": [
        "N",
        "m"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv weightsPowerLoop filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.weightsLinearLoop": {
      "prefix": "ef",
      "name": "mixingEnv.weightsLinearLoop",
      "full_name": "ef.mixingEnv.weightsLinearLoop",
      "args": [
        "N",
        "m"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv weightsLinearLoop filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.weightsPowerClamp": {
      "prefix": "ef",
      "name": "mixingEnv.weightsPowerClamp",
      "full_name": "ef.mixingEnv.weightsPowerClamp",
      "args": [
        "N",
        "m"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv weightsPowerClamp filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.weightsLinearClamp": {
      "prefix": "ef",
      "name": "mixingEnv.weightsLinearClamp",
      "full_name": "ef.mixingEnv.weightsLinearClamp",
      "args": [
        "N",
        "m"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv weightsLinearClamp filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.dryWetMixer": {
      "prefix": "ef",
      "name": "mixingEnv.dryWetMixer",
      "full_name": "ef.mixingEnv.dryWetMixer",
      "args": [
        "wetAmount",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv dryWetMixer filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.dryWetMixerConstantPower": {
      "prefix": "ef",
      "name": "mixingEnv.dryWetMixerConstantPower",
      "full_name": "ef.mixingEnv.dryWetMixerConstantPower",
      "args": [
        "wetAmount",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv dryWetMixerConstantPower filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.mixLinearClamp": {
      "prefix": "ef",
      "name": "mixingEnv.mixLinearClamp",
      "full_name": "ef.mixingEnv.mixLinearClamp",
      "args": [
        "N",
        "C",
        "m"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv mixLinearClamp filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.mixLinearLoop": {
      "prefix": "ef",
      "name": "mixingEnv.mixLinearLoop",
      "full_name": "ef.mixingEnv.mixLinearLoop",
      "args": [
        "N",
        "C",
        "m"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv mixLinearLoop filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.mixPowerClamp": {
      "prefix": "ef",
      "name": "mixingEnv.mixPowerClamp",
      "full_name": "ef.mixingEnv.mixPowerClamp",
      "args": [
        "N",
        "C",
        "m"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv mixPowerClamp filter",
      "param_docs": {},
      "example": ""
    },
    "ef.mixingEnv.mixPowerLoop": {
      "prefix": "ef",
      "name": "mixingEnv.mixPowerLoop",
      "full_name": "ef.mixingEnv.mixPowerLoop",
      "args": [
        "N",
        "C",
        "m"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "mixingEnv mixPowerLoop filter",
      "param_docs": {},
      "example": ""
    },
    "ef.nonlinearityEnv.makeOdd": {
      "prefix": "ef",
      "name": "nonlinearityEnv.makeOdd",
      "full_name": "ef.nonlinearityEnv.makeOdd",
      "args": [
        "f",
        "x"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "nonlinearityEnv makeOdd filter",
      "param_docs": {},
      "example": ""
    },
    "ef.nonlinearityEnv.wavefold": {
      "prefix": "ef",
      "name": "nonlinearityEnv.wavefold",
      "full_name": "ef.nonlinearityEnv.wavefold",
      "args": [
        "width",
        "x"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "nonlinearityEnv wavefold filter",
      "param_docs": {},
      "example": ""
    },
    "mo.shockTrigger": {
      "prefix": "mo",
      "name": "shockTrigger",
      "full_name": "mo.shockTrigger",
      "args": [
        "hpHz",
        "threshold",
        "debounceMs",
        "sig"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Debounced shock trigger from an accelerometer axis.",
      "param_docs": {
        "hpHz": "high-pass frequency (Hz) used to isolate shocks ( > 0 )",
        "threshold": "trigger threshold applied after high-pass (normalized g units)",
        "debounceMs": "time in milliseconds to hold the trigger high (>= 0)",
        "sig": "accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "shockTrigger_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\naccX = os.pulsetrain(4) * 2;\n} : mo.shockTrigger(50, 0.5, 50);"
    },
    "mo.inclinometer": {
      "prefix": "mo",
      "name": "inclinometer",
      "full_name": "mo.inclinometer",
      "args": [
        "lpHz",
        "sig"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Low-pass inclinometer for a single axis.",
      "param_docs": {
        "lpHz": "low-pass frequency (Hz) ( > 0 )",
        "sig": "accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "inclinometer_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.inclinometer(2, os.sawtooth(1));"
    },
    "mo.inclineBalance": {
      "prefix": "mo",
      "name": "inclineBalance",
      "full_name": "mo.inclineBalance",
      "args": [
        "lpHz",
        "posSig",
        "negSig"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Balance between positive and negative inclination on the same axis.",
      "param_docs": {
        "lpHz": "low-pass frequency (Hz) ( > 0 )",
        "posSig": "positive-facing accelerometer axis signal (normalized, typically [-1, 1])",
        "negSig": "negative-facing accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "inclineBalance_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\naccPosX = os.sawtooth(0.1) * 0.5 + 0.5;\naccNegX = accPosX * (-1);\n} : mo.inclineBalance(1, accPosX, accNegX);"
    },
    "mo.inclineSymmetric": {
      "prefix": "mo",
      "name": "inclineSymmetric",
      "full_name": "mo.inclineSymmetric",
      "args": [
        "lpHz",
        "posSig",
        "negSig"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Symmetric gravity comparison (0->1->0) from positive and negative axes.",
      "param_docs": {
        "lpHz": "low-pass frequency (Hz) ( > 0 )",
        "posSig": "positive-facing accelerometer axis signal (normalized, typically [-1, 1])",
        "negSig": "negative-facing accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "inclineSymmetric_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\naccPosX = os.triangle(0.2) * 0.5 + 0.5;\naccNegX = accPosX * (-1);\n} : mo.inclineSymmetric(2, accPosX, accNegX);"
    },
    "mo.projectedGravity": {
      "prefix": "mo",
      "name": "projectedGravity",
      "full_name": "mo.projectedGravity",
      "args": [
        "lpHz",
        "offset",
        "sig"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Projects an axis onto gravity with optional dead-zone offset.",
      "param_docs": {
        "lpHz": "low-pass frequency (Hz) ( > 0 )",
        "offset": "dead-zone offset applied after projection (0..0.33). Magnitudes below",
        "sig": "accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "projectedGravity_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.projectedGravity(2, 0.05, os.triangle(0.1));"
    },
    "mo.motionEnvelope": {
      "prefix": "mo",
      "name": "motionEnvelope",
      "full_name": "mo.motionEnvelope",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Base thresholded AR envelope used by the accelerometer and gyroscope helpers.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "input signal (normalized)"
      },
      "example": ""
    },
    "mo.envelopeAbs": {
      "prefix": "mo",
      "name": "envelopeAbs",
      "full_name": "mo.envelopeAbs",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope on the absolute value of a signal (responds to both polarities).",
      "param_docs": {
        "sig": "input signal"
      },
      "example": ""
    },
    "mo.envelopePos": {
      "prefix": "mo",
      "name": "envelopePos",
      "full_name": "mo.envelopePos",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope for the positive portion of a signal.",
      "param_docs": {
        "sig": "input signal"
      },
      "example": ""
    },
    "mo.envelopeNeg": {
      "prefix": "mo",
      "name": "envelopeNeg",
      "full_name": "mo.envelopeNeg",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope for the negative portion of a signal (by flipping its polarity first).",
      "param_docs": {
        "sig": "input signal"
      },
      "example": ""
    },
    "mo.pita3": {
      "prefix": "mo",
      "name": "pita3",
      "full_name": "mo.pita3",
      "args": [
        "x",
        "y",
        "z"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "3D magnitude helper `sqrt(x^2 + y^2 + z^2)` used for total envelopes.",
      "param_docs": {},
      "example": ""
    },
    "mo.totalEnvelope": {
      "prefix": "mo",
      "name": "totalEnvelope",
      "full_name": "mo.totalEnvelope",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "x",
        "y",
        "z"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Magnitude-based envelope across three axes.",
      "param_docs": {},
      "example": ""
    },
    "mo.accelEnvelopeAbs": {
      "prefix": "mo",
      "name": "accelEnvelopeAbs",
      "full_name": "mo.accelEnvelopeAbs",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower on the absolute value of an accelerometer axis.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "accelEnvelopeAbs_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\naccX = os.sawtooth(0.5);\n} : mo.accelEnvelopeAbs(0.1, 1.5, 5, 20, accX);"
    },
    "mo.accelEnvelopePos": {
      "prefix": "mo",
      "name": "accelEnvelopePos",
      "full_name": "mo.accelEnvelopePos",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for positive acceleration on one axis.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "accelEnvelopePos_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.accelEnvelopePos(0.05, 1, 5, 5, os.triangle(0.25));"
    },
    "mo.accelEnvelopeNeg": {
      "prefix": "mo",
      "name": "accelEnvelopeNeg",
      "full_name": "mo.accelEnvelopeNeg",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for negative acceleration on one axis.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "accelerometer axis signal (normalized, typically [-1, 1])"
      },
      "example": "accelEnvelopeNeg_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.accelEnvelopeNeg(0.05, 1, 5, 5, os.triangle(0.25));"
    },
    "mo.totalAccel": {
      "prefix": "mo",
      "name": "totalAccel",
      "full_name": "mo.totalAccel",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "ax",
        "ay",
        "az"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Total acceleration magnitude with thresholding and envelope.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "ax": "accelerometer X axis (normalized, typically [-1, 1])",
        "ay": "accelerometer Y axis (normalized, typically [-1, 1])",
        "az": "accelerometer Z axis (normalized, typically [-1, 1])"
      },
      "example": "totalAccel_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\nax = os.sawtooth(0.2) * 0.2;\nay = os.triangle(0.15) * 0.1;\naz = os.sawtooth(0.12) * 0.3;\n} : mo.totalAccel(0.05, 1.2, 8, 12, ax, ay, az);"
    },
    "mo.gyroEnvelopeAbs": {
      "prefix": "mo",
      "name": "gyroEnvelopeAbs",
      "full_name": "mo.gyroEnvelopeAbs",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower on the absolute value of a gyroscope axis.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "gyroscope axis signal (normalized rad/s range)"
      },
      "example": "gyroEnvelopeAbs_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.gyroEnvelopeAbs(0.02, 0.9, 25, 30, os.sawtooth(0.5));"
    },
    "mo.gyroEnvelopePos": {
      "prefix": "mo",
      "name": "gyroEnvelopePos",
      "full_name": "mo.gyroEnvelopePos",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for positive gyroscope rotation on one axis.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "gyroscope axis signal (normalized rad/s range)"
      },
      "example": "gyroEnvelopePos_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.gyroEnvelopePos(0.02, 0.9, 25, 30, os.triangle(0.5));"
    },
    "mo.gyroEnvelopeNeg": {
      "prefix": "mo",
      "name": "gyroEnvelopeNeg",
      "full_name": "mo.gyroEnvelopeNeg",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "sig"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Envelope follower for negative gyroscope rotation on one axis.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "sig": "gyroscope axis signal (normalized rad/s range)"
      },
      "example": "gyroEnvelopeNeg_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : mo.gyroEnvelopeNeg(0.02, 0.9, 25, 30, os.triangle(0.5));"
    },
    "mo.totalGyro": {
      "prefix": "mo",
      "name": "totalGyro",
      "full_name": "mo.totalGyro",
      "args": [
        "thr",
        "gain",
        "envUpMs",
        "envDownMs",
        "gx",
        "gy",
        "gz"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Total gyroscope magnitude with thresholding and envelope.",
      "param_docs": {
        "thr": "threshold subtracted before detection (normalized)",
        "gain": "linear gain applied after thresholding",
        "envUpMs": "attack time in milliseconds (>= 0)",
        "envDownMs": "release time in milliseconds (>= 0)",
        "gx": "gyroscope X axis (normalized rad/s range)",
        "gy": "gyroscope Y axis (normalized rad/s range)",
        "gz": "gyroscope Z axis (normalized rad/s range)"
      },
      "example": "totalGyro_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\ngx = os.sawtooth(0.2) * 0.2;\ngy = os.triangle(0.15) * 0.1;\ngz = os.sawtooth(0.12) * 0.3;\n} : mo.totalGyro(0.01, 0.9, 25, 30, gx, gy, gz);"
    },
    "mo.orientationWeight": {
      "prefix": "mo",
      "name": "orientationWeight",
      "full_name": "mo.orientationWeight",
      "args": [
        "targetX",
        "targetY",
        "targetZ",
        "shape",
        "xs",
        "ys",
        "zs",
        "smoothMs"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 1,
      "description": "Weighting of a 3D vector toward a target axis with shape and smoothing.",
      "param_docs": {
        "targetX": "target X coordinate (-1..1)",
        "targetY": "target Y coordinate (-1..1)",
        "targetZ": "target Z coordinate (-1..1)",
        "shape": "scaling applied to the distance (>= 0, larger tightens the lobe)",
        "xs": "current X coordinate (normalized)",
        "ys": "current Y coordinate (normalized)",
        "zs": "current Z coordinate (normalized)",
        "smoothMs": "smoothing time in milliseconds (>= 0)"
      },
      "example": "orientationWeight_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\nx = os.triangle(0.1);\ny = os.sawtooth(0.1);\nz = os.triangle(0.05);\n} : mo.orientationWeight(0, 1, 0, 1, x, y, z, 10);"
    },
    "mo.orientation6": {
      "prefix": "mo",
      "name": "orientation6",
      "full_name": "mo.orientation6",
      "args": [
        "xs",
        "ys",
        "zs",
        "//              shapeCour",
        "shapeRear",
        "shapeJardin",
        "shapeFront",
        "shapeDown",
        "shapeUp",
        "//              smoothMs"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "Weights toward the six device axes (Cour/stage left -X, Rear -Y, Jardin/stage right +X, Front +Y, Down -Z, Up +Z).",
      "param_docs": {
        "xs": "current X coordinate (normalized)",
        "ys": "current Y coordinate (normalized)",
        "zs": "current Z coordinate (normalized)",
        "shapeCour": "shape for Cour (-X)",
        "shapeRear": "shape for Rear (-Y)",
        "shapeJardin": "shape for Jardin (+X)",
        "shapeFront": "shape for Front (+Y)",
        "shapeDown": "shape for Down (-Z)",
        "shapeUp": "shape for Up (+Z)",
        "smoothMs": "smoothing time in milliseconds (>= 0)"
      },
      "example": "orientation6_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\nx = os.triangle(0.05);\ny = os.sawtooth(0.08);\nz = os.triangle(0.03);\n} : mo.orientation6(x, y, z, 1, 1, 1, 1, 1, 1, 10);"
    },
    "mo.scale": {
      "prefix": "mo",
      "name": "scale",
      "full_name": "mo.scale",
      "args": [
        "ilow",
        "ihigh",
        "olow",
        "ohigh"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Normalized scaler with input dead-zone and bounded output range.",
      "param_docs": {
        "ilow": "minimum input value before scaling starts (0..1)",
        "ihigh": "maximum input value before clamping (must be > ilow)",
        "olow": "minimum output value",
        "ohigh": "maximum output value"
      },
      "example": "scale_test =\nwith {\nmo = library(\"motion.lib\");\nos = library(\"oscillators.lib\");\n} : os.sawtooth(0.2) : mo.scale(0.2, 0.8, 0, 1);"
    },
    "no.noise": {
      "prefix": "no",
      "name": "noise",
      "full_name": "no.noise",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "White noise generator (outputs random number between -1 and 1). `noise` is a standard Faust function.",
      "param_docs": {},
      "example": "no = library(\"noises.lib\");\nnoise_test = no.noise;"
    },
    "no.multirandom": {
      "prefix": "no",
      "name": "multirandom",
      "full_name": "no.multirandom",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated random numbers in parallel.",
      "param_docs": {
        "N": "the number of decorrelated random numbers in parallel, a constant numerical expression"
      },
      "example": "no = library(\"noises.lib\");\nmultirandom_test = no.multirandom(4);"
    },
    "no.multinoise": {
      "prefix": "no",
      "name": "multinoise",
      "full_name": "no.multinoise",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated noises in parallel.",
      "param_docs": {
        "N": "the number of decorrelated random numbers in parallel, a constant numerical expression"
      },
      "example": "no = library(\"noises.lib\");\nmultinoise_test = no.multinoise(3);"
    },
    "no.noises": {
      "prefix": "no",
      "name": "noises",
      "full_name": "no.noises",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A convenient wrapper around multinoise.",
      "param_docs": {
        "N": "the number of decorrelated random numbers in parallel, a constant numerical expression",
        "i": "the selected random number (i in [0..N[)"
      },
      "example": "no = library(\"noises.lib\");\nnoises_test = no.noises(4, 2);"
    },
    "no.dnoise": {
      "prefix": "no",
      "name": "dnoise",
      "full_name": "no.dnoise",
      "args": [
        "t",
        "sx"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A deterministic noise burst with a dynamically adjustable seed, enabling consistent recall. Useful for noise variation sensitive applications like replicable/recallable percussion sounds and waveguide",
      "param_docs": {
        "t": "is a noise burst trigger",
        "sx": "defines the range of integer seed multipliers."
      },
      "example": "no = library(\"noises.lib\");\nba = library(\"basics.lib\");\ndnoise_test = (1 : ba.impulsify, 10.0) : no.dnoise;"
    },
    "no.randomseed": {
      "prefix": "no",
      "name": "randomseed",
      "full_name": "no.randomseed",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A random seed based on the foreign function `arc4random` (see man arc4random). Used in `rnoise`, `rmultirandom`, etc. to avoid having the same pseudo random sequence at each run.",
      "param_docs": {},
      "example": "no = library(\"noises.lib\");\nrandomseed_test = no.randomseed;"
    },
    "no.rnoise": {
      "prefix": "no",
      "name": "rnoise",
      "full_name": "no.rnoise",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "A randomized white noise generator (outputs random number between -1 and 1).",
      "param_docs": {},
      "example": "no = library(\"noises.lib\");\nrnoise_test = no.rnoise;"
    },
    "no.rmultirandom": {
      "prefix": "no",
      "name": "rmultirandom",
      "full_name": "no.rmultirandom",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated random numbers in parallel.",
      "param_docs": {
        "N": "the number of decorrelated random numbers in parallel, a constant numerical expression"
      },
      "example": "no = library(\"noises.lib\");\nrmultirandom_test = no.rmultirandom(4);"
    },
    "no.rmultinoise": {
      "prefix": "no",
      "name": "rmultinoise",
      "full_name": "no.rmultinoise",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates multiple decorrelated noises in parallel.",
      "param_docs": {
        "N": "the number of decorrelated random numbers in parallel, a constant numerical expression"
      },
      "example": "no = library(\"noises.lib\");\nrmultinoise_test = no.rmultinoise(3);"
    },
    "no.rnoises": {
      "prefix": "no",
      "name": "rnoises",
      "full_name": "no.rnoises",
      "args": [
        "N",
        "i"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A convenient wrapper around rmultinoise.",
      "param_docs": {
        "N": "the number of decorrelated random numbers in parallel",
        "i": "the selected random number (i in [0..N[)"
      },
      "example": "no = library(\"noises.lib\");\nrnoises_test = no.rnoises(4, 2);"
    },
    "no.pink_noise": {
      "prefix": "no",
      "name": "pink_noise",
      "full_name": "no.pink_noise",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Pink noise (1/f noise) generator (third-order approximation covering the audio band well). `pink_noise` is a standard Faust function.",
      "param_docs": {},
      "example": "no = library(\"noises.lib\");\npink_noise_test = no.pink_noise;"
    },
    "no.pink_noise_vm": {
      "prefix": "no",
      "name": "pink_noise_vm",
      "full_name": "no.pink_noise_vm",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Multi pink noise generator.",
      "param_docs": {
        "N": "number of latched white-noise processes to sum,"
      },
      "example": "no = library(\"noises.lib\");\npink_noise_vm_test = no.pink_noise_vm(4);"
    },
    "no.lfnoise": {
      "prefix": "no",
      "name": "lfnoise",
      "full_name": "no.lfnoise",
      "args": [
        "rate"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Low-frequency noise generators (Butterworth-filtered downsampled white noise).",
      "param_docs": {},
      "example": "no = library(\"noises.lib\");\nlfnoise0_test = no.lfnoise0(10.0);\nlfnoiseN_test = no.lfnoiseN(3, 10.0);\nlfnoise_test = no.lfnoise(10.0);"
    },
    "no.sparse_noise": {
      "prefix": "no",
      "name": "sparse_noise",
      "full_name": "no.sparse_noise",
      "args": [
        "f0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sparse noise generator.",
      "param_docs": {
        "f0": "average frequency of noise impulses per second"
      },
      "example": "no = library(\"noises.lib\");\nsparse_noise_test = no.sparse_noise(5.0);"
    },
    "no.velvet_noise_vm": {
      "prefix": "no",
      "name": "velvet_noise_vm",
      "full_name": "no.velvet_noise_vm",
      "args": [
        "amp",
        "f0"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Velvet noise generator.",
      "param_docs": {
        "amp": "amplitude of noise impulses (positive and negative)",
        "f0": "average frequency of noise impulses per second"
      },
      "example": "no = library(\"noises.lib\");\nvelvet_noise_test = no.velvet_noise(0.5, 5.0);"
    },
    "no.gnoise": {
      "prefix": "no",
      "name": "gnoise",
      "full_name": "no.gnoise",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Approximate zero-mean, unit-variance Gaussian white noise generator.",
      "param_docs": {
        "N": "number of uniform random numbers added to approximate Gaussian white noise"
      },
      "example": "no = library(\"noises.lib\");\ngnoise_test = no.gnoise(8);"
    },
    "no.colored_noise": {
      "prefix": "no",
      "name": "colored_noise",
      "full_name": "no.colored_noise",
      "args": [
        "N",
        "alpha"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Generates a colored noise signal with an arbitrary spectral roll-off factor (alpha) over the entire audible frequency range (20-20000 Hz). The output is normalized so that an equal RMS",
      "param_docs": {
        "N": "desired integer filter order (constant numerical expression)",
        "alpha": "slope of roll-off, between -1 and 1. -1 corresponds to"
      },
      "example": "no = library(\"noises.lib\");\ncolored_noise_test = no.colored_noise(4, 0.0);"
    },
    "os.sinwaveform": {
      "prefix": "os",
      "name": "sinwaveform",
      "full_name": "os.sinwaveform",
      "args": [
        "tablesize"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine waveform ready to use with a `rdtable`.",
      "param_docs": {
        "tablesize": "the table size"
      },
      "example": "os = library(\"oscillators.lib\");\nsinwaveform_test = os.sinwaveform(1024);"
    },
    "os.coswaveform": {
      "prefix": "os",
      "name": "coswaveform",
      "full_name": "os.coswaveform",
      "args": [
        "tablesize"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine waveform ready to use with a `rdtable`.",
      "param_docs": {
        "tablesize": "the table size"
      },
      "example": "os = library(\"oscillators.lib\");\ncoswaveform_test = os.coswaveform(1024);"
    },
    "os.phasor": {
      "prefix": "os",
      "name": "phasor",
      "full_name": "os.phasor",
      "args": [
        "tablesize",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple phasor to be used with a `rdtable`. `phasor` is a standard Faust function.",
      "param_docs": {
        "tablesize": "the table size",
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nphasor_test = os.phasor(1024, 440);"
    },
    "os.hs_phasor": {
      "prefix": "os",
      "name": "hs_phasor",
      "full_name": "os.hs_phasor",
      "args": [
        "tablesize",
        "freq",
        "reset"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Hardsyncing phasor to be used with a `rdtable`.",
      "param_docs": {
        "tablesize": "the table size",
        "freq": "the frequency in Hz",
        "reset": "a reset signal, reset phase to 0 when equal to 1"
      },
      "example": "os = library(\"oscillators.lib\");\nhs_phasor_test = os.hs_phasor(1024, 330, button(\"reset\"));"
    },
    "os.hsp_phasor": {
      "prefix": "os",
      "name": "hsp_phasor",
      "full_name": "os.hsp_phasor",
      "args": [
        "tablesize",
        "freq",
        "reset",
        "phase"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Hardsyncing phasor with selectable phase to be used with a `rdtable`.",
      "param_docs": {
        "tablesize": "the table size",
        "freq": "the frequency in Hz",
        "reset": "reset the oscillator to phase when equal to 1",
        "phase": "phase between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\nhsp_phasor_test = os.hsp_phasor(1024, 330, button(\"reset\"), 0.25);"
    },
    "os.oscsin": {
      "prefix": "os",
      "name": "oscsin",
      "full_name": "os.oscsin",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine wave oscillator. `oscsin` is a standard Faust function.",
      "param_docs": {
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscsin_test = os.oscsin(440);"
    },
    "os.hs_oscsin": {
      "prefix": "os",
      "name": "hs_oscsin",
      "full_name": "os.hs_oscsin",
      "args": [
        "freq",
        "reset"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Sin lookup table with hardsyncing phase.",
      "param_docs": {
        "freq": "the frequency in Hz",
        "reset": "reset the oscillator to 0 when equal to 1"
      },
      "example": "os = library(\"oscillators.lib\");\nhs_oscsin_test = os.hs_oscsin(440, button(\"reset\"));"
    },
    "os.osccos": {
      "prefix": "os",
      "name": "osccos",
      "full_name": "os.osccos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cosine wave oscillator.",
      "param_docs": {
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nosccos_test = os.osccos(440);"
    },
    "os.hs_osccos": {
      "prefix": "os",
      "name": "hs_osccos",
      "full_name": "os.hs_osccos",
      "args": [
        "freq",
        "reset"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cos lookup table with hardsyncing phase.",
      "param_docs": {
        "freq": "the frequency in Hz",
        "reset": "reset the oscillator to 0 when equal to 1"
      },
      "example": "os = library(\"oscillators.lib\");\nhs_osccos_test = os.hs_osccos(440, button(\"reset\"));"
    },
    "os.oscp": {
      "prefix": "os",
      "name": "oscp",
      "full_name": "os.oscp",
      "args": [
        "freq",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A sine wave generator with controllable phase.",
      "param_docs": {
        "freq": "the frequency in Hz",
        "phase": "the phase in radian"
      },
      "example": "os = library(\"oscillators.lib\");\nma = library(\"maths.lib\");\noscp_test = os.oscp(440, ma.PI/3);"
    },
    "os.osci": {
      "prefix": "os",
      "name": "osci",
      "full_name": "os.osci",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Interpolated phase sine wave oscillator.",
      "param_docs": {
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nosci_test = os.osci(440);"
    },
    "os.osc": {
      "prefix": "os",
      "name": "osc",
      "full_name": "os.osc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Default sine wave oscillator (same as [oscsin](#oscsin)). `osc` is a standard Faust function.",
      "param_docs": {
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nosc_test = os.osc(440);"
    },
    "os.m_oscsin": {
      "prefix": "os",
      "name": "m_oscsin",
      "full_name": "os.m_oscsin",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine wave oscillator based on the `sin` mathematical function.",
      "param_docs": {
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nm_oscsin_test = os.m_oscsin(440);"
    },
    "os.m_osccos": {
      "prefix": "os",
      "name": "m_osccos",
      "full_name": "os.m_osccos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sine wave oscillator based on the `cos` mathematical function.",
      "param_docs": {
        "freq": "the frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nm_osccos_test = os.m_osccos(440);"
    },
    "os.lf_imptrain": {
      "prefix": "os",
      "name": "lf_imptrain",
      "full_name": "os.lf_imptrain",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unit-amplitude low-frequency impulse train. `lf_imptrain` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_imptrain_test = os.lf_imptrain(3);"
    },
    "os.lf_pulsetrainpos": {
      "prefix": "os",
      "name": "lf_pulsetrainpos",
      "full_name": "os.lf_pulsetrainpos",
      "args": [
        "freq",
        "duty"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unit-amplitude nonnegative LF pulse train, duty cycle between 0 and 1.",
      "param_docs": {
        "freq": "frequency in Hz",
        "duty": "duty cycle between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_pulsetrainpos_test = os.lf_pulsetrainpos(3, 0.35);"
    },
    "os.lf_pulsetrain": {
      "prefix": "os",
      "name": "lf_pulsetrain",
      "full_name": "os.lf_pulsetrain",
      "args": [
        "freq",
        "duty"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unit-amplitude zero-mean LF pulse train, duty cycle between 0 and 1.",
      "param_docs": {
        "freq": "frequency in Hz",
        "duty": "duty cycle between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_pulsetrain_test = os.lf_pulsetrain(3, 0.35);"
    },
    "os.lf_squarewavepos": {
      "prefix": "os",
      "name": "lf_squarewavepos",
      "full_name": "os.lf_squarewavepos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Positive LF square wave in [0,1]",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_squarewavepos_test = os.lf_squarewavepos(3);"
    },
    "os.lf_squarewave": {
      "prefix": "os",
      "name": "lf_squarewave",
      "full_name": "os.lf_squarewave",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Zero-mean unit-amplitude LF square wave. `lf_squarewave` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_squarewave_test = os.lf_squarewave(3);"
    },
    "os.lf_trianglepos": {
      "prefix": "os",
      "name": "lf_trianglepos",
      "full_name": "os.lf_trianglepos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Positive unit-amplitude LF positive triangle wave.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_trianglepos_test = os.lf_trianglepos(3);"
    },
    "os.lf_triangle": {
      "prefix": "os",
      "name": "lf_triangle",
      "full_name": "os.lf_triangle",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Zero-mean unit-amplitude LF triangle wave. `lf_triangle` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_triangle_test = os.lf_triangle(3);"
    },
    "os.lf_rawsaw": {
      "prefix": "os",
      "name": "lf_rawsaw",
      "full_name": "os.lf_rawsaw",
      "args": [
        "periodsamps"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and period in samples.",
      "param_docs": {
        "periodsamps": "number of periods per samples"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_rawsaw_test = os.lf_rawsaw(128);"
    },
    "os.lf_sawpos": {
      "prefix": "os",
      "name": "lf_sawpos",
      "full_name": "os.lf_sawpos",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_sawpos_test = os.lf_sawpos(3);"
    },
    "os.lf_sawpos_phase": {
      "prefix": "os",
      "name": "lf_sawpos_phase",
      "full_name": "os.lf_sawpos_phase",
      "args": [
        "freq",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1 with phase control.",
      "param_docs": {
        "freq": "frequency in Hz",
        "phase": "phase between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_sawpos_phase_test = os.lf_sawpos_phase(3, 0.25);"
    },
    "os.lf_sawpos_reset": {
      "prefix": "os",
      "name": "lf_sawpos_reset",
      "full_name": "os.lf_sawpos_reset",
      "args": [
        "freq",
        "reset"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1 with reset.",
      "param_docs": {
        "freq": "frequency in Hz",
        "reset": "reset the oscillator to 0 when equal to 1"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_sawpos_reset_test = os.lf_sawpos_reset(3, button(\"reset\"));"
    },
    "os.lf_sawpos_phase_reset": {
      "prefix": "os",
      "name": "lf_sawpos_phase_reset",
      "full_name": "os.lf_sawpos_phase_reset",
      "args": [
        "freq",
        "phase",
        "reset"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between 0 and 1 with phase control and reset.",
      "param_docs": {
        "freq": "frequency in Hz",
        "phase": "phase between 0 and 1",
        "reset": "reset the oscillator to phase when equal to 1"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_sawpos_phase_reset_test = os.lf_sawpos_phase_reset(3, 0.75, button(\"reset\"));"
    },
    "os.lf_saw": {
      "prefix": "os",
      "name": "lf_saw",
      "full_name": "os.lf_saw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple sawtooth waveform oscillator between -1 and 1. `lf_saw` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nlf_saw_test = os.lf_saw(3);"
    },
    "os.sawN": {
      "prefix": "os",
      "name": "sawN",
      "full_name": "os.sawN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator using Nth-order polynomial transitions to reduce aliasing.",
      "param_docs": {
        "N": "polynomial order, a constant numerical expression between 1 and 4",
        "freq": "frequency in Hz",
        "phase": "phase between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\nsawN_test = os.sawN(3, 440);"
    },
    "os.sawNp": {
      "prefix": "os",
      "name": "sawNp",
      "full_name": "os.sawNp",
      "args": [
        "N",
        "freq",
        "phase"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as `(os.)sawN` but with a controllable waveform phase.",
      "param_docs": {},
      "example": "os = library(\"oscillators.lib\");\nsawNp_test = os.sawNp(3, 330, 0.5);"
    },
    "os.freq": {
      "prefix": "os",
      "name": "freq",
      "full_name": "os.freq",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator with Order 2 or 4 Droop Correction Filtering.",
      "param_docs": {
        "N": "polynomial order, a constant numerical expression",
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nsaw2f2_test = os.saw2f2(220);\nsaw2f4_test = os.saw2f4(220);"
    },
    "os.saw2ptr": {
      "prefix": "os",
      "name": "saw2ptr",
      "full_name": "os.saw2ptr",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator using Polynomial Transition Regions (PTR) for order 2.",
      "param_docs": {},
      "example": "os = library(\"oscillators.lib\");\nsaw2ptr_test = os.saw2ptr(220);"
    },
    "os.saw2dpw": {
      "prefix": "os",
      "name": "saw2dpw",
      "full_name": "os.saw2dpw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-Suppressed Sawtooth Audio-Frequency Oscillator using the Differentiated Polynomial Waveform (DWP) method.",
      "param_docs": {},
      "example": "os = library(\"oscillators.lib\");\nsaw2dpw_test = os.saw2dpw(220);"
    },
    "os.sawtooth": {
      "prefix": "os",
      "name": "sawtooth",
      "full_name": "os.sawtooth",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed aliasing-suppressed sawtooth oscillator, presently defined as `saw2`. `sawtooth` is a standard Faust function.",
      "param_docs": {},
      "example": "os = library(\"oscillators.lib\");\nsawtooth_test = os.sawtooth(220);"
    },
    "os.impulse": {
      "prefix": "os",
      "name": "impulse",
      "full_name": "os.impulse",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "One-time impulse generated when the Faust process is started. `impulse` is a standard Faust function.",
      "param_docs": {},
      "example": "os = library(\"oscillators.lib\");\nimpulse_test = os.impulse;"
    },
    "os.pulsetrainN": {
      "prefix": "os",
      "name": "pulsetrainN",
      "full_name": "os.pulsetrainN",
      "args": [
        "N",
        "freq",
        "duty"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed pulse train oscillator.",
      "param_docs": {
        "N": "order, as a constant numerical expression",
        "freq": "frequency in Hz",
        "duty": "duty cycle between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\npulsetrainN_test = os.pulsetrainN(3, 220, 0.25);"
    },
    "os.pulsetrain": {
      "prefix": "os",
      "name": "pulsetrain",
      "full_name": "os.pulsetrain",
      "args": [
        "freq",
        "duty"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed pulse train oscillator. Based on `pulsetrainN(2)`. `pulsetrain` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz",
        "duty": "duty cycle between 0 and 1"
      },
      "example": "os = library(\"oscillators.lib\");\npulsetrain_test = os.pulsetrain(220, 0.25);"
    },
    "os.squareN": {
      "prefix": "os",
      "name": "squareN",
      "full_name": "os.squareN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed square wave oscillator.",
      "param_docs": {
        "N": "order, as a constant numerical expression",
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nsquareN_test = os.squareN(3, 220);"
    },
    "os.square": {
      "prefix": "os",
      "name": "square",
      "full_name": "os.square",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed square wave oscillator. Based on `squareN(2)`. `square` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nsquare_test = os.square(220);"
    },
    "os.imptrainN": {
      "prefix": "os",
      "name": "imptrainN",
      "full_name": "os.imptrainN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed impulse train generator.",
      "param_docs": {
        "N": "order, as a constant numerical expression",
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nimptrainN_test = os.imptrainN(4, 220);"
    },
    "os.imptrain": {
      "prefix": "os",
      "name": "imptrain",
      "full_name": "os.imptrain",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed impulse train generator. Based on `imptrainN(2)`. `imptrain` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\nimptrain_test = os.imptrain(220);"
    },
    "os.triangleN": {
      "prefix": "os",
      "name": "triangleN",
      "full_name": "os.triangleN",
      "args": [
        "N",
        "freq"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed triangle wave oscillator.",
      "param_docs": {
        "N": "order, as a constant numerical expression",
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\ntriangleN_test = os.triangleN(3, 220);"
    },
    "os.triangle": {
      "prefix": "os",
      "name": "triangle",
      "full_name": "os.triangle",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Alias-suppressed triangle wave oscillator. Based on `triangleN(2)`. `triangle` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\ntriangle_test = os.triangle(220);"
    },
    "os.oscb": {
      "prefix": "os",
      "name": "oscb",
      "full_name": "os.oscb",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the biquad.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscb_test = os.oscb(440);\noscrq_test = os.oscrq(440);\noscrs_test = os.oscrs(440);\noscrc_test = os.oscrc(440);\noscs_test = os.oscs(440);"
    },
    "os.oscrq": {
      "prefix": "os",
      "name": "oscrq",
      "full_name": "os.oscrq",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Sinusoidal (sine and cosine) oscillator based on 2D vector rotation, = undamped \"coupled-form\" resonator = lossless 2nd-order normalized ladder filter.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscrq_test = os.oscrq(440);"
    },
    "os.oscrs": {
      "prefix": "os",
      "name": "oscrs",
      "full_name": "os.oscrs",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal (sine) oscillator based on 2D vector rotation, = undamped \"coupled-form\" resonator = lossless 2nd-order normalized ladder filter.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscrs_test = os.oscrs(440);"
    },
    "os.oscrc": {
      "prefix": "os",
      "name": "oscrc",
      "full_name": "os.oscrc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal (cosine) oscillator based on 2D vector rotation, = undamped \"coupled-form\" resonator = lossless 2nd-order normalized ladder filter.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscrc_test = os.oscrc(440);"
    },
    "os.oscs": {
      "prefix": "os",
      "name": "oscs",
      "full_name": "os.oscs",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the state variable filter = undamped \"modified-coupled-form\" resonator = \"magic circle\" algorithm used in graphics.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscs_test = os.oscs(440);"
    },
    "os.quadosc": {
      "prefix": "os",
      "name": "quadosc",
      "full_name": "os.quadosc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Quadrature (cosine and sine) oscillator based on QuadOsc by Martin Vicanek.",
      "param_docs": {},
      "example": "os = library(\"oscillators.lib\");\nquadosc_test = os.quadosc(440);"
    },
    "os.sidebands": {
      "prefix": "os",
      "name": "sidebands",
      "full_name": "os.sidebands",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Adds harmonics to quad oscillator.",
      "param_docs": {
        "vs": "list of amplitudes"
      },
      "example": "os = library(\"oscillators.lib\");\nsidebands_test = os.quadosc(110) : os.sidebands((1, 0.5, 0.25));"
    },
    "os.sidebands_list": {
      "prefix": "os",
      "name": "sidebands_list",
      "full_name": "os.sidebands_list",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates the list of complex harmonics from quad oscillator.",
      "param_docs": {
        "N": "number of harmonics, compile time constant > 1"
      },
      "example": "os = library(\"oscillators.lib\");\nsidebands_list_test = os.quadosc(110) : os.sidebands_list(3);"
    },
    "os.dsf": {
      "prefix": "os",
      "name": "dsf",
      "full_name": "os.dsf",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "An environment with sine/cosine oscsillators with exponentially decaying harmonics based on direct summation formula.",
      "param_docs": {
        "f0": "base frequency",
        "df": "step frequency",
        "a": "decaying factor != 1",
        "n": "total number of harmonics (`osccN/oscsN` only)"
      },
      "example": "os = library(\"oscillators.lib\");\ndsf_oscc_test = os.dsf.oscc(220, 110, 0.6);\ndsf_oscs_test = os.dsf.oscs(220, 110, 0.6);\ndsf_osccN_test = os.dsf.osccN(220, 110, 0.6, 4);\ndsf_oscsN_test = os.dsf.oscsN(220, 110, 0.6, 4);\ndsf_osccNq_test = os.dsf.osccNq(220, 110, 0.6);\ndsf_oscsNq_test = os.dsf.oscsNq(220, 110, 0.6);"
    },
    "os.oscwc": {
      "prefix": "os",
      "name": "oscwc",
      "full_name": "os.oscwc",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude cosine oscillator.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscwc_test = os.oscwc(440);"
    },
    "os.oscws": {
      "prefix": "os",
      "name": "oscws",
      "full_name": "os.oscws",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude sine oscillator.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscws_test = os.oscws(440);"
    },
    "os.oscq": {
      "prefix": "os",
      "name": "oscq",
      "full_name": "os.oscq",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude cosine and sine (quadrature) oscillator.",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscq_test = os.oscq(440);"
    },
    "os.oscw": {
      "prefix": "os",
      "name": "oscw",
      "full_name": "os.oscw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude cosine oscillator (default).",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\noscw_test = os.oscw(440);"
    },
    "os.CZsaw": {
      "prefix": "os",
      "name": "CZsaw",
      "full_name": "os.CZsaw",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ saw oscillator. `CZsaw` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = saw-wave"
      },
      "example": "os = library(\"oscillators.lib\");\nCZsaw_test = os.CZsaw(os.lf_sawpos(110), 0.5);"
    },
    "os.CZsawP": {
      "prefix": "os",
      "name": "CZsawP",
      "full_name": "os.CZsawP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ saw oscillator, with it's phase aligned to `fund:sin`. `CZsawP` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = saw-wave"
      },
      "example": "os = library(\"oscillators.lib\");\nCZsawP_test = os.CZsawP(os.lf_sawpos(110), 0.5);"
    },
    "os.CZsquare": {
      "prefix": "os",
      "name": "CZsquare",
      "full_name": "os.CZsquare",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ square oscillator `CZsquare` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = square-wave"
      },
      "example": "os = library(\"oscillators.lib\");\nCZsquare_test = os.CZsquare(os.lf_sawpos(110), 0.5);"
    },
    "os.CZsquareP": {
      "prefix": "os",
      "name": "CZsquareP",
      "full_name": "os.CZsquareP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ square oscillator, with it's phase aligned to `fund:sin`. `CZsquareP` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = square-wave"
      },
      "example": "os = library(\"oscillators.lib\");\nCZsquareP_test = os.CZsquareP(os.lf_sawpos(110), 0.5);"
    },
    "os.CZpulse": {
      "prefix": "os",
      "name": "CZpulse",
      "full_name": "os.CZpulse",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ pulse oscillator. `CZpulse` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 gives a sine-wave, 1 is closer to a pulse"
      },
      "example": "os = library(\"oscillators.lib\");\nCZpulse_test = os.CZpulse(os.lf_sawpos(110), 0.5);"
    },
    "os.CZpulseP": {
      "prefix": "os",
      "name": "CZpulseP",
      "full_name": "os.CZpulseP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ pulse oscillator, with it's phase aligned to `fund:sin`. `CZpulseP` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 gives a sine-wave, 1 is closer to a pulse"
      },
      "example": "os = library(\"oscillators.lib\");\nCZpulseP_test = os.CZpulseP(os.lf_sawpos(110), 0.5);"
    },
    "os.CZsinePulse": {
      "prefix": "os",
      "name": "CZsinePulse",
      "full_name": "os.CZsinePulse",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ sine/pulse oscillator. `CZsinePulse` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 gives a sine-wave, 1 is a sine minus a pulse"
      },
      "example": "os = library(\"oscillators.lib\");\nCZsinePulse_test = os.CZsinePulse(os.lf_sawpos(110), 0.5);"
    },
    "os.CZsinePulseP": {
      "prefix": "os",
      "name": "CZsinePulseP",
      "full_name": "os.CZsinePulseP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ sine/pulse oscillator, with it's phase aligned to `fund:sin`. `CZsinePulseP` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 gives a sine-wave, 1 is a sine minus a pulse"
      },
      "example": "os = library(\"oscillators.lib\");\nCZsinePulseP_test = os.CZsinePulseP(os.lf_sawpos(110), 0.5);"
    },
    "os.CZhalfSine": {
      "prefix": "os",
      "name": "CZhalfSine",
      "full_name": "os.CZhalfSine",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ half sine oscillator. `CZhalfSine` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 gives a sine-wave, 1 is somewhere between a saw and a square"
      },
      "example": "os = library(\"oscillators.lib\");\nCZhalfSine_test = os.CZhalfSine(os.lf_sawpos(110), 0.5);"
    },
    "os.CZhalfSineP": {
      "prefix": "os",
      "name": "CZhalfSineP",
      "full_name": "os.CZhalfSineP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ half sine oscillator, with it's phase aligned to `fund:sin`. `CZhalfSineP` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "index": "the brightness of the oscillator, 0 gives a sine-wave, 1 is somewhere between a saw and a square"
      },
      "example": "os = library(\"oscillators.lib\");\nCZhalfSineP_test = os.CZhalfSineP(os.lf_sawpos(110), 0.5);"
    },
    "os.CZresSaw": {
      "prefix": "os",
      "name": "CZresSaw",
      "full_name": "os.CZresSaw",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ resonant sawtooth oscillator. `CZresSaw` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "res": "the frequency of resonance as a factor of the fundamental pitch."
      },
      "example": "os = library(\"oscillators.lib\");\nCZresSaw_test = os.CZresSaw(os.lf_sawpos(110), 2.5);"
    },
    "os.CZresTriangle": {
      "prefix": "os",
      "name": "CZresTriangle",
      "full_name": "os.CZresTriangle",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ resonant triangle oscillator. `CZresTriangle` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "res": "the frequency of resonance as a factor of the fundamental pitch."
      },
      "example": "os = library(\"oscillators.lib\");\nCZresTriangle_test = os.CZresTriangle(os.lf_sawpos(110), 2.5);"
    },
    "os.CZresTrap": {
      "prefix": "os",
      "name": "CZresTrap",
      "full_name": "os.CZresTrap",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator that mimics the Casio CZ resonant trapeze oscillator `CZresTrap` is a standard Faust function.",
      "param_docs": {
        "fund": "a saw-tooth waveform between 0 and 1 that the oscillator slaves to",
        "res": "the frequency of resonance as a factor of the fundamental pitch."
      },
      "example": "os = library(\"oscillators.lib\");\nCZresTrap_test = os.CZresTrap(os.lf_sawpos(110), 2.5);"
    },
    "os.polyblep": {
      "prefix": "os",
      "name": "polyblep",
      "full_name": "os.polyblep",
      "args": [
        "Q",
        "phase"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "PolyBLEP residual function, used for smoothing steps in the audio signal.",
      "param_docs": {
        "Q": "smoothing factor between 0 and 0.5. Determines how far from the ends of the phase interval the quadratic function is used.",
        "phase": "normalised phase (between 0 and 1)"
      },
      "example": "os = library(\"oscillators.lib\");\npolyblep_test = os.polyblep(0.2, os.lf_sawpos(220));"
    },
    "os.polyblep_saw": {
      "prefix": "os",
      "name": "polyblep_saw",
      "full_name": "os.polyblep_saw",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sawtooth oscillator with suppressed aliasing (using `polyblep`).",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\npolyblep_saw_test = os.polyblep_saw(220);"
    },
    "os.polyblep_square": {
      "prefix": "os",
      "name": "polyblep_square",
      "full_name": "os.polyblep_square",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Square wave oscillator with suppressed aliasing (using `polyblep`).",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\npolyblep_square_test = os.polyblep_square(220);"
    },
    "os.polyblep_triangle": {
      "prefix": "os",
      "name": "polyblep_triangle",
      "full_name": "os.polyblep_triangle",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Triangle wave oscillator with suppressed aliasing (using `polyblep`).",
      "param_docs": {
        "freq": "frequency in Hz"
      },
      "example": "os = library(\"oscillators.lib\");\npolyblep_triangle_test = os.polyblep_triangle(220);"
    },
    "os.dsf.Nq": {
      "prefix": "os",
      "name": "dsf.Nq",
      "full_name": "os.dsf.Nq",
      "args": [
        "f0",
        "df"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf Nq filter",
      "param_docs": {},
      "example": ""
    },
    "os.dsf.oscc": {
      "prefix": "os",
      "name": "dsf.oscc",
      "full_name": "os.dsf.oscc",
      "args": [
        "f0",
        "df",
        "a"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf oscc filter",
      "param_docs": {},
      "example": ""
    },
    "os.dsf.oscs": {
      "prefix": "os",
      "name": "dsf.oscs",
      "full_name": "os.dsf.oscs",
      "args": [
        "f0",
        "df",
        "a"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf oscs filter",
      "param_docs": {},
      "example": ""
    },
    "os.dsf.osccN": {
      "prefix": "os",
      "name": "dsf.osccN",
      "full_name": "os.dsf.osccN",
      "args": [
        "f0",
        "df",
        "a",
        "n"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf osccN filter",
      "param_docs": {},
      "example": ""
    },
    "os.dsf.oscsN": {
      "prefix": "os",
      "name": "dsf.oscsN",
      "full_name": "os.dsf.oscsN",
      "args": [
        "f0",
        "df",
        "a",
        "n"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf oscsN filter",
      "param_docs": {},
      "example": ""
    },
    "os.dsf.osccNq": {
      "prefix": "os",
      "name": "dsf.osccNq",
      "full_name": "os.dsf.osccNq",
      "args": [
        "f0",
        "df",
        "a"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf osccNq filter",
      "param_docs": {},
      "example": ""
    },
    "os.dsf.oscsNq": {
      "prefix": "os",
      "name": "dsf.oscsNq",
      "full_name": "os.dsf.oscsNq",
      "args": [
        "f0",
        "df",
        "a"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "dsf oscsNq filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.saw": {
      "prefix": "os",
      "name": "CZ.saw",
      "full_name": "os.CZ.saw",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ saw filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.sawP": {
      "prefix": "os",
      "name": "CZ.sawP",
      "full_name": "os.CZ.sawP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ sawP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.sawChooseP": {
      "prefix": "os",
      "name": "CZ.sawChooseP",
      "full_name": "os.CZ.sawChooseP",
      "args": [
        "fund",
        "index",
        "p"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ sawChooseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.square": {
      "prefix": "os",
      "name": "CZ.square",
      "full_name": "os.CZ.square",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ square filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.squareP": {
      "prefix": "os",
      "name": "CZ.squareP",
      "full_name": "os.CZ.squareP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ squareP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.squareChooseP": {
      "prefix": "os",
      "name": "CZ.squareChooseP",
      "full_name": "os.CZ.squareChooseP",
      "args": [
        "fund",
        "index",
        "p"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ squareChooseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.pulse": {
      "prefix": "os",
      "name": "CZ.pulse",
      "full_name": "os.CZ.pulse",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ pulse filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.pulseP": {
      "prefix": "os",
      "name": "CZ.pulseP",
      "full_name": "os.CZ.pulseP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ pulseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.pulseChooseP": {
      "prefix": "os",
      "name": "CZ.pulseChooseP",
      "full_name": "os.CZ.pulseChooseP",
      "args": [
        "fund",
        "index",
        "p"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ pulseChooseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.sinePulse": {
      "prefix": "os",
      "name": "CZ.sinePulse",
      "full_name": "os.CZ.sinePulse",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ sinePulse filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.sinePulseP": {
      "prefix": "os",
      "name": "CZ.sinePulseP",
      "full_name": "os.CZ.sinePulseP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ sinePulseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.sinePulseChooseP": {
      "prefix": "os",
      "name": "CZ.sinePulseChooseP",
      "full_name": "os.CZ.sinePulseChooseP",
      "args": [
        "fund",
        "index",
        "p"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ sinePulseChooseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.halfSine": {
      "prefix": "os",
      "name": "CZ.halfSine",
      "full_name": "os.CZ.halfSine",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ halfSine filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.halfSineP": {
      "prefix": "os",
      "name": "CZ.halfSineP",
      "full_name": "os.CZ.halfSineP",
      "args": [
        "fund",
        "index"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ halfSineP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.halfSineChooseP": {
      "prefix": "os",
      "name": "CZ.halfSineChooseP",
      "full_name": "os.CZ.halfSineChooseP",
      "args": [
        "fund",
        "index",
        "p"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ halfSineChooseP filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.resSaw": {
      "prefix": "os",
      "name": "CZ.resSaw",
      "full_name": "os.CZ.resSaw",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ resSaw filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.resTriangle": {
      "prefix": "os",
      "name": "CZ.resTriangle",
      "full_name": "os.CZ.resTriangle",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ resTriangle filter",
      "param_docs": {},
      "example": ""
    },
    "os.CZ.resTrap": {
      "prefix": "os",
      "name": "CZ.resTrap",
      "full_name": "os.CZ.resTrap",
      "args": [
        "fund",
        "res"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "CZ resTrap filter",
      "param_docs": {},
      "example": ""
    },
    "pf.flanger_mono": {
      "prefix": "pf",
      "name": "flanger_mono",
      "full_name": "pf.flanger_mono",
      "args": [
        "dmax",
        "curdel",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono flanging effect.",
      "param_docs": {
        "dmax": "maximum delay-line length (power of 2) - 10 ms typical",
        "curdel": "current dynamic delay (not to exceed dmax)",
        "depth": "effect strength between 0 and 1 (1 typical)",
        "fb": "feedback gain between 0 and 1 (0 typical)",
        "invert": "0 for normal, 1 to invert sign of flanging sum"
      },
      "example": "pf = library(\"phaflangers.lib\");\nos = library(\"oscillators.lib\");\nflanger_mono_test = os.osc(440) : pf.flanger_mono(4096, 1024, 0.7, 0.25, 0);"
    },
    "pf.flanger_stereo": {
      "prefix": "pf",
      "name": "flanger_stereo",
      "full_name": "pf.flanger_stereo",
      "args": [
        "dmax",
        "curdel1",
        "curdel2",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Stereo flanging effect. `flanger_stereo` is a standard Faust function.",
      "param_docs": {
        "dmax": "maximum delay-line length (power of 2) - 10 ms typical",
        "curdel1": "current dynamic delay for the left channel (not to exceed dmax)",
        "curdel2": "current dynamic delay for the right channel (not to exceed dmax)",
        "depth": "effect strength between 0 and 1 (1 typical)",
        "fb": "feedback gain between 0 and 1 (0 typical)",
        "invert": "0 for normal, 1 to invert sign of flanging sum"
      },
      "example": "pf = library(\"phaflangers.lib\");\nos = library(\"oscillators.lib\");\nflanger_stereo_test = os.osc(440), os.osc(660) : pf.flanger_stereo(4096, 1024, 1536, 0.7, 0.25, 0);"
    },
    "pf.phaser2_mono": {
      "prefix": "pf",
      "name": "phaser2_mono",
      "full_name": "pf.phaser2_mono",
      "args": [
        "Notches",
        "phase",
        "width",
        "frqmin",
        "fratio",
        "frqmax",
        "speed",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "Mono phasing effect.",
      "param_docs": {
        "Notches": "number of spectral notches (MACRO ARGUMENT - not a signal)",
        "phase": "phase of the oscillator (0-1)",
        "width": "approximate width of spectral notches in Hz",
        "frqmin": "approximate minimum frequency of first spectral notch in Hz",
        "fratio": "ratio of adjacent notch frequencies",
        "frqmax": "approximate maximum frequency of first spectral notch in Hz",
        "speed": "LFO frequency in Hz (rate of periodic notch sweep cycles)",
        "depth": "effect strength between 0 and 1 (1 typical) (aka \"intensity\")",
        "fb": "feedback gain between -1 and 1 (0 typical)",
        "invert": "0 for normal, 1 to invert sign of flanging sum"
      },
      "example": "pf = library(\"phaflangers.lib\");\nos = library(\"oscillators.lib\");\nphaser2_mono_test = os.osc(330) : pf.phaser2_mono(4, 0.0, 50, 200, 1.5, 4000, 0.5, 0.8, 0.2, 0);"
    },
    "pf.phaser2_stereo": {
      "prefix": "pf",
      "name": "phaser2_stereo",
      "full_name": "pf.phaser2_stereo",
      "args": [
        "Notches",
        "width",
        "frqmin",
        "fratio",
        "frqmax",
        "speed",
        "depth",
        "fb",
        "invert"
      ],
      "arg_count": 9,
      "inputs": 0,
      "outputs": 1,
      "description": "Stereo phasing effect. `phaser2_stereo` is a standard Faust function.",
      "param_docs": {
        "Notches": "number of spectral notches (MACRO ARGUMENT - not a signal)",
        "width": "approximate width of spectral notches in Hz",
        "frqmin": "approximate minimum frequency of first spectral notch in Hz",
        "fratio": "ratio of adjacent notch frequencies",
        "frqmax": "approximate maximum frequency of first spectral notch in Hz",
        "speed": "LFO frequency in Hz (rate of periodic notch sweep cycles)",
        "depth": "effect strength between 0 and 1 (1 typical) (aka \"intensity\")",
        "fb": "feedback gain between -1 and 1 (0 typical)",
        "invert": "0 for normal, 1 to invert sign of flanging sum"
      },
      "example": "pf = library(\"phaflangers.lib\");\nos = library(\"oscillators.lib\");\nphaser2_stereo_test = os.osc(220), os.osc(330) : pf.phaser2_stereo(4, 50, 200, 1.5, 4000, 0.5, 0.8, 0.2, 0);"
    },
    "pm.speedOfSound": {
      "prefix": "pm",
      "name": "speedOfSound",
      "full_name": "pm.speedOfSound",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Speed of sound in meters per second (340m/s).",
      "param_docs": {},
      "example": ""
    },
    "pm.maxLength": {
      "prefix": "pm",
      "name": "maxLength",
      "full_name": "pm.maxLength",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "The default maximum length (3) in meters of strings and tubes used in this library. This variable should be overriden to allow longer strings or tubes. Useful conversion tools for physical modeling.",
      "param_docs": {},
      "example": ""
    },
    "pm.f2l": {
      "prefix": "pm",
      "name": "f2l",
      "full_name": "pm.f2l",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Frequency to length in meters.",
      "param_docs": {
        "freq": "the frequency"
      },
      "example": "pm = library(\"physmodels.lib\");\nf2l_test = pm.f2l(440);"
    },
    "pm.l2f": {
      "prefix": "pm",
      "name": "l2f",
      "full_name": "pm.l2f",
      "args": [
        "length"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Length in meters to frequency.",
      "param_docs": {
        "length": "length/distance in meters"
      },
      "example": "pm = library(\"physmodels.lib\");\nl2f_test = pm.l2f(0.75);"
    },
    "pm.l2s": {
      "prefix": "pm",
      "name": "l2s",
      "full_name": "pm.l2s",
      "args": [
        "l"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Length in meters to number of samples.",
      "param_docs": {
        "l": "length in meters"
      },
      "example": "pm = library(\"physmodels.lib\");\nl2s_test = pm.l2s(1.2);"
    },
    "pm.basicBlock": {
      "prefix": "pm",
      "name": "basicBlock",
      "full_name": "pm.basicBlock",
      "args": [
        "basicBlock : basicBlock : etc."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Empty bidirectional block to be used with [`chain`](#chain): 3 signals ins and 3 signals out.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nbasicBlock_test = 0,0,0 : pm.basicBlock;"
    },
    "pm.chain": {
      "prefix": "pm",
      "name": "chain",
      "full_name": "pm.chain",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a chain of bidirectional blocks. Blocks must have 3 inputs and outputs. The first input/output carry left going waves, the second input/output carry right going waves, and the third",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nchain_test = 0,0,0 : pm.chain(pm.in(0.1) : pm.basicBlock);"
    },
    "pm.inLeftWave": {
      "prefix": "pm",
      "name": "inLeftWave",
      "full_name": "pm.inLeftWave",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adds a signal to left going waves anywhere in a [`chain`](#chain) of blocks.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\ninLeftWave_test = 0,0,0 : pm.inLeftWave(0.25);"
    },
    "pm.inRightWave": {
      "prefix": "pm",
      "name": "inRightWave",
      "full_name": "pm.inRightWave",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adds a signal to right going waves anywhere in a [`chain`](#chain) of blocks.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\ninRightWave_test = 0,0,0 : pm.inRightWave(0.25);"
    },
    "pm.in": {
      "prefix": "pm",
      "name": "in",
      "full_name": "pm.in",
      "args": [
        "A : in(x"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adds a signal to left and right going waves anywhere in a [`chain`](#chain) of blocks.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nin_test = 0,0,0 : pm.in(0.25);"
    },
    "pm.outLeftWave": {
      "prefix": "pm",
      "name": "outLeftWave",
      "full_name": "pm.outLeftWave",
      "args": [
        "A : outLeftWave : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sends the signal of left going waves to the output channel of the [`chain`](#chain).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\noutLeftWave_test = pm.outLeftWave(0.1, 0.2, 0.3);"
    },
    "pm.outRightWave": {
      "prefix": "pm",
      "name": "outRightWave",
      "full_name": "pm.outRightWave",
      "args": [
        "A : outRightWave : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sends the signal of right going waves to the output channel of the [`chain`](#chain).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\noutRightWave_test = pm.outRightWave(0.1, 0.2, 0.3);"
    },
    "pm.out": {
      "prefix": "pm",
      "name": "out",
      "full_name": "pm.out",
      "args": [
        "A : out : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sends the signal of right and left going waves to the output channel of the [`chain`](#chain).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nout_test = pm.out(0.1, 0.2, 0.3);"
    },
    "pm.terminations": {
      "prefix": "pm",
      "name": "terminations",
      "full_name": "pm.terminations",
      "args": [
        "a",
        "b",
        "c"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates terminations on both sides of a [`chain`](#chain) without closing the inputs and outputs of the bidirectional signals chain. As for [`chain`](#chain), this function adds a 1 sample delay to th",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nterminations_test = 0,0,0 : pm.terminations(*(-1), pm.basicBlock, *(-1));"
    },
    "pm.lTermination": {
      "prefix": "pm",
      "name": "lTermination",
      "full_name": "pm.lTermination",
      "args": [
        "a",
        "b"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a termination on the left side of a [`chain`](#chain) without closing the inputs and outputs of the bidirectional signals chain. This function adds a 1 sample delay near the termination and ca",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nlTermination_test = 0,0,0 : pm.lTermination(*(-1), pm.basicBlock);"
    },
    "pm.rTermination": {
      "prefix": "pm",
      "name": "rTermination",
      "full_name": "pm.rTermination",
      "args": [
        "b",
        "c"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a termination on the right side of a [`chain`](#chain) without closing the inputs and outputs of the bidirectional signals chain. This function adds a 1 sample delay near the termination and c",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nrTermination_test = 0,0,0 : pm.rTermination(pm.basicBlock, *(-1));"
    },
    "pm.closeIns": {
      "prefix": "pm",
      "name": "closeIns",
      "full_name": "pm.closeIns",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 3,
      "description": "Closes the inputs of a bidirectional chain in all directions.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\ncloseIns_test = pm.closeIns;"
    },
    "pm.closeOuts": {
      "prefix": "pm",
      "name": "closeOuts",
      "full_name": "pm.closeOuts",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 3,
      "outputs": 1,
      "description": "Closes the outputs of a bidirectional chain in all directions except for the main signal output (3d output).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\ncloseOuts_test = 0,0,0 : pm.closeOuts;"
    },
    "pm.endChain": {
      "prefix": "pm",
      "name": "endChain",
      "full_name": "pm.endChain",
      "args": [
        "chain(..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Closes the inputs and outputs of a bidirectional chain in all directions except for the main signal output (3d output).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nendChain_test = 0,0,0 : pm.endChain(pm.basicBlock);"
    },
    "pm.waveguideN": {
      "prefix": "pm",
      "name": "waveguideN",
      "full_name": "pm.waveguideN",
      "args": [
        "A : waveguideUd(nMax",
        "n"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A series of waveguide functions based on various types of delays (see [`fdelay[n]`](#fdelayn)).",
      "param_docs": {
        "nMax": "the maximum length of the delays in the waveguide",
        "n": "the length of the delay lines in samples."
      },
      "example": "pm = library(\"physmodels.lib\");\nwaveguideUd_test = 0,0,0 : pm.waveguideUd(512, 32);\nwaveguideFd_test = 0,0,0 : pm.waveguideFd(512, 32);\nwaveguideFd2_test = 0,0,0 : pm.waveguideFd2(512, 32);\nwaveguideFd4_test = 0,0,0 : pm.waveguideFd4(512, 32);"
    },
    "pm.waveguide": {
      "prefix": "pm",
      "name": "waveguide",
      "full_name": "pm.waveguide",
      "args": [
        "A : waveguide(nMax",
        "n"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard `pm.lib` waveguide (based on [`waveguideFd4`](#waveguiden)).",
      "param_docs": {
        "nMax": "the maximum length of the delays in the waveguide",
        "n": "the length of the delay lines in samples."
      },
      "example": "pm = library(\"physmodels.lib\");\nwaveguide_test = 0,0,0 : pm.waveguide(512, 32);"
    },
    "pm.bridgeFilter": {
      "prefix": "pm",
      "name": "bridgeFilter",
      "full_name": "pm.bridgeFilter",
      "args": [
        "brightness",
        "absorption"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Generic two zeros bridge FIR filter (as implemented in the [STK](https://ccrma.stanford.edu/software/stk/)) that can be used to implement the reflectance violin, guitar, etc. bridges.",
      "param_docs": {
        "brightness": "controls the damping of high frequencies (0-1)",
        "absorption": "controls the absorption of the brige and thus the t60 of"
      },
      "example": "pm = library(\"physmodels.lib\");\nbridgeFilter_test = pm.bridgeFilter(0.6, 0.4, os.osc(110));"
    },
    "pm.modeFilter": {
      "prefix": "pm",
      "name": "modeFilter",
      "full_name": "pm.modeFilter",
      "args": [
        "freq",
        "t60",
        "gain"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Resonant bandpass filter that can be used to implement a single resonance (mode).",
      "param_docs": {
        "freq": "mode frequency",
        "t60": "mode resonance duration (in seconds)",
        "gain": "mode gain (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmodeFilter_test = pm.modeFilter(440, 1.5, 0.8);"
    },
    "pm.stringSegment": {
      "prefix": "pm",
      "name": "stringSegment",
      "full_name": "pm.stringSegment",
      "args": [
        "A : stringSegment(maxLength",
        "length"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A string segment without terminations (just a simple waveguide).",
      "param_docs": {
        "maxLength": "the maximum length of the string in meters (should be static)",
        "length": "the length of the string in meters"
      },
      "example": "pm = library(\"physmodels.lib\");\nstringSegment_test = 0,0,0 : pm.stringSegment(1.0, 0.5);"
    },
    "pm.openString": {
      "prefix": "pm",
      "name": "openString",
      "full_name": "pm.openString",
      "args": [
        "... : openString(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a basic \"generic\" string with a selectable excitation position. Lowpass filters are built-in and allow to simulate the effect of dispersion on the sound and thus",
      "param_docs": {
        "length": "the length of the string in meters",
        "stiffness": "the stiffness of the string (0-1) (1 for max stiffness)",
        "pluckPosition": "excitation position (0-1) (1 is bottom)",
        "excitation": "the excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nopenString_test = 0,0,0 : pm.openString(0.8, 0.5, 0.2, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.nylonString": {
      "prefix": "pm",
      "name": "nylonString",
      "full_name": "pm.nylonString",
      "args": [
        "... : nylonString(length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a basic nylon string with selectable excitation position. This element is based on [`openString`](#openstring) and has a fix stiffness corresponding to that of a nyl",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "excitation position (0-1) (1 is bottom)",
        "excitation": "the excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nnylonString_test = 0,0,0 : pm.nylonString(0.8, 0.3, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.steelString": {
      "prefix": "pm",
      "name": "steelString",
      "full_name": "pm.steelString",
      "args": [
        "... : steelString(length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a basic steel string with selectable excitation position. This element is based on [`openString`](#openstring) and has a fix stiffness corresponding to that of a ste",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "excitation position (0-1) (1 is bottom)",
        "excitation": "the excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nsteelString_test = 0,0,0 : pm.steelString(0.8, 0.3, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.openStringPick": {
      "prefix": "pm",
      "name": "openStringPick",
      "full_name": "pm.openStringPick",
      "args": [
        "... : openStringPick(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a \"generic\" string with selectable excitation position. It also has a built-in pickup whose position is the same as the excitation position. Thus, moving the excitat",
      "param_docs": {
        "length": "the length of the string in meters",
        "stiffness": "the stiffness of the string (0-1) (1 for max stiffness)",
        "pluckPosition": "excitation position (0-1) (1 is bottom)",
        "excitation": "the excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nopenStringPick_test = 0,0,0 : pm.openStringPick(0.8, 0.4, 0.3, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.openStringPickUp": {
      "prefix": "pm",
      "name": "openStringPickUp",
      "full_name": "pm.openStringPickUp",
      "args": [
        "... : openStringPickUp(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a \"generic\" string with selectable excitation position and stiffness. It also has a built-in pickup whose position can be independenly selected. The only constraint ",
      "param_docs": {
        "length": "the length of the string in meters",
        "stiffness": "the stiffness of the string (0-1) (1 for max stiffness)",
        "pluckPosition": "pluck position between the top of the string and the",
        "pickupPosition": "position of the pickup on the string (0-1) (1 is bottom)",
        "excitation": "the excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nopenStringPickUp_test = 0,0,0 : pm.openStringPickUp(0.8, 0.4, 0.6, 0.7, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.openStringPickDown": {
      "prefix": "pm",
      "name": "openStringPickDown",
      "full_name": "pm.openStringPickDown",
      "args": [
        "... : openStringPickDown(length",
        "stiffness",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A bidirectional block implementing a \"generic\" string with selectable excitation position and stiffness. It also has a built-in pickup whose position can be independenly selected. The only constraint ",
      "param_docs": {
        "length": "the length of the string in meters",
        "stiffness": "the stiffness of the string (0-1) (1 for max stiffness)",
        "pluckPosition": "pluck position on the string (0-1) (1 is bottom)",
        "pickupPosition": "position of the pickup between the top of the string",
        "excitation": "the excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nopenStringPickDown_test = 0,0,0 : pm.openStringPickDown(0.8, 0.4, 0.6, 0.5, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.ksReflexionFilter": {
      "prefix": "pm",
      "name": "ksReflexionFilter",
      "full_name": "pm.ksReflexionFilter",
      "args": [
        "_",
        "chain(..."
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "The \"typical\" one-zero Karplus-strong feedforward reflexion filter. This filter will be typically used in a termination (see below).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nos = library(\"oscillators.lib\");\nksReflexionFilter_test = os.osc(220) : pm.ksReflexionFilter;"
    },
    "pm.rStringRigidTermination": {
      "prefix": "pm",
      "name": "rStringRigidTermination",
      "full_name": "pm.rStringRigidTermination",
      "args": [
        "rStringRigidTermination : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a right rigid string termination (no damping, just phase inversion).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nrStringRigidTermination_test = 0,0,0 : pm.rStringRigidTermination;"
    },
    "pm.lStringRigidTermination": {
      "prefix": "pm",
      "name": "lStringRigidTermination",
      "full_name": "pm.lStringRigidTermination",
      "args": [
        "... : stringSegment : lStringRigidTermination"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a left rigid string termination (no damping, just phase inversion).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nlStringRigidTermination_test = 0,0,0 : pm.lStringRigidTermination;"
    },
    "pm.elecGuitarBridge": {
      "prefix": "pm",
      "name": "elecGuitarBridge",
      "full_name": "pm.elecGuitarBridge",
      "args": [
        "... : stringSegment : elecGuitarBridge"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple electric guitar bridge. This block is based on [`bridgeFilter`](#bridgeFilter). The bridge doesn't implement transmittance since it is not meant to be connect",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nelecGuitarBridge_test = 0,0,0 : pm.elecGuitarBridge;"
    },
    "pm.elecGuitarNuts": {
      "prefix": "pm",
      "name": "elecGuitarNuts",
      "full_name": "pm.elecGuitarNuts",
      "args": [
        "elecGuitarNuts : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple electric guitar nuts. This block is based on [`bridgeFilter`](#bridgeFilter) and does essentially the same thing as [`elecGuitarBridge`](#elecguitarbridge), b",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nelecGuitarNuts_test = 0,0,0 : pm.elecGuitarNuts;"
    },
    "pm.guitarBridge": {
      "prefix": "pm",
      "name": "guitarBridge",
      "full_name": "pm.guitarBridge",
      "args": [
        "... : stringSegment : guitarBridge"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple acoustic guitar bridge. This bridge damps more hight frequencies than [`elecGuitarBridge`](#elecguitarbridge) and implements a transmittance",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nguitarBridge_test = 0,0,0 : pm.guitarBridge;"
    },
    "pm.guitarNuts": {
      "prefix": "pm",
      "name": "guitarNuts",
      "full_name": "pm.guitarNuts",
      "args": [
        "guitarNuts : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple acoustic guitar nuts. This nuts damps more hight frequencies than [`elecGuitarNuts`](#elecguitarnuts) and implements a transmittance",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nguitarNuts_test = 0,0,0 : pm.guitarNuts;"
    },
    "pm.idealString": {
      "prefix": "pm",
      "name": "idealString",
      "full_name": "pm.idealString",
      "args": [
        "length",
        "reflexion",
        "xPosition",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "An \"ideal\" string with rigid terminations and where the plucking position and the pick-up position are the same. Since terminations are rigid, this string will ring forever.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nidealString_test = 0,0,0 : pm.idealString(0.9, 0.2, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.ks": {
      "prefix": "pm",
      "name": "ks",
      "full_name": "pm.ks",
      "args": [
        "length",
        "damping",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A Karplus-Strong string (in that case, the string is implemented as a one dimension waveguide).",
      "param_docs": {
        "length": "the length of the string in meters",
        "damping": "string damping (0-1)",
        "excitation": "excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nks_test = pm.ks(0.9, 0.3, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.ks_ui_MIDI": {
      "prefix": "pm",
      "name": "ks_ui_MIDI",
      "full_name": "pm.ks_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use, MIDI-enabled Karplus-Strong string with buil-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nks_ui_MIDI_test = pm.ks_ui_MIDI;"
    },
    "pm.elecGuitarModel": {
      "prefix": "pm",
      "name": "elecGuitarModel",
      "full_name": "pm.elecGuitarModel",
      "args": [
        "length",
        "pluckPosition",
        "mute",
        "excitation"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple electric guitar model (without audio effects, of course) with selectable pluck position. This model implements a single string. Additional strings should be created",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "mute": "mute coefficient (1 for no mute and 0 for instant mute)",
        "excitation": "excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nelecGuitarModel_test = pm.elecGuitarModel(0.9, 0.3, 0.8, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.elecGuitar": {
      "prefix": "pm",
      "name": "elecGuitar",
      "full_name": "pm.elecGuitar",
      "args": [
        "length",
        "pluckPosition",
        "trigger"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple electric guitar model with steel strings (based on [`elecGuitarModel`](#elecguitarmodel)) implementing an excitation model.",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "mute": "mute coefficient (1 for no mute and 0 for instant mute)",
        "gain": "gain of the pluck (0-1)",
        "trigger": "trigger signal (1 for on, 0 for off)"
      },
      "example": "pm = library(\"physmodels.lib\");\nelecGuitar_test = pm.elecGuitar(0.9, 0.3, 0.8, 0.6, button(\"gate\"));"
    },
    "pm.elecGuitar_ui_MIDI": {
      "prefix": "pm",
      "name": "elecGuitar_ui_MIDI",
      "full_name": "pm.elecGuitar_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled electric guitar physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nelecGuitar_ui_MIDI_test = pm.elecGuitar_ui_MIDI;"
    },
    "pm.guitarBody": {
      "prefix": "pm",
      "name": "guitarBody",
      "full_name": "pm.guitarBody",
      "args": [
        "... : guitarBody"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "WARNING: not implemented yet! Bidirectional block implementing a simple acoustic guitar body.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nguitarBody_test = 0,0,0 : pm.guitarBody;"
    },
    "pm.guitarModel": {
      "prefix": "pm",
      "name": "guitarModel",
      "full_name": "pm.guitarModel",
      "args": [
        "length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with steel strings and selectable excitation position. This model implements a single string. Additional strings should be created by making a polyphonic application out",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "excitation": "excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nguitarModel_test = pm.guitarModel(0.9, 0.25, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.guitar": {
      "prefix": "pm",
      "name": "guitar",
      "full_name": "pm.guitar",
      "args": [
        "length",
        "pluckPosition",
        "trigger"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with steel strings (based on [`guitarModel`](#guitarmodel)) implementing an excitation model. This model implements a single string. Additional strings should be created",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "gain": "gain of the excitation",
        "trigger": "trigger signal (1 for on, 0 for off)"
      },
      "example": "pm = library(\"physmodels.lib\");\nguitar_test = pm.guitar(0.9, 0.25, 0.8, button(\"gate\"));"
    },
    "pm.guitar_ui_MIDI": {
      "prefix": "pm",
      "name": "guitar_ui_MIDI",
      "full_name": "pm.guitar_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled steel strings acoustic guitar physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nguitar_ui_MIDI_test = pm.guitar_ui_MIDI;"
    },
    "pm.nylonGuitarModel": {
      "prefix": "pm",
      "name": "nylonGuitarModel",
      "full_name": "pm.nylonGuitarModel",
      "args": [
        "length",
        "pluckPosition",
        "excitation"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with nylon strings and selectable excitation position. This model implements a single string. Additional strings should be created by making a polyphonic application out",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "excitation": "excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nnylonGuitarModel_test = pm.nylonGuitarModel(0.9, 0.25, pm.impulseExcitation(button(\"gate\")));"
    },
    "pm.nylonGuitar": {
      "prefix": "pm",
      "name": "nylonGuitar",
      "full_name": "pm.nylonGuitar",
      "args": [
        "length",
        "pluckPosition",
        "trigger"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple acoustic guitar model with nylon strings (based on [`nylonGuitarModel`](#nylonguitarmodel)) implementing an excitation model. This model implements a single string. Additional strings should ",
      "param_docs": {
        "length": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "gain": "gain of the excitation (0-1)",
        "trigger": "trigger signal (1 for on, 0 for off)"
      },
      "example": "pm = library(\"physmodels.lib\");\nnylonGuitar_test = pm.nylonGuitar(0.9, 0.25, 0.8, button(\"gate\"));"
    },
    "pm.nylonGuitar_ui_MIDI": {
      "prefix": "pm",
      "name": "nylonGuitar_ui_MIDI",
      "full_name": "pm.nylonGuitar_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled nylon strings acoustic guitar physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nnylonGuitar_ui_MIDI_test = pm.nylonGuitar_ui_MIDI;"
    },
    "pm.modeInterpRes": {
      "prefix": "pm",
      "name": "modeInterpRes",
      "full_name": "pm.modeInterpRes",
      "args": [
        "nModes",
        "x",
        "y"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Modular string instrument resonator based on IR measurements made on 3D printed models. The 2D space allowing for the control of the shape and the scale of the model is enabled by interpolating betwee",
      "param_docs": {
        "nModes": "number of modeled modes (40 max)",
        "x": "shape of the resonator (0: square, 1: square with rounded corners, 2: round)",
        "y": "scale of the resonator (0: small, 1: medium, 2: large)"
      },
      "example": "pm = library(\"physmodels.lib\");\nos = library(\"oscillators.lib\");\nmodeInterpRes_test = os.osc(110) : pm.modeInterpRes(20, 1.0, 1.5);"
    },
    "pm.modularInterpBody": {
      "prefix": "pm",
      "name": "modularInterpBody",
      "full_name": "pm.modularInterpBody",
      "args": [
        "... : modularInterpBody(nModes",
        "shape",
        "scale"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a modular string instrument resonator (see [`modeInterpRes`](#pm.modeinterpres)).",
      "param_docs": {
        "nModes": "number of modeled modes (40 max)",
        "shape": "shape of the resonator (0: square, 1: square with rounded corners, 2: round)",
        "scale": "scale of the resonator (0: small, 1: medium, 2: large)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmodularInterpBody_test = 0,0,0 : pm.modularInterpBody(20, 1.0, 1.5);"
    },
    "pm.modularInterpStringModel": {
      "prefix": "pm",
      "name": "modularInterpStringModel",
      "full_name": "pm.modularInterpStringModel",
      "args": [
        "length",
        "pluckPosition",
        "shape",
        "scale",
        "bodyExcitation",
        "stringExcitation"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "String instrument model with a modular body (see [`modeInterpRes`](#pm.modeinterpres) and <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>).",
      "param_docs": {
        "stringLength": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "shape": "shape of the resonator (0: square, 1: square with rounded corners, 2: round)",
        "scale": "scale of the resonator (0: small, 1: medium, 2: large)",
        "bodyExcitation": "excitation signal for the body",
        "stringExcitation": "excitation signal for the string"
      },
      "example": "pm = library(\"physmodels.lib\");\nmodularInterpStringModel_test = pm.modularInterpStringModel(0.9, 0.3, 1.0, 1.5, pm.impulseExcitation(button(\"body\")), pm.impulseExcitation(button(\"string\")));"
    },
    "pm.modularInterpInstr": {
      "prefix": "pm",
      "name": "modularInterpInstr",
      "full_name": "pm.modularInterpInstr",
      "args": [
        "stringLength",
        "pluckPosition",
        "shape",
        "scale",
        "gain",
        "tapBody",
        "triggerString"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "String instrument with a modular body (see [`modeInterpRes`](#pm.modeinterpres) and <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>).",
      "param_docs": {
        "stringLength": "the length of the string in meters",
        "pluckPosition": "pluck position (0-1) (1 is on the bridge)",
        "shape": "shape of the resonator (0: square, 1: square with rounded corners, 2: round)",
        "scale": "scale of the resonator (0: small, 1: medium, 2: large)",
        "gain": "of the string excitation",
        "tapBody": "send an impulse in the body of the instrument where the string is connected (1 for on, 0 for off)",
        "triggerString": "trigger signal for the string (1 for on, 0 for off)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmodularInterpInstr_test = pm.modularInterpInstr(0.9, 0.3, 1.0, 1.5, 0.8, button(\"body\"), button(\"string\"));"
    },
    "pm.modularInterpInstr_ui_MIDI": {
      "prefix": "pm",
      "name": "modularInterpInstr_ui_MIDI",
      "full_name": "pm.modularInterpInstr_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled string instrument with a modular body (see [`modeInterpRes`](#pm.modeinterpres) and <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>)",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nmodularInterpInstr_ui_MIDI_test = pm.modularInterpInstr_ui_MIDI;"
    },
    "pm.bowTable": {
      "prefix": "pm",
      "name": "bowTable",
      "full_name": "pm.bowTable",
      "args": [
        "offset",
        "slope"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Extremely basic bow table that can be used to implement a wide range of bow types for many different bowed string instruments (violin, cello, etc.).",
      "param_docs": {
        "excitation": "an excitation signal",
        "offset": "table offset",
        "slope": "table slope"
      },
      "example": "pm = library(\"physmodels.lib\");\nbowTable_test = pm.bowTable(0.4, 0.1);"
    },
    "pm.violinBowTable": {
      "prefix": "pm",
      "name": "violinBowTable",
      "full_name": "pm.violinBowTable",
      "args": [
        "bowPressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Violin bow table based on [`bowTable`](#bowtable).",
      "param_docs": {
        "bowVelocity": "velocity of the bow/excitation signal (0-1)",
        "bowPressure": "bow pressure on the string (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nviolinBowTable_test = pm.violinBowTable(0.4, 0.1);"
    },
    "pm.bowInteraction": {
      "prefix": "pm",
      "name": "bowInteraction",
      "full_name": "pm.bowInteraction",
      "args": [
        "... : stringSegment : bowInteraction(bowTable"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing the interaction of a bow in a [`chain`](#chain).",
      "param_docs": {
        "bowTable": "the bow table"
      },
      "example": "pm = library(\"physmodels.lib\");\nbowInteraction_test = pm.bowInteraction((0.4, 0.05));"
    },
    "pm.violinBow": {
      "prefix": "pm",
      "name": "violinBow",
      "full_name": "pm.violinBow",
      "args": [
        "... : stringSegment : violinBow(bowPressure",
        "bowVelocity"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a violin bow and its interaction with a string.",
      "param_docs": {
        "bowVelocity": "velocity of the bow / excitation signal (0-1)",
        "bowPressure": "bow pressure on the string (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nviolinBow_test = pm.violinBow(0.4, 0.05);"
    },
    "pm.violinBowedString": {
      "prefix": "pm",
      "name": "violinBowedString",
      "full_name": "pm.violinBowedString",
      "args": [
        "nuts : violinBowedString(stringLength",
        "bowPressure",
        "bowVelocity",
        "bowPosition"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Violin bowed string bidirectional block with controllable bow position. Terminations are not implemented in this model.",
      "param_docs": {
        "stringLength": "the length of the string in meters",
        "bowVelocity": "velocity of the bow / excitation signal (0-1)",
        "bowPressure": "bow pressure on the string (0-1)",
        "bowPosition": "the position of the bow on the string (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nviolinBowedString_test = 0,0,0 : pm.violinBowedString(0.82, 0.35, pm.violinBow(0.4, 0.05), 0.15);"
    },
    "pm.violinNuts": {
      "prefix": "pm",
      "name": "violinNuts",
      "full_name": "pm.violinNuts",
      "args": [
        "violinNuts : stringSegment : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing simple violin nuts. This function is based on [`bridgeFilter`](#bridgefilter).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nviolinNuts_test = 0,0,0 : pm.violinNuts;"
    },
    "pm.violinBridge": {
      "prefix": "pm",
      "name": "violinBridge",
      "full_name": "pm.violinBridge",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple violin bridge. This function is based on [`bridgeFilter`](#bridgefilter).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nviolinBridge_test = 0,0,0 : pm.violinBridge;"
    },
    "pm.violinBody": {
      "prefix": "pm",
      "name": "violinBody",
      "full_name": "pm.violinBody",
      "args": [
        "... : stringSegment : violinBridge : violinBody"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a simple violin body (just a simple resonant lowpass filter).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nviolinBody_test = 0,0,0 : pm.violinBody;"
    },
    "pm.violinModel": {
      "prefix": "pm",
      "name": "violinModel",
      "full_name": "pm.violinModel",
      "args": [
        "stringLength",
        "bowPressure",
        "bowVelocity",
        "bridgeReflexion",
        "// bridgeAbsorption",
        "bowPosition"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use simple violin physical model. This model implements a single string. Additional strings should be created by making a polyphonic application out of this function. Pitch is changed",
      "param_docs": {
        "stringLength": "the length of the string in meters",
        "bowVelocity": "velocity of the bow / excitation signal (0-1)",
        "bowPressure": "bow pressure on the string (0-1))",
        "bowPosition": "the position of the bow on the string (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nviolinModel_test = pm.violinModel(0.82, 0.35, pm.violinBow(0.4, 0.05), 0.15);"
    },
    "pm.violin_ui": {
      "prefix": "pm",
      "name": "violin_ui",
      "full_name": "pm.violin_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use violin physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nviolin_ui_test = pm.violin_ui;"
    },
    "pm.violin_ui_MIDI": {
      "prefix": "pm",
      "name": "violin_ui_MIDI",
      "full_name": "pm.violin_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-enabled violin physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nviolin_ui_MIDI_test = pm.violin_ui_MIDI;"
    },
    "pm.openTube": {
      "prefix": "pm",
      "name": "openTube",
      "full_name": "pm.openTube",
      "args": [
        "A : openTube(maxLength",
        "length"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "A tube segment without terminations (same as [`stringSegment`](#stringsegment)).",
      "param_docs": {
        "maxLength": "the maximum length of the tube in meters (should be static)",
        "length": "the length of the tube in meters"
      },
      "example": "pm = library(\"physmodels.lib\");\nopenTube_test = pm.openTube(0.9);"
    },
    "pm.reedTable": {
      "prefix": "pm",
      "name": "reedTable",
      "full_name": "pm.reedTable",
      "args": [
        "offeset",
        "slope"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Extremely basic reed table that can be used to implement a wide range of single reed types for many different instruments (saxophone, clarinet, etc.).",
      "param_docs": {
        "excitation": "an excitation signal",
        "offset": "table offset",
        "slope": "table slope"
      },
      "example": "pm = library(\"physmodels.lib\");\nreedTable_test = pm.reedTable(0.4, 0.2);"
    },
    "pm.fluteJetTable": {
      "prefix": "pm",
      "name": "fluteJetTable",
      "full_name": "pm.fluteJetTable",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Extremely basic flute jet table.",
      "param_docs": {
        "excitation": "an excitation signal"
      },
      "example": "pm = library(\"physmodels.lib\");\nfluteJetTable_test = pm.fluteJetTable(0.5);"
    },
    "pm.brassLipsTable": {
      "prefix": "pm",
      "name": "brassLipsTable",
      "full_name": "pm.brassLipsTable",
      "args": [
        "tubeLength",
        "lipsTension"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple brass lips/mouthpiece table. Since this implementation is very basic and that the lips and tube of the instrument are coupled to each other, the length of that tube must be provided here.",
      "param_docs": {
        "excitation": "an excitation signal (can be DC)",
        "tubeLength": "length in meters of the tube connected to the mouthpiece",
        "lipsTension": "tension of the lips (0-1) (default: 0.5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nbrassLipsTable_test = pm.brassLipsTable(0.3, 0.2);"
    },
    "pm.clarinetReed": {
      "prefix": "pm",
      "name": "clarinetReed",
      "full_name": "pm.clarinetReed",
      "args": [
        "stiffness"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Clarinet reed based on [`reedTable`](#reedtable) with controllable stiffness.",
      "param_docs": {
        "excitation": "an excitation signal",
        "stiffness": "reed stiffness (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nclarinetReed_test = pm.clarinetReed(0.6, 0.4, 0.1);"
    },
    "pm.clarinetMouthPiece": {
      "prefix": "pm",
      "name": "clarinetMouthPiece",
      "full_name": "pm.clarinetMouthPiece",
      "args": [
        "clarinetMouthPiece(reedStiffness",
        "pressure"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a clarinet mouthpiece as well as the various interactions happening with traveling waves. This element is ready to be plugged to a tube...",
      "param_docs": {
        "pressure": "the pressure of the air flow (DC) created by the virtual performer (0-1).",
        "reedStiffness": "reed stiffness (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nclarinetMouthPiece_test = pm.clarinetMouthPiece(0.6, 0.4, 0.1);"
    },
    "pm.brassLips": {
      "prefix": "pm",
      "name": "brassLips",
      "full_name": "pm.brassLips",
      "args": [
        "brassLips(tubeLength",
        "lipsTension",
        "pressure"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a brass mouthpiece as well as the various interactions happening with traveling waves. This element is ready to be plugged to a tube...",
      "param_docs": {
        "tubeLength": "length in meters of the tube connected to the mouthpiece",
        "lipsTension": "tension of the lips (0-1) (default: 0.5)",
        "pressure": "the pressure of the air flow (DC) created by the virtual performer (0-1)."
      },
      "example": "pm = library(\"physmodels.lib\");\nbrassLips_test = pm.brassLips(0.3, 0.2, 0.1);"
    },
    "pm.fluteEmbouchure": {
      "prefix": "pm",
      "name": "fluteEmbouchure",
      "full_name": "pm.fluteEmbouchure",
      "args": [
        "... : tube : fluteEmbouchure(pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block implementing a flute embouchure as well as the various interactions happening with traveling waves. This element is ready to be plugged between tubes segments...",
      "param_docs": {
        "pressure": "the pressure of the air flow (DC) created by the virtual"
      },
      "example": "pm = library(\"physmodels.lib\");\nfluteEmbouchure_test = pm.fluteEmbouchure(0.5, 0.3);"
    },
    "pm.wBell": {
      "prefix": "pm",
      "name": "wBell",
      "full_name": "pm.wBell",
      "args": [
        "... : wBell(opening"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic wind instrument bell bidirectional block that should be placed at the end of a [`chain`](#chain).",
      "param_docs": {
        "opening": "the \"opening\" of bell (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nwBell_test = pm.wBell(0.4, 0.6);"
    },
    "pm.fluteHead": {
      "prefix": "pm",
      "name": "fluteHead",
      "full_name": "pm.fluteHead",
      "args": [
        "fluteHead : tube : ..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple flute head implementing waves reflexion.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nfluteHead_test = pm.fluteHead(0.8, 0.4, 0.3);"
    },
    "pm.fluteFoot": {
      "prefix": "pm",
      "name": "fluteFoot",
      "full_name": "pm.fluteFoot",
      "args": [
        "... : tube : fluteFoot"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple flute foot implementing waves reflexion and dispersion.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nfluteFoot_test = pm.fluteFoot(0.8, 0.4, 0.3);"
    },
    "pm.clarinetModel": {
      "prefix": "pm",
      "name": "clarinetModel",
      "full_name": "pm.clarinetModel",
      "args": [
        "length",
        "pressure",
        "reedStiffness",
        "bellOpening"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple clarinet physical model without tone holes (pitch is changed by changing the length of the tube of the instrument).",
      "param_docs": {
        "tubeLength": "the length of the tube in meters",
        "pressure": "the pressure of the air flow created by the virtual performer (0-1).",
        "reedStiffness": "reed stiffness (0-1)",
        "bellOpening": "the opening of bell (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nclarinetModel_test = pm.clarinetModel(0.9, 0.4, 0.3, 0.2);"
    },
    "pm.clarinetModel_ui": {
      "prefix": "pm",
      "name": "clarinetModel_ui",
      "full_name": "pm.clarinetModel_ui",
      "args": [
        "pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`clarinetModel`](#clarinetModel) but with a built-in UI. This function doesn't implement a virtual \"blower\", thus `pressure` remains an argument here.",
      "param_docs": {
        "pressure": "the pressure of the air flow created by the virtual performer (0-1)."
      },
      "example": "pm = library(\"physmodels.lib\");\nclarinetModel_ui_test = pm.clarinetModel_ui;"
    },
    "pm.clarinet_ui": {
      "prefix": "pm",
      "name": "clarinet_ui",
      "full_name": "pm.clarinet_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use clarinet physical model with built-in UI based on [`clarinetModel`](#clarinetmodel).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nclarinet_ui_test = pm.clarinet_ui;"
    },
    "pm.clarinet_ui_MIDI": {
      "prefix": "pm",
      "name": "clarinet_ui_MIDI",
      "full_name": "pm.clarinet_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI compliant clarinet physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nclarinet_ui_MIDI_test = pm.clarinet_ui_MIDI;"
    },
    "pm.brassModel": {
      "prefix": "pm",
      "name": "brassModel",
      "full_name": "pm.brassModel",
      "args": [
        "tubeLength",
        "lipsTension",
        "mute",
        "pressure"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple generic brass instrument physical model without pistons (pitch is changed by changing the length of the tube of the instrument). This model is kind of hard to control and might not sound very",
      "param_docs": {
        "tubeLength": "the length of the tube in meters",
        "lipsTension": "tension of the lips (0-1) (default: 0.5)",
        "mute": "mute opening at the end of the instrument (0-1) (default: 0.5)",
        "pressure": "the pressure of the air flow created by the virtual performer (0-1)."
      },
      "example": "pm = library(\"physmodels.lib\");\nbrassModel_test = pm.brassModel(0.9, 0.4, 0.2, 0.6);"
    },
    "pm.brassModel_ui": {
      "prefix": "pm",
      "name": "brassModel_ui",
      "full_name": "pm.brassModel_ui",
      "args": [
        "pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`brassModel`](#brassModel) but with a built-in UI. This function doesn't implement a virtual \"blower\", thus `pressure` remains an argument here.",
      "param_docs": {
        "pressure": "the pressure of the air flow created by the virtual performer (0-1)."
      },
      "example": "pm = library(\"physmodels.lib\");\nbrassModel_ui_test = pm.brassModel_ui;"
    },
    "pm.brass_ui": {
      "prefix": "pm",
      "name": "brass_ui",
      "full_name": "pm.brass_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use brass instrument physical model with built-in UI based on [`brassModel`](#brassmodel).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nbrass_ui_test = pm.brass_ui;"
    },
    "pm.brass_ui_MIDI": {
      "prefix": "pm",
      "name": "brass_ui_MIDI",
      "full_name": "pm.brass_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable brass instrument physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nbrass_ui_MIDI_test = pm.brass_ui_MIDI;"
    },
    "pm.fluteModel": {
      "prefix": "pm",
      "name": "fluteModel",
      "full_name": "pm.fluteModel",
      "args": [
        "tubeLength",
        "mouthPosition",
        "pressure"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple generic flute instrument physical model without tone holes (pitch is changed by changing the length of the tube of the instrument).",
      "param_docs": {
        "tubeLength": "the length of the tube in meters",
        "mouthPosition": "position of the mouth on the embouchure (0-1) (default: 0.5)",
        "pressure": "the pressure of the air flow created by the virtual performer (0-1)."
      },
      "example": "pm = library(\"physmodels.lib\");\nfluteModel_test = pm.fluteModel(0.9, 0.4, 0.6);"
    },
    "pm.fluteModel_ui": {
      "prefix": "pm",
      "name": "fluteModel_ui",
      "full_name": "pm.fluteModel_ui",
      "args": [
        "pressure"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`fluteModel`](#fluteModel) but with a built-in UI. This function doesn't implement a virtual \"blower\", thus `pressure` remains an argument here.",
      "param_docs": {
        "pressure": "the pressure of the air flow created by the virtual performer (0-1)."
      },
      "example": "pm = library(\"physmodels.lib\");\nfluteModel_ui_test = pm.fluteModel_ui;"
    },
    "pm.flute_ui": {
      "prefix": "pm",
      "name": "flute_ui",
      "full_name": "pm.flute_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use flute physical model with built-in UI based on [`fluteModel`](#flutemodel).",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nflute_ui_test = pm.flute_ui;"
    },
    "pm.flute_ui_MIDI": {
      "prefix": "pm",
      "name": "flute_ui_MIDI",
      "full_name": "pm.flute_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable flute physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nflute_ui_MIDI_test = pm.flute_ui_MIDI;"
    },
    "pm.impulseExcitation": {
      "prefix": "pm",
      "name": "impulseExcitation",
      "full_name": "pm.impulseExcitation",
      "args": [
        "gate"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates an impulse excitation of one sample.",
      "param_docs": {
        "gate": "a gate button"
      },
      "example": "pm = library(\"physmodels.lib\");\nimpulseExcitation_test = pm.impulseExcitation(button(\"gate\"));"
    },
    "pm.strikeModel": {
      "prefix": "pm",
      "name": "strikeModel",
      "full_name": "pm.strikeModel",
      "args": [
        "LPcutoff",
        "HPcutoff",
        "sharpness",
        "gain",
        "gate"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a filtered noise excitation.",
      "param_docs": {
        "HPcutoff": "highpass cutoff frequency",
        "LPcutoff": "lowpass cutoff frequency",
        "sharpness": "sharpness of the attack and release (0-1)",
        "gain": "gain of the excitation",
        "gate": "a gate button/trigger signal (0/1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nstrikeModel_test = pm.strikeModel(200, 4000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.strike": {
      "prefix": "pm",
      "name": "strike",
      "full_name": "pm.strike",
      "args": [
        "exPos",
        "sharpness",
        "gain",
        "gate"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Strikes generator with controllable excitation position.",
      "param_docs": {
        "exPos": "excitation position wiht 0: for max low freqs and 1: for max high",
        "sharpness": "sharpness of the attack and release (0-1)",
        "gain": "gain of the excitation",
        "gate": "a gate button/trigger signal (0/1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nstrike_test = pm.strike(0.4, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.pluckString": {
      "prefix": "pm",
      "name": "pluckString",
      "full_name": "pm.pluckString",
      "args": [
        "stringLength",
        "cutoff",
        "maxFreq",
        "sharpness",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Creates a plucking excitation signal.",
      "param_docs": {
        "stringLength": "length of the string to pluck",
        "cutoff": "cutoff ratio (1 for default)",
        "maxFreq": "max frequency ratio (1 for default)",
        "sharpness": "sharpness of the attack and release (1 for default)",
        "gain": "gain of the excitation (0-1)",
        "trigger": "trigger signal (1 for on, 0 for off)"
      },
      "example": "pm = library(\"physmodels.lib\");\npluckString_test = pm.pluckString(0.9, 1, 1, 1, 0.6, button(\"gate\"));"
    },
    "pm.blower": {
      "prefix": "pm",
      "name": "blower",
      "full_name": "pm.blower",
      "args": [
        "pressure",
        "breathGain",
        "breathCutoff"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A virtual blower creating a DC signal with some breath noise in it.",
      "param_docs": {
        "pressure": "pressure (0-1)",
        "breathGain": "breath noise gain (0-1) (recommended: 0.005)",
        "breathCutoff": "breath cuttoff frequency (Hz) (recommended: 2000)"
      },
      "example": "pm = library(\"physmodels.lib\");\nblower_test = pm.blower(0.5, 0.05, 2000, 5, 0.2);"
    },
    "pm.blower_ui": {
      "prefix": "pm",
      "name": "blower_ui",
      "full_name": "pm.blower_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Same as [`blower`](#blower) but with a built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nblower_ui_test = pm.blower_ui;"
    },
    "pm.djembeModel": {
      "prefix": "pm",
      "name": "djembeModel",
      "full_name": "pm.djembeModel",
      "args": [
        "freq"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Dirt-simple djembe modal physical model. Mode parameters are empirically calculated and don't correspond to any measurements or 3D model. They kind of sound good though :).",
      "param_docs": {
        "excitation": "excitation signal",
        "freq": "fundamental frequency of the bar"
      },
      "example": "pm = library(\"physmodels.lib\");\ndjembeModel_test = pm.djembeModel(110);"
    },
    "pm.djembe": {
      "prefix": "pm",
      "name": "djembe",
      "full_name": "pm.djembe",
      "args": [
        "freq",
        "strikePosition",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Dirt-simple djembe modal physical model. Mode parameters are empirically calculated and don't correspond to any measurements or 3D model. They kind of sound good though :).",
      "param_docs": {
        "freq": "fundamental frequency of the model",
        "strikePosition": "strike position (0 for the middle of the membrane and",
        "strikeSharpness": "sharpness of the strike (0-1, default: 0.5)",
        "gain": "gain of the strike",
        "trigger": "trigger signal (0: off, 1: on)"
      },
      "example": "pm = library(\"physmodels.lib\");\ndjembe_test = pm.djembe(110, 0.3, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.djembe_ui_MIDI": {
      "prefix": "pm",
      "name": "djembe_ui_MIDI",
      "full_name": "pm.djembe_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple MIDI controllable djembe physical model with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\ndjembe_ui_MIDI_test = pm.djembe_ui_MIDI;"
    },
    "pm.marimbaBarModel": {
      "prefix": "pm",
      "name": "marimbaBarModel",
      "full_name": "pm.marimbaBarModel",
      "args": [
        "freq",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic marimba tone bar modal model.",
      "param_docs": {
        "excitation": "excitation signal",
        "freq": "fundamental frequency of the bar",
        "exPos": "excitation position (0-4)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmarimbaBarModel_test = pm.marimbaBarModel(220);"
    },
    "pm.marimbaResTube": {
      "prefix": "pm",
      "name": "marimbaResTube",
      "full_name": "pm.marimbaResTube",
      "args": [
        "tubeLength",
        "excitation"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple marimba resonance tube.",
      "param_docs": {
        "tubeLength": "the length of the tube in meters",
        "excitation": "the excitation signal (audio in)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmarimbaResTube_test = pm.marimbaResTube(220);"
    },
    "pm.marimbaModel": {
      "prefix": "pm",
      "name": "marimbaModel",
      "full_name": "pm.marimbaModel",
      "args": [
        "freq",
        "exPos"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple marimba physical model implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see [`marimbaBarModel`](#marimbabarmodel) to know mor",
      "param_docs": {
        "excitation": "the excitation signal",
        "freq": "the frequency of the bar/tube couple",
        "exPos": "excitation position (0-4)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmarimbaModel_test = pm.marimbaModel(220);"
    },
    "pm.marimba": {
      "prefix": "pm",
      "name": "marimba",
      "full_name": "pm.marimba",
      "args": [
        "freq",
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple marimba physical model implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see [`marimbaBarModel`](#marimbabarmodel) to know mor",
      "param_docs": {
        "freq": "the frequency of the bar/tube couple",
        "strikePosition": "strike position (0-4)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nmarimba_test = pm.marimba(220, 0.4, 1, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.marimba_ui_MIDI": {
      "prefix": "pm",
      "name": "marimba_ui_MIDI",
      "full_name": "pm.marimba_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple MIDI controllable marimba physical model with built-in UI implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nmarimba_ui_MIDI_test = pm.marimba_ui_MIDI;"
    },
    "pm.churchBellModel": {
      "prefix": "pm",
      "name": "churchBellModel",
      "full_name": "pm.churchBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic church bell modal model generated by `mesh2faust` from `libraries/modalmodels/churchBell`.",
      "param_docs": {
        "excitation": "the excitation signal",
        "nModes": "number of synthesized modes (max: 50)",
        "exPos": "excitation position (0-6)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nchurchBellModel_test = pm.churchBellModel(110);"
    },
    "pm.churchBell": {
      "prefix": "pm",
      "name": "churchBell",
      "full_name": "pm.churchBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Generic church bell modal model.",
      "param_docs": {
        "strikePosition": "strike position (0-6)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nchurchBell_test = pm.churchBell(0.4, 2000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.churchBell_ui": {
      "prefix": "pm",
      "name": "churchBell_ui",
      "full_name": "pm.churchBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Church bell physical model based on [`churchBell`](#pmchurchbell) with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nchurchBell_ui_test = pm.churchBell_ui;"
    },
    "pm.englishBellModel": {
      "prefix": "pm",
      "name": "englishBellModel",
      "full_name": "pm.englishBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "English church bell modal model generated by `mesh2faust` from `libraries/modalmodels/englishBell`.",
      "param_docs": {
        "excitation": "the excitation signal",
        "nModes": "number of synthesized modes (max: 50)",
        "exPos": "excitation position (0-6)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nenglishBellModel_test = pm.englishBellModel(110);"
    },
    "pm.englishBell": {
      "prefix": "pm",
      "name": "englishBell",
      "full_name": "pm.englishBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "English church bell modal model.",
      "param_docs": {
        "strikePosition": "strike position (0-6)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nenglishBell_test = pm.englishBell(0.4, 2000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.englishBell_ui": {
      "prefix": "pm",
      "name": "englishBell_ui",
      "full_name": "pm.englishBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "English church bell physical model based on [`englishBell`](#pmenglishbell) with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nenglishBell_ui_test = pm.englishBell_ui;"
    },
    "pm.frenchBellModel": {
      "prefix": "pm",
      "name": "frenchBellModel",
      "full_name": "pm.frenchBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "French church bell modal model generated by `mesh2faust` from `libraries/modalmodels/frenchBell`.",
      "param_docs": {
        "excitation": "the excitation signal",
        "nModes": "number of synthesized modes (max: 50)",
        "exPos": "excitation position (0-6)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nfrenchBellModel_test = pm.frenchBellModel(110);"
    },
    "pm.frenchBell": {
      "prefix": "pm",
      "name": "frenchBell",
      "full_name": "pm.frenchBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "French church bell modal model.",
      "param_docs": {
        "strikePosition": "strike position (0-6)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nfrenchBell_test = pm.frenchBell(0.4, 2000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.frenchBell_ui": {
      "prefix": "pm",
      "name": "frenchBell_ui",
      "full_name": "pm.frenchBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "French church bell physical model based on [`frenchBell`](#pmfrenchbell) with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nfrenchBell_ui_test = pm.frenchBell_ui;"
    },
    "pm.germanBellModel": {
      "prefix": "pm",
      "name": "germanBellModel",
      "full_name": "pm.germanBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "German church bell modal model generated by `mesh2faust` from `libraries/modalmodels/germanBell`.",
      "param_docs": {
        "excitation": "the excitation signal",
        "nModes": "number of synthesized modes (max: 50)",
        "exPos": "excitation position (0-6)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\ngermanBellModel_test = pm.germanBellModel(110);"
    },
    "pm.germanBell": {
      "prefix": "pm",
      "name": "germanBell",
      "full_name": "pm.germanBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "German church bell modal model.",
      "param_docs": {
        "strikePosition": "strike position (0-6)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\ngermanBell_test = pm.germanBell(0.4, 2000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.germanBell_ui": {
      "prefix": "pm",
      "name": "germanBell_ui",
      "full_name": "pm.germanBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "German church bell physical model based on [`germanBell`](#pmgermanbell) with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\ngermanBell_ui_test = pm.germanBell_ui;"
    },
    "pm.russianBellModel": {
      "prefix": "pm",
      "name": "russianBellModel",
      "full_name": "pm.russianBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Russian church bell modal model generated by `mesh2faust` from `libraries/modalmodels/russianBell`.",
      "param_docs": {
        "excitation": "the excitation signal",
        "nModes": "number of synthesized modes (max: 50)",
        "exPos": "excitation position (0-6)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nrussianBellModel_test = pm.russianBellModel(110);"
    },
    "pm.russianBell": {
      "prefix": "pm",
      "name": "russianBell",
      "full_name": "pm.russianBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Russian church bell modal model.",
      "param_docs": {
        "strikePosition": "strike position (0-6)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nrussianBell_test = pm.russianBell(0.4, 2000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.russianBell_ui": {
      "prefix": "pm",
      "name": "russianBell_ui",
      "full_name": "pm.russianBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Russian church bell physical model based on [`russianBell`](#pmrussianbell) with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nrussianBell_ui_test = pm.russianBell_ui;"
    },
    "pm.standardBellModel": {
      "prefix": "pm",
      "name": "standardBellModel",
      "full_name": "pm.standardBellModel",
      "args": [
        "nModes",
        "exPos",
        "t60",
        "t60DecayRatio",
        "t60DecaySlope"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard church bell modal model generated by `mesh2faust` from `libraries/modalmodels/standardBell`.",
      "param_docs": {
        "excitation": "the excitation signal",
        "nModes": "number of synthesized modes (max: 50)",
        "exPos": "excitation position (0-6)",
        "t60": "T60 in seconds (recommended value: 0.1)",
        "t60DecayRatio": "T60 decay ratio (recommended value: 1)",
        "t60DecaySlope": "T60 decay slope (recommended value: 5)"
      },
      "example": "pm = library(\"physmodels.lib\");\nstandardBellModel_test = pm.standardBellModel(110);"
    },
    "pm.standardBell": {
      "prefix": "pm",
      "name": "standardBell",
      "full_name": "pm.standardBell",
      "args": [
        "strikePosition",
        "strikeCutoff",
        "strikeSharpness",
        "gain",
        "trigger"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard church bell modal model.",
      "param_docs": {
        "strikePosition": "strike position (0-6)",
        "strikeCutoff": "cuttoff frequency of the strike genarator (recommended: ~7000Hz)",
        "strikeSharpness": "sharpness of the strike (recommended: ~0.25)",
        "gain": "gain of the strike (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nstandardBell_test = pm.standardBell(0.4, 2000, 0.5, 0.8, button(\"gate\"));"
    },
    "pm.standardBell_ui": {
      "prefix": "pm",
      "name": "standardBell_ui",
      "full_name": "pm.standardBell_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard church bell physical model based on [`standardBell`](#pmstandardbell) with built-in UI.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nstandardBell_ui_test = pm.standardBell_ui;"
    },
    "pm.formantValues": {
      "prefix": "pm",
      "name": "formantValues",
      "full_name": "pm.formantValues",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Formant data values in an environment.",
      "param_docs": {
        "i": "formant number",
        "j": "(voiceType*nFormants)+vowel",
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3:",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)"
      },
      "example": "pm = library(\"physmodels.lib\");\nformantValues_test = pm.formantValues.f(0);"
    },
    "pm.voiceGender": {
      "prefix": "pm",
      "name": "voiceGender",
      "full_name": "pm.voiceGender",
      "args": [
        "voiceType"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Calculate the gender for the provided `voiceType` value. (0: male, 1: female)",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)"
      },
      "example": "pm = library(\"physmodels.lib\");\nvoiceGender_test = pm.voiceGender(0.5);"
    },
    "pm.skirtWidthMultiplier": {
      "prefix": "pm",
      "name": "skirtWidthMultiplier",
      "full_name": "pm.skirtWidthMultiplier",
      "args": [
        "vowel",
        "freq",
        "gender"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Calculates value to multiply bandwidth to obtain `skirtwidth` for a Fof filter.",
      "param_docs": {
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "freq": "the fundamental frequency of the excitation signal",
        "gender": "gender of the voice used in the fof filter (0: male, 1: female)"
      },
      "example": "pm = library(\"physmodels.lib\");\nskirtWidthMultiplier_test = pm.skirtWidthMultiplier(0.5);"
    },
    "pm.autobendFreq": {
      "prefix": "pm",
      "name": "autobendFreq",
      "full_name": "pm.autobendFreq",
      "args": [
        "n",
        "freq",
        "voiceType"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Autobends the center frequencies of formants 1 and 2 based on the fundamental frequency of the excitation signal and leaves all other formant frequencies unchanged. Ported from `chant-lib`.",
      "param_docs": {
        "n": "formant index",
        "freq": "the fundamental frequency of the excitation signal",
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)"
      },
      "example": "pm = library(\"physmodels.lib\");\nautobendFreq_test = pm.autobendFreq(440, 0.5);"
    },
    "pm.vocalEffort": {
      "prefix": "pm",
      "name": "vocalEffort",
      "full_name": "pm.vocalEffort",
      "args": [
        "freq",
        "gender"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Changes the gains of the formants based on the fundamental frequency of the excitation signal. Higher formants are reinforced for higher fundamental frequencies.",
      "param_docs": {
        "freq": "the fundamental frequency of the excitation signal",
        "gender": "the gender of the voice type (0: male, 1: female)"
      },
      "example": "pm = library(\"physmodels.lib\");\nvocalEffort_test = pm.vocalEffort(0.6);"
    },
    "pm.fof": {
      "prefix": "pm",
      "name": "fof",
      "full_name": "pm.fof",
      "args": [
        "fc",
        "bw",
        "a",
        "g"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Function to generate a single Formant-Wave-Function.",
      "param_docs": {
        "fc": "formant center frequency,",
        "bw": "formant bandwidth (Hz),",
        "sw": "formant skirtwidth (Hz)",
        "g": "linear scale factor (g=1 gives 0dB amplitude response at fc)"
      },
      "example": "pm = library(\"physmodels.lib\");\nfof_test = pm.fof(0.3, 440, 880, 0.5);"
    },
    "pm.fofSH": {
      "prefix": "pm",
      "name": "fofSH",
      "full_name": "pm.fofSH",
      "args": [
        "fc",
        "bw",
        "a",
        "g"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "FOF with sample and hold used on `bw` and a parameter used in the filter-cycling FOF function `fofCycle`.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nfofSH_test = pm.fofSH(0.3, 440, 880, 0.5);"
    },
    "pm.fofCycle": {
      "prefix": "pm",
      "name": "fofCycle",
      "full_name": "pm.fofCycle",
      "args": [
        "fc",
        "bw",
        "a",
        "g",
        "n"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "FOF implementation where time-varying filter parameter noise is mitigated by using a cycle of `n` sample and hold FOF filters.",
      "param_docs": {
        "n": "the number of FOF filters to cycle through"
      },
      "example": "pm = library(\"physmodels.lib\");\nfofCycle_test = pm.fofCycle(0.3, 440, 880, 0.5, 0.2);"
    },
    "pm.fofSmooth": {
      "prefix": "pm",
      "name": "fofSmooth",
      "full_name": "pm.fofSmooth",
      "args": [
        "fc",
        "bw",
        "sw",
        "g",
        "tau"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "FOF implementation where time-varying filter parameter noise is mitigated by lowpass filtering the filter parameters `bw` and `a` with [smooth](#smooth).",
      "param_docs": {
        "tau": "the desired smoothing time constant in seconds"
      },
      "example": "pm = library(\"physmodels.lib\");\nfofSmooth_test = pm.fofSmooth(0.3, 440, 880, 0.5, 0.2);"
    },
    "pm.formantFilterFofCycle": {
      "prefix": "pm",
      "name": "formantFilterFofCycle",
      "full_name": "pm.formantFilterFofCycle",
      "args": [
        "voiceType",
        "vowel",
        "nFormants",
        "i",
        "freq"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filter based on a single FOF filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. A cycle of `n` fof filters with sample-and-hold is",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor,",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "nFormants": "number of formant regions in frequency domain, typically 5",
        "i": "formant number (i.e. 0 - 4) used to index formant data value arrays",
        "freq": "fundamental frequency of excitation signal. Used to calculate"
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterFofCycle_test = pm.formantFilterFofCycle(0, 0, 5, 0, 200);"
    },
    "pm.formantFilterFofSmooth": {
      "prefix": "pm",
      "name": "formantFilterFofSmooth",
      "full_name": "pm.formantFilterFofSmooth",
      "args": [
        "voiceType",
        "vowel",
        "nFormants",
        "i",
        "freq"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filter based on a single FOF filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Fof filter parameters are lowpass filtered",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor,",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "nFormants": "number of formant regions in frequency domain, typically 5",
        "i": "formant number (i.e. 1 - 5) used to index formant data value arrays",
        "freq": "fundamental frequency of excitation signal. Used to calculate"
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterFofSmooth_test = pm.formantFilterFofSmooth(0, 0, 5, 0, 200);"
    },
    "pm.formantFilterBP": {
      "prefix": "pm",
      "name": "formantFilterBP",
      "full_name": "pm.formantFilterBP",
      "args": [
        "voiceType",
        "vowel",
        "nFormants",
        "i",
        "freq"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filter based on a single resonant bandpass filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspon",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "nFormants": "number of formant regions in frequency domain, typically 5",
        "i": "formant index used to index formant data value arrays",
        "freq": "fundamental frequency of excitation signal."
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterBP_test = pm.formantFilterBP(0, 0, 5, 0, 200);"
    },
    "pm.formantFilterbank": {
      "prefix": "pm",
      "name": "formantFilterbank",
      "full_name": "pm.formantFilterbank",
      "args": [
        "voiceType",
        "vowel",
        "formantGen",
        "freq"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank which can use different types of filterbank functions and different excitation signals. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to anothe",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "formantGen": "the specific formant filterbank function",
        "freq": "fundamental frequency of excitation signal. Needed for FOF"
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterbank_test = pm.formantFilterbank(0, 0, 5, 0);"
    },
    "pm.formantFilterbankFofCycle": {
      "prefix": "pm",
      "name": "formantFilterbankFofCycle",
      "full_name": "pm.formantFilterbankFofCycle",
      "args": [
        "voiceType",
        "vowel",
        "freq"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank based on a bank of fof filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "freq": "the fundamental frequency of the excitation signal. Needed to calculate the skirtwidth"
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterbankFofCycle_test = pm.formantFilterbankFofCycle(0, 0, 5));"
    },
    "pm.formantFilterbankFofSmooth": {
      "prefix": "pm",
      "name": "formantFilterbankFofSmooth",
      "full_name": "pm.formantFilterbankFofSmooth",
      "args": [
        "voiceType",
        "vowel",
        "freq"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank based on a bank of fof filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "freq": "the fundamental frequency of the excitation signal. Needed to"
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterbankFofSmooth_test = pm.formantFilterbankFofSmooth(0, 0, 5);"
    },
    "pm.formantFilterbankBP": {
      "prefix": "pm",
      "name": "formantFilterbankBP",
      "full_name": "pm.formantFilterbankBP",
      "args": [
        "voiceType",
        "vowel",
        "freq"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Formant filterbank based on a bank of resonant bandpass filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must cor",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u)",
        "freq": "the fundamental frequency of the excitation signal. Needed for the autobendFreq and vocalEffort functions."
      },
      "example": "pm = library(\"physmodels.lib\");\nformantFilterbankBP_test = pm.formantFilterbankBP(0, 0, 5);"
    },
    "pm.SFFormantModel": {
      "prefix": "pm",
      "name": "SFFormantModel",
      "full_name": "pm.SFFormantModel",
      "args": [
        "voiceType",
        "vowel",
        "exType",
        "freq",
        "gain",
        "source",
        "filterbank",
        "isFof"
      ],
      "arg_count": 8,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The `source` and `filterbank` must be specified by the user. `filterbank` must take the same input parameters as [`formantFilterbank`](",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u",
        "exType": "voice vs. fricative sound ratio (0-1 where 1 is 100% fricative)",
        "freq": "the fundamental frequency of the source signal",
        "gain": "linear gain multiplier to multiply the source by",
        "isFof": "whether model is FOF based (0: no, 1: yes)"
      },
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModel_test = pm.SFFormantModel(0, 0, 0.5, 0.6, 100, 2, 1, 1);"
    },
    "pm.SFFormantModelFofCycle": {
      "prefix": "pm",
      "name": "SFFormantModelFofCycle",
      "full_name": "pm.SFFormantModelFofCycle",
      "args": [
        "voiceType",
        "vowel",
        "freq",
        "gain"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The source is just a periodic impulse and the \"filter\" is a bank of FOF filters. Formant parameters are linearly interpolated allowing ",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u",
        "freq": "the fundamental frequency of the source signal",
        "gain": "linear gain multiplier to multiply the source by"
      },
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelFofCycle_test = pm.SFFormantModelFofCycle(0.5, 0.6, 0.7);"
    },
    "pm.SFFormantModelFofSmooth": {
      "prefix": "pm",
      "name": "SFFormantModelFofSmooth",
      "full_name": "pm.SFFormantModelFofSmooth",
      "args": [
        "voiceType",
        "vowel",
        "freq",
        "gain"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The source is just a periodic impulse and the \"filter\" is a bank of FOF filters. Formant parameters are linearly interpolated allowing ",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u",
        "freq": "the fundamental frequency of the source signal",
        "gain": "linear gain multiplier to multiply the source by"
      },
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelFofSmooth_test = pm.SFFormantModelFofSmooth(0.5, 0.6, 0.7);"
    },
    "pm.SFFormantModelBP": {
      "prefix": "pm",
      "name": "SFFormantModelBP",
      "full_name": "pm.SFFormantModelBP",
      "args": [
        "voiceType",
        "vowel",
        "exType",
        "freq",
        "gain"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Simple formant/vocal synthesizer based on a source/filter model. The source is just a sawtooth wave and the \"filter\" is a bank of resonant bandpass filters. Formant parameters are linearly interpolate",
      "param_docs": {
        "voiceType": "the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)",
        "vowel": "the vowel (0: a, 1: e, 2: i, 3: o, 4: u",
        "exType": "voice vs. fricative sound ratio (0-1 where 1 is 100% fricative)",
        "freq": "the fundamental frequency of the source signal",
        "gain": "linear gain multiplier to multiply the source by"
      },
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelBP_test = pm.SFFormantModelBP(0.5, 0.6, 0.7);"
    },
    "pm.SFFormantModelFofCycle_ui": {
      "prefix": "pm",
      "name": "SFFormantModelFofCycle_ui",
      "full_name": "pm.SFFormantModelFofCycle_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use source-filter vocal synthesizer with built-in user interface.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelFofCycle_ui_test = pm.SFFormantModelFofCycle_ui;"
    },
    "pm.SFFormantModelFofSmooth_ui": {
      "prefix": "pm",
      "name": "SFFormantModelFofSmooth_ui",
      "full_name": "pm.SFFormantModelFofSmooth_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use source-filter vocal synthesizer with built-in user interface.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelFofSmooth_ui_test = pm.SFFormantModelFofSmooth_ui;"
    },
    "pm.SFFormantModelBP_ui": {
      "prefix": "pm",
      "name": "SFFormantModelBP_ui",
      "full_name": "pm.SFFormantModelBP_ui",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use source-filter vocal synthesizer with built-in user interface.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelBP_ui_test = pm.SFFormantModelBP_ui;"
    },
    "pm.SFFormantModelFofCycle_ui_MIDI": {
      "prefix": "pm",
      "name": "SFFormantModelFofCycle_ui_MIDI",
      "full_name": "pm.SFFormantModelFofCycle_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable source-filter vocal synthesizer.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelFofCycle_ui_MIDI_test = pm.SFFormantModelFofCycle_ui_MIDI;"
    },
    "pm.SFFormantModelFofSmooth_ui_MIDI": {
      "prefix": "pm",
      "name": "SFFormantModelFofSmooth_ui_MIDI",
      "full_name": "pm.SFFormantModelFofSmooth_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable source-filter vocal synthesizer.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelFofSmooth_ui_MIDI_test = pm.SFFormantModelFofSmooth_ui_MIDI;"
    },
    "pm.SFFormantModelBP_ui_MIDI": {
      "prefix": "pm",
      "name": "SFFormantModelBP_ui_MIDI",
      "full_name": "pm.SFFormantModelBP_ui_MIDI",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Ready-to-use MIDI-controllable source-filter vocal synthesizer.",
      "param_docs": {},
      "example": "pm = library(\"physmodels.lib\");\nSFFormantModelBP_ui_MIDI_test = pm.SFFormantModelBP_ui_MIDI;"
    },
    "pm.allpassNL": {
      "prefix": "pm",
      "name": "allpassNL",
      "full_name": "pm.allpassNL",
      "args": [
        "... : allpassNL(nonlinearity"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Bidirectional block adding nonlinearities in both directions in a chain. Nonlinearities are created by modulating the coefficients of a passive allpass filter by the signal it is processing.",
      "param_docs": {
        "nonlinearity": "amount of nonlinearity to be added (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nallpassNL_test = 0,0,0 : pm.allpassNL(0.4);"
    },
    "pm.modalModel": {
      "prefix": "pm",
      "name": "modalModel",
      "full_name": "pm.modalModel",
      "args": [
        "n",
        "freqs",
        "t60s",
        "gains"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Implement multiple resonance modes using resonant bandpass filters.",
      "param_docs": {
        "n": "number of given modes",
        "freqs": "list of filter center freqencies",
        "t60s": "list of mode resonance durations (in seconds)",
        "gains": "list of mode gains (0-1)"
      },
      "example": "pm = library(\"physmodels.lib\");\nos = library(\"oscillators.lib\");\nmodalModel_test = os.impulse : pm.modalModel(3, (440,660,880), (0.5,0.4,0.3), (0.8,0.6,0.4));"
    },
    "pm.rk_solve": {
      "prefix": "pm",
      "name": "rk_solve",
      "full_name": "pm.rk_solve",
      "args": [
        "ts",
        "ks",
        "ni",
        "h",
        "eq",
        "iv"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Solves the system of ordinary differential equations of any order using the explicit Runge-Kutta methods.",
      "param_docs": {
        "ni": "number of iterations at each tick, compile time constant",
        "h": "time step, run time constant, e.g. 1/ma.SR",
        "eq": "list of derivative functions",
        "iv": "list of initial values"
      },
      "example": "pm = library(\"physmodels.lib\");\nma = library(\"maths.lib\");\nrk_solve_test = pm.rk_solve((0), (1), 1, 1.0/ma.SR, eq, (1)) with { eq(t,x) = -x; };"
    },
    "pm.formantValues.f": {
      "prefix": "pm",
      "name": "formantValues.f",
      "full_name": "pm.formantValues.f",
      "args": [
        "4"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "formantValues f filter",
      "param_docs": {},
      "example": ""
    },
    "pm.formantValues.g": {
      "prefix": "pm",
      "name": "formantValues.g",
      "full_name": "pm.formantValues.g",
      "args": [
        "4"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "formantValues g filter",
      "param_docs": {},
      "example": ""
    },
    "pm.formantValues.bw": {
      "prefix": "pm",
      "name": "formantValues.bw",
      "full_name": "pm.formantValues.bw",
      "args": [
        "4"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "formantValues bw filter",
      "param_docs": {},
      "example": ""
    },
    "pl.SR": {
      "prefix": "pl",
      "name": "SR",
      "full_name": "pl.SR",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current sampling rate (between 1 and 192000Hz). Constant during program execution. Setting this value to a constant will allow the compiler to optimize the code by computing constant expressions at",
      "param_docs": {},
      "example": ""
    },
    "pl.BS": {
      "prefix": "pl",
      "name": "BS",
      "full_name": "pl.BS",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Current block-size (between 1 and 16384 frames). Can change during the execution.",
      "param_docs": {},
      "example": ""
    },
    "pl.tablesize": {
      "prefix": "pl",
      "name": "tablesize",
      "full_name": "pl.tablesize",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Oscillator table size. This value is used to define the size of the table used by the oscillators. It is usually a power of 2 and can be lowered to save memory. The default value is 65536.",
      "param_docs": {},
      "example": ""
    },
    "qu.quantize": {
      "prefix": "qu",
      "name": "quantize",
      "full_name": "qu.quantize",
      "args": [
        "rf",
        "nl"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Configurable frequency quantization tool. Snaps input frequencies to exact scale notes. Works for positive audio frequencies.",
      "param_docs": {
        "rf": "frequency of the root note of the scale",
        "nl": "list of frequency ratios for each note relative to root"
      },
      "example": "qu = library(\"quantizers.lib\");\nquantize_test = qu.quantize(440, qu.ionian, hslider(\"input\", 450, 100, 1000, 1));"
    },
    "qu.quantizeSmoothed": {
      "prefix": "qu",
      "name": "quantizeSmoothed",
      "full_name": "qu.quantizeSmoothed",
      "args": [
        "rf",
        "nl"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Configurable frequency quantization tool. Smoothly transitions between scale notes. Works for positive audio frequencies.",
      "param_docs": {
        "rf": "frequency of the root note of the scale",
        "nl": "list of frequency ratios for each note relative to root"
      },
      "example": "qu = library(\"quantizers.lib\");\nquantizeSmoothed_test = qu.quantizeSmoothed(440, qu.ionian, hslider(\"input\", 450, 100, 1000, 1));"
    },
    "qu.ionian": {
      "prefix": "qu",
      "name": "ionian",
      "full_name": "qu.ionian",
      "args": [
        "rf",
        "ionian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the ionian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nionian_test = qu.quantize(220, qu.ionian, 260);"
    },
    "qu.dorian": {
      "prefix": "qu",
      "name": "dorian",
      "full_name": "qu.dorian",
      "args": [
        "rf",
        "dorian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the dorian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\ndorian_test = qu.quantize(220, qu.dorian, 260);"
    },
    "qu.phrygian": {
      "prefix": "qu",
      "name": "phrygian",
      "full_name": "qu.phrygian",
      "args": [
        "rf",
        "phrygian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the phrygian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nphrygian_test = qu.quantize(220, qu.phrygian, 260);"
    },
    "qu.lydian": {
      "prefix": "qu",
      "name": "lydian",
      "full_name": "qu.lydian",
      "args": [
        "rf",
        "lydian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the lydian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nlydian_test = qu.quantize(220, qu.lydian, 260);"
    },
    "qu.mixo": {
      "prefix": "qu",
      "name": "mixo",
      "full_name": "qu.mixo",
      "args": [
        "rf",
        "mixo"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the mixolydian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nmixo_test = qu.quantize(220, qu.mixo, 260);"
    },
    "qu.eolian": {
      "prefix": "qu",
      "name": "eolian",
      "full_name": "qu.eolian",
      "args": [
        "rf",
        "eolian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the eolian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\neolian_test = qu.quantize(220, qu.eolian, 260);"
    },
    "qu.locrian": {
      "prefix": "qu",
      "name": "locrian",
      "full_name": "qu.locrian",
      "args": [
        "rf",
        "locrian"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the locrian mode.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nlocrian_test = qu.quantize(220, qu.locrian, 260);"
    },
    "qu.pentanat": {
      "prefix": "qu",
      "name": "pentanat",
      "full_name": "qu.pentanat",
      "args": [
        "rf",
        "pentanat"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the pythagorean tuning for the minor pentatonic scale.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\npentanat_test = qu.quantize(220, qu.pentanat, 260);"
    },
    "qu.kumoi": {
      "prefix": "qu",
      "name": "kumoi",
      "full_name": "qu.kumoi",
      "args": [
        "rf",
        "kumoi"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the kumoijoshi, the japanese pentatonic scale.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nkumoi_test = qu.quantize(220, qu.kumoi, 260);"
    },
    "qu.natural": {
      "prefix": "qu",
      "name": "natural",
      "full_name": "qu.natural",
      "args": [
        "rf",
        "natural"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the natural major scale.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\nnatural_test = qu.quantize(220, qu.natural, 260);"
    },
    "qu.dodeca": {
      "prefix": "qu",
      "name": "dodeca",
      "full_name": "qu.dodeca",
      "args": [
        "rf",
        "dodeca"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the dodecaphonic scale.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\ndodeca_test = qu.quantize(220, qu.dodeca, 260);"
    },
    "qu.dimin": {
      "prefix": "qu",
      "name": "dimin",
      "full_name": "qu.dimin",
      "args": [
        "rf",
        "dimin"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the diminished scale.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\ndimin_test = qu.quantize(220, qu.dimin, 260);"
    },
    "qu.penta": {
      "prefix": "qu",
      "name": "penta",
      "full_name": "qu.penta",
      "args": [
        "rf",
        "penta"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "List of the frequency ratios of the notes of the minor pentatonic scale.",
      "param_docs": {
        "rf": "frequency of the root note of the scale"
      },
      "example": "qu = library(\"quantizers.lib\");\npenta_test = qu.quantize(220, qu.penta, 260);"
    },
    "qu.quantizer.smoothCurve": {
      "prefix": "qu",
      "name": "quantizer.smoothCurve",
      "full_name": "qu.quantizer.smoothCurve",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer smoothCurve filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.getOctave": {
      "prefix": "qu",
      "name": "quantizer.getOctave",
      "full_name": "qu.quantizer.getOctave",
      "args": [
        "freq",
        "rf"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer getOctave filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.normalizedRatio": {
      "prefix": "qu",
      "name": "quantizer.normalizedRatio",
      "full_name": "qu.quantizer.normalizedRatio",
      "args": [
        "freq",
        "rf"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer normalizedRatio filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.findClosestRatio": {
      "prefix": "qu",
      "name": "quantizer.findClosestRatio",
      "full_name": "qu.quantizer.findClosestRatio",
      "args": [
        "freq",
        "rf",
        "nl"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer findClosestRatio filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.findRatio": {
      "prefix": "qu",
      "name": "quantizer.findRatio",
      "full_name": "qu.quantizer.findRatio",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer findRatio filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.smoothInterpolation": {
      "prefix": "qu",
      "name": "quantizer.smoothInterpolation",
      "full_name": "qu.quantizer.smoothInterpolation",
      "args": [
        "freq",
        "rf",
        "nl"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer smoothInterpolation filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.smoothRatio": {
      "prefix": "qu",
      "name": "quantizer.smoothRatio",
      "full_name": "qu.quantizer.smoothRatio",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer smoothRatio filter",
      "param_docs": {},
      "example": ""
    },
    "qu.quantizer.interpolateBetween": {
      "prefix": "qu",
      "name": "quantizer.interpolateBetween",
      "full_name": "qu.quantizer.interpolateBetween",
      "args": [
        "ratio1",
        "ratio2"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "quantizer interpolateBetween filter",
      "param_docs": {},
      "example": ""
    },
    "rm.parReduce": {
      "prefix": "rm",
      "name": "parReduce",
      "full_name": "rm.parReduce",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "`parReduce(op,N)` combines a set of `N` parallel signals into a single one using a binary operation `op`.",
      "param_docs": {
        "op": "is a binary operation",
        "N": "is the number of incomming signals (`N>0`). We use a capital letter"
      },
      "example": "rm = library(\"reducemaps.lib\");\nparReduce_test = (1,2,3,4) : rm.parReduce(+, 4);"
    },
    "rm.topReduce": {
      "prefix": "rm",
      "name": "topReduce",
      "full_name": "rm.topReduce",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "`topReduce(op,N)` involves combining a set of `N` parallel signals into a single one using a binary operation `op`. With `topReduce`, the reduction process starts from the top two incoming signals, do",
      "param_docs": {
        "op": "is a binary operation",
        "N": "is the number of incomming signals (`N>0`). We use a capital letter"
      },
      "example": "rm = library(\"reducemaps.lib\");\ntopReduce_test = (1,2,3,4) : rm.topReduce(+, 4);"
    },
    "rm.botReduce": {
      "prefix": "rm",
      "name": "botReduce",
      "full_name": "rm.botReduce",
      "args": [
        "op",
        "N"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 1,
      "description": "`botReduce(op,N)` combines a set of `N` parallel signals into a single one using a binary operation `op`. With `botReduce`, the reduction process starts from the bottom two incoming signals, up to the",
      "param_docs": {},
      "example": "rm = library(\"reducemaps.lib\");\nbotReduce_test = (1,2,3,4) : rm.botReduce(+, 4);"
    },
    "rm.reduce": {
      "prefix": "rm",
      "name": "reduce",
      "full_name": "rm.reduce",
      "args": [
        "op",
        "n"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Reduce a block of `n` consecutive samples of the incomming signal using a binary operation `op`. For example: `reduce(max,128)` will compute the maximun value of each block of 128 samples. Please note",
      "param_docs": {
        "op": "is a binary operation",
        "n": "is the number of consecutive samples in a block."
      },
      "example": "rm = library(\"reducemaps.lib\");\nreduce_test = rm.reduce(max, 4, hslider(\"reduce:input\", 0, -1, 1, 0.01));"
    },
    "rm.reducemap": {
      "prefix": "rm",
      "name": "reducemap",
      "full_name": "rm.reducemap",
      "args": [
        "op",
        "foo",
        "n"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Like `reduce` but a `foo` function is applied to the result. From a mathematical point of view: `reducemap(op,foo,n)` is equivalent to `reduce(op,n):foo`",
      "param_docs": {
        "op": "is a binary operation",
        "foo": "is a function applied to the result of the reduction",
        "n": "is the number of consecutive samples in a block."
      },
      "example": "rm = library(\"reducemaps.lib\");\nreducemap_test = rm.reducemap(+, /(4), 4, hslider(\"reducemap:input\", 0, -1, 1, 0.01));"
    },
    "re.jcrev": {
      "prefix": "re",
      "name": "jcrev",
      "full_name": "re.jcrev",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 4,
      "description": "This artificial reverberator take a mono signal and output stereo (`satrev`) and quad (`jcrev`). They were implemented by John Chowning in the MUS10 computer-music language (descended from Music V by ",
      "param_docs": {},
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\njcrev_test = os.osc(440) : re.jcrev;"
    },
    "re.satrev": {
      "prefix": "re",
      "name": "satrev",
      "full_name": "re.satrev",
      "args": [],
      "arg_count": 0,
      "inputs": 1,
      "outputs": 2,
      "description": "This artificial reverberator take a mono signal and output stereo (`satrev`) and quad (`jcrev`).  They were implemented by John Chowning in the MUS10 computer-music language (descended from Music V by",
      "param_docs": {},
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nsatrev_test = os.osc(330) : re.satrev;"
    },
    "re.fdnrev0": {
      "prefix": "re",
      "name": "fdnrev0",
      "full_name": "re.fdnrev0",
      "args": [
        "MAXDELAY",
        "delays",
        "BBSO",
        "freqs",
        "durs",
        "loopgainmax",
        "nonl"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "Pure Feedback Delay Network Reverberator (generalized for easy scaling). `fdnrev0` is a standard Faust function.",
      "param_docs": {
        "N": "2, 4, 8, ...  (power of 2)",
        "MAXDELAY": "power of 2 at least as large as longest delay-line length",
        "delays": "N delay lines, N a power of 2, lengths preferably coprime",
        "BBSO": "odd positive integer = order of bandsplit desired at freqs",
        "freqs": "NB-1 crossover frequencies separating desired frequency bands",
        "durs": "NB decay times (t60) desired for the various bands",
        "loopgainmax": "scalar gain between 0 and 1 used to \"squelch\" the reverb",
        "nonl": "nonlinearity (0 to 0.999..., 0 being linear)"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nfdnrev0_test = (os.osc(220), os.osc(330), os.osc(440), os.osc(550))\n<: re.fdnrev0(4096, (149, 211, 263, 293), 1, (800, 4000), (2.5, 2.0, 1.5), 0.8, 0.0);"
    },
    "re.zita_rev_fdn": {
      "prefix": "re",
      "name": "zita_rev_fdn",
      "full_name": "re.zita_rev_fdn",
      "args": [
        "f1",
        "f2",
        "t60dc",
        "t60m",
        "fsmax"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 2,
      "description": "Internal 8x8 late-reverberation FDN used in the FOSS Linux reverb `zita-rev1` by Fons Adriaensen <fons@linuxaudio.org>.  This is an FDN reverb with allpass comb filters in each feedback delay in addit",
      "param_docs": {
        "f1": "crossover frequency (Hz) separating dc and midrange frequencies",
        "f2": "frequency (Hz) above f1 where T60 = t60m/2 (see below)",
        "t60dc": "desired decay time (t60) at frequency 0 (sec)",
        "t60m": "desired decay time (t60) at midrange frequencies (sec)",
        "fsmax": "maximum sampling rate to be used (Hz)"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nzita_rev_fdn_test = par(i, 8, os.osc(110 * (i + 1)))\n<: re.zita_rev_fdn(200, 2000, 3.0, 2.0, 48000);"
    },
    "re.zita_rev1_stereo": {
      "prefix": "re",
      "name": "zita_rev1_stereo",
      "full_name": "re.zita_rev1_stereo",
      "args": [
        "rdel",
        "f1",
        "f2",
        "t60dc",
        "t60m",
        "fsmax"
      ],
      "arg_count": 6,
      "inputs": 2,
      "outputs": 2,
      "description": "Extend `zita_rev_fdn` to include `zita_rev1` input/output mapping in stereo mode. `zita_rev1_stereo` is a standard Faust function.",
      "param_docs": {},
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nzita_rev1_stereo_test = (os.osc(440), os.osc(550))\n: re.zita_rev1_stereo(20, 200, 2000, 3.0, 2.0, 48000);"
    },
    "re.zita_rev1_ambi": {
      "prefix": "re",
      "name": "zita_rev1_ambi",
      "full_name": "re.zita_rev1_ambi",
      "args": [
        "rgxyz",
        "rdel",
        "f1",
        "f2",
        "t60dc",
        "t60m",
        "fsmax"
      ],
      "arg_count": 7,
      "inputs": 2,
      "outputs": 4,
      "description": "Extend `zita_rev_fdn` to include `zita_rev1` input/output mapping in \"ambisonics mode\", as provided in the Linux C++ version.",
      "param_docs": {},
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nzita_rev1_ambi_test = (os.osc(330), os.osc(550))\n: re.zita_rev1_ambi(0.0, 25, 200, 2000, 3.0, 2.0, 48000);"
    },
    "re.vital_rev": {
      "prefix": "re",
      "name": "vital_rev",
      "full_name": "re.vital_rev",
      "args": [
        "prelow",
        "prehigh",
        "lowcutoff",
        "highcutoff",
        "lowgain",
        "highgain",
        "chorus_amt",
        "chorus_freq",
        "predelay",
        "time",
        "size",
        "mix"
      ],
      "arg_count": 12,
      "inputs": 2,
      "outputs": 2,
      "description": "A port of the reverb from the Vital synthesizer. All input parameters have been normalized to a continuous [0,1] range, making them easy to modulate. The scaling of the parameters happens inside the f",
      "param_docs": {
        "prelow": "In the pre-filter, this is the cutoff frequency of a high-pass filter (hence a low value)",
        "prehigh": "In the pre-filter, this is the cutoff frequency of a low-pass filter (hence a high value)",
        "lowcutoff": "In the feedback filter stage, this is the cutoff frequency of a low-shelf filter",
        "highcutoff": "In the feedback filter stage, this is the cutoff frequency of a high-shelf filter",
        "lowgain": "In the feedback filter stage, this is the gain of a low-shelf filter",
        "highgain": "In the feedback filter stage, this is the gain of a high-shelf filter",
        "chorus_amt": "The amount of chorus modulation in the main delay lines",
        "chorus_freq": "The LFO rate of chorus modulation in the main delay lines",
        "predelay": "The amount of pre-delay time",
        "time": "The decay time of the reverb",
        "size": "The size of the room",
        "mix": "A wetness value to use in a final dry/wet mixer"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nvital_rev_test = (os.osc(330), os.osc(440))\n: re.vital_rev(0.2, 0.8, 0.5, 0.7, 0.4, 0.6, 0.3, 0.2, 0.1, 0.7, 0.5, 0.4);"
    },
    "re.mono_freeverb": {
      "prefix": "re",
      "name": "mono_freeverb",
      "full_name": "re.mono_freeverb",
      "args": [
        "fb1",
        "fb2",
        "damp",
        "spread"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "A simple Schroeder reverberator primarily developed by \"Jezar at Dreampoint\" that is extensively used in the free-software world. It uses four Schroeder allpasses in series and eight parallel Schroede",
      "param_docs": {
        "fb1": "coefficient of the lowpass comb filters (0-1)",
        "fb2": "coefficient of the allpass comb filters (0-1)",
        "damp": "damping of the lowpass comb filter (0-1)",
        "spread": "spatial spread in number of samples (for stereo)"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nmono_freeverb_test = os.osc(440) : re.mono_freeverb(0.7, 0.5, 0.3, 30);"
    },
    "re.stereo_freeverb": {
      "prefix": "re",
      "name": "stereo_freeverb",
      "full_name": "re.stereo_freeverb",
      "args": [
        "fb1",
        "fb2",
        "damp",
        "spread"
      ],
      "arg_count": 4,
      "inputs": 2,
      "outputs": 2,
      "description": "A simple Schroeder reverberator primarily developed by \"Jezar at Dreampoint\" that is extensively used in the free-software world. It uses four Schroeder allpasses in series and eight parallel Schroede",
      "param_docs": {
        "fb1": "coefficient of the lowpass comb filters (0-1)",
        "fb2": "coefficient of the allpass comb filters (0-1)",
        "damp": "damping of the lowpass comb filter (0-1)",
        "spread": "spatial spread in number of samples (for stereo)"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nstereo_freeverb_test = (os.osc(330), os.osc(550))\n: re.stereo_freeverb(0.7, 0.5, 0.3, 30);"
    },
    "re.dattorro_rev": {
      "prefix": "re",
      "name": "dattorro_rev",
      "full_name": "re.dattorro_rev",
      "args": [
        "pre_delay",
        "bw",
        "i_diff1",
        "i_diff2",
        "decay",
        "d_diff1",
        "d_diff2",
        "damping"
      ],
      "arg_count": 8,
      "inputs": 2,
      "outputs": 2,
      "description": "Reverberator based on the Dattorro reverb topology. This implementation does not use modulated delay lengths (excursion).",
      "param_docs": {
        "pre_delay": "pre-delay in samples (fixed at compile time)",
        "bw": "band-width filter (pre filtering); (0 - 1)",
        "i_diff1": "input diffusion factor 1; (0 - 1)",
        "i_diff2": "input diffusion factor 2;",
        "decay": "decay rate; (0 - 1); infinite decay = 1.0",
        "d_diff1": "decay diffusion factor 1; (0 - 1)",
        "d_diff2": "decay diffusion factor 2;",
        "damping": "high-frequency damping; no damping = 0.0"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\ndattorro_rev_test = (os.osc(330), os.osc(550))\n: re.dattorro_rev(200, 0.5, 0.7, 0.6, 0.5, 0.7, 0.5, 0.2);"
    },
    "re.dattorro_rev_default": {
      "prefix": "re",
      "name": "dattorro_rev_default",
      "full_name": "re.dattorro_rev_default",
      "args": [],
      "arg_count": 0,
      "inputs": 2,
      "outputs": 2,
      "description": "Reverberator based on the Dattorro reverb topology with reverb parameters from the original paper. This implementation does not use modulated delay lengths (excursion) and",
      "param_docs": {},
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\ndattorro_rev_default_test = (os.osc(330), os.osc(550))\n: re.dattorro_rev_default;"
    },
    "re.jpverb": {
      "prefix": "re",
      "name": "jpverb",
      "full_name": "re.jpverb",
      "args": [
        "t60",
        "damp",
        "size",
        "early_diff",
        "mod_depth",
        "mod_freq",
        "low",
        "mid",
        "high",
        "low_cutoff",
        "high_cutoff"
      ],
      "arg_count": 11,
      "inputs": 2,
      "outputs": 2,
      "description": "An algorithmic reverb (stereo in/out), inspired by the lush chorused sound of certain vintage Lexicon and Alesis reverberation units. Designed to sound great with synthetic sound sources, rather than ",
      "param_docs": {
        "t60": "approximate reverberation time in seconds ([0.1..60] sec) (T60 - the time for the reverb to decay by 60db when damp == 0 ). Does not effect early reflections",
        "damp": "controls damping of high-frequencies as the reverb decays. 0 is no damping, 1 is very strong damping. Values should be in the range ([0..1])",
        "size": "scales size of delay-lines within the reverberator, producing the impression of a larger or smaller space. Values below 1 can sound metallic. Values should be in the range [0.5..5]",
        "early_diff": "controls shape of early reflections. Values of 0.707 or more produce smooth exponential decay. Lower values produce a slower build-up of echoes. Values should be in the range ([0..1])",
        "mod_depth": "depth ([0..1]) of delay-line modulation. Use in combination with `mod_freq` to set amount of chorusing within the structure",
        "mod_freq": "frequency ([0..10] Hz) of delay-line modulation. Use in combination with `mod_depth` to set amount of chorusing within the structure",
        "low": "multiplier ([0..1]) for the reverberation time within the low band",
        "mid": "multiplier ([0..1]) for the reverberation time within the mid band",
        "high": "multiplier ([0..1]) for the reverberation time within the high band",
        "low_cutoff": "frequency (100..6000 Hz) at which the crossover between the low and mid bands of the reverb occurs",
        "high_cutoff": "frequency (1000..10000 Hz) at which the crossover between the mid and high bands of the reverb occurs"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\njpverb_test = (os.osc(330), os.osc(440))\n: re.jpverb(3.0, 0.2, 1.0, 0.8, 0.3, 0.4, 0.9, 0.8, 0.7, 500, 4000);"
    },
    "re.greyhole": {
      "prefix": "re",
      "name": "greyhole",
      "full_name": "re.greyhole",
      "args": [
        "dt",
        "damp",
        "size",
        "early_diff",
        "feedback",
        "mod_depth",
        "mod_freq"
      ],
      "arg_count": 7,
      "inputs": 2,
      "outputs": 2,
      "description": "A complex echo-like effect (stereo in/out), inspired by the classic Eventide effect of a similar name. The effect consists of a diffuser (like a mini-reverb, structurally similar to the one used in `j",
      "param_docs": {
        "dt": "approximate reverberation time in seconds ([0.1..60 sec])",
        "damp": "controls damping of high-frequencies as the reverb decays. 0 is no damping, 1 is very strong damping. Values should be between ([0..1])",
        "size": "control of relative \"room size\" roughly in the range ([0.5..3])",
        "early_diff": "controls pattern of echoes produced by the diffuser. At very low values, the diffuser acts like a delay-line whose length is controlled by the 'size' parameter. Medium values produce a slow build-up of echoes, giving the sound a reversed-like quality. Values of 0.707 or greater than produce smooth exponentially decaying echoes. Values should be in the range ([0..1])",
        "feedback": "amount of feedback through the system. Sets the number of repeating echoes. A setting of 1.0 produces infinite sustain. Values should be in the range ([0..1])",
        "mod_depth": "depth ([0..1]) of delay-line modulation. Use in combination with `mod_freq` to produce chorus and pitch-variations in the echoes",
        "mod_freq": "frequency ([0..10] Hz) of delay-line modulation. Use in combination with `mod_depth` to produce chorus and pitch-variations in the echoes"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\ngreyhole_test = (os.osc(220), os.osc(440))\n: re.greyhole(2.0, 0.3, 1.0, 0.6, 0.5, 0.4, 0.2);"
    },
    "re.kb_rom_rev1": {
      "prefix": "re",
      "name": "kb_rom_rev1",
      "full_name": "re.kb_rom_rev1",
      "args": [
        "rt",
        "damp"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Reverberator based on Keith Barr's all-pass single feedback loop reverb topology. Originally designed for the Spin Semiconductor FV-1 chip, this code is an adaptation of the rom_rev1.spn file, part of",
      "param_docs": {
        "rt": "coefficent of the decay of the reverb (0-1)",
        "damp": "coefficient of the lowpass filters (0-1)"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nkb_rom_rev1_test = (os.osc(330), os.osc(660))\n: re.kb_rom_rev1(0.7, 0.3);"
    },
    "re.springreverb": {
      "prefix": "re",
      "name": "springreverb",
      "full_name": "re.springreverb",
      "args": [
        "dwell",
        "blend",
        "tone",
        "tension",
        "springs"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Mono spring-inspired reverb originally designed for the Chaos Audio Stratus, which defines all parameters in the [0..10] range. They have been remapped to more typical [0..1] ranges in this implementa",
      "param_docs": {
        "dwell": "feedback amount controlling decay length ([0..1])",
        "blend": "wet gain scaling ([0..1], maps to 0..0.8)",
        "tone": "lowpass cutoff applied to the wet path ([0..1])",
        "tension": "base spring delay time and tail length ([0..1])",
        "springs": "spacing preset between spring delays (0 = left, 1 = right, 2 = middle)"
      },
      "example": "re = library(\"reverbs.lib\");\nos = library(\"oscillators.lib\");\nspringreverb_test = os.osc(330)\n: re.springreverb(0.5, 0.5, 0.5, 0.5, 1);"
    },
    "re.jp_gh_rev.diffuser_aux": {
      "prefix": "re",
      "name": "jp_gh_rev.diffuser_aux",
      "full_name": "re.jp_gh_rev.diffuser_aux",
      "args": [
        "angle",
        "g",
        "scale1",
        "scale2",
        "size",
        "block"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev diffuser_aux filter",
      "param_docs": {},
      "example": ""
    },
    "re.jp_gh_rev.diffuser": {
      "prefix": "re",
      "name": "jp_gh_rev.diffuser",
      "full_name": "re.jp_gh_rev.diffuser",
      "args": [
        "angle",
        "g",
        "scale1",
        "scale2",
        "size"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev diffuser filter",
      "param_docs": {},
      "example": ""
    },
    "re.jp_gh_rev.diffuser_nested": {
      "prefix": "re",
      "name": "jp_gh_rev.diffuser_nested",
      "full_name": "re.jp_gh_rev.diffuser_nested",
      "args": [
        "N",
        "angle",
        "g",
        "scale",
        "size"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev diffuser_nested filter",
      "param_docs": {},
      "example": ""
    },
    "re.jp_gh_rev.smooth_init": {
      "prefix": "re",
      "name": "jp_gh_rev.smooth_init",
      "full_name": "re.jp_gh_rev.smooth_init",
      "args": [
        "s",
        "default"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev smooth_init filter",
      "param_docs": {},
      "example": ""
    },
    "re.jp_gh_rev.jpverb": {
      "prefix": "re",
      "name": "jp_gh_rev.jpverb",
      "full_name": "re.jp_gh_rev.jpverb",
      "args": [
        "t60",
        "damp",
        "size",
        "early_diff",
        "mod_depth",
        "mod_freq",
        "low",
        "mid",
        "high",
        "low_cutoff",
        "high_cutoff"
      ],
      "arg_count": 11,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev jpverb filter",
      "param_docs": {},
      "example": ""
    },
    "re.jp_gh_rev.greyhole": {
      "prefix": "re",
      "name": "jp_gh_rev.greyhole",
      "full_name": "re.jp_gh_rev.greyhole",
      "args": [
        "dt",
        "damp",
        "size",
        "early_diff",
        "feedback",
        "mod_depth",
        "mod_freq"
      ],
      "arg_count": 7,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev greyhole filter",
      "param_docs": {},
      "example": ""
    },
    "re.jp_gh_rev.linear_interp": {
      "prefix": "re",
      "name": "jp_gh_rev.linear_interp",
      "full_name": "re.jp_gh_rev.linear_interp",
      "args": [
        "x"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "jp_gh_rev linear_interp filter",
      "param_docs": {},
      "example": ""
    },
    "ro.cross": {
      "prefix": "ro",
      "name": "cross",
      "full_name": "ro.cross",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cross N signals: `(x1,x2,..,xn) -> (xn,..,x2,x1)`. `cross` is a standard Faust function.",
      "param_docs": {
        "N": "number of signals (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\ncross_test = (os.osc(200), os.osc(300), os.osc(400)) : ro.cross(3);"
    },
    "ro.crossnn": {
      "prefix": "ro",
      "name": "crossnn",
      "full_name": "ro.crossnn",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Cross two `bus(N)`s.",
      "param_docs": {
        "N": "the number of signals in the `bus` (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\ncrossnn_test = (os.osc(110), os.osc(220), os.osc(330), os.osc(440)) : ro.crossnn(2);"
    },
    "ro.crossn1": {
      "prefix": "ro",
      "name": "crossn1",
      "full_name": "ro.crossn1",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 2,
      "description": "Cross `bus(N)` and `bus(1)`.",
      "param_docs": {
        "N": "the number of signals in the first `bus` (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\ncrossn1_test = (os.osc(100), os.osc(200), os.osc(300), os.osc(400)) : ro.crossn1(3);"
    },
    "ro.cross1n": {
      "prefix": "ro",
      "name": "cross1n",
      "full_name": "ro.cross1n",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Cross `bus(1)` and `bus(N)`.",
      "param_docs": {
        "N": "the number of signals in the second `bus` (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\ncross1n_test = (os.osc(150), os.osc(250), os.osc(350), os.osc(450)) : ro.cross1n(3);"
    },
    "ro.crossNM": {
      "prefix": "ro",
      "name": "crossNM",
      "full_name": "ro.crossNM",
      "args": [
        "N",
        "M"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Cross `bus(N)` and `bus(M)`.",
      "param_docs": {
        "N": "the number of signals in the first `bus` (int, as a constant numerical expression)",
        "M": "the number of signals in the second `bus` (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\ncrossNM_test = (os.osc(180), os.osc(280), os.osc(380), os.osc(480), os.osc(580)) : ro.crossNM(2,3);"
    },
    "ro.interleave": {
      "prefix": "ro",
      "name": "interleave",
      "full_name": "ro.interleave",
      "args": [
        "R",
        "C"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Interleave R x C cables from column order to row order. That is, transpose the input CxR matrix, the first R inputs is the first row.",
      "param_docs": {
        "R": "row length (int, as a constant numerical expression)",
        "C": "column length (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\ninterleave_test = (os.osc(200), os.osc(300), os.osc(400), os.osc(500)) : ro.interleave(2,2);"
    },
    "ro.butterfly": {
      "prefix": "ro",
      "name": "butterfly",
      "full_name": "ro.butterfly",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Addition (first half) then substraction (second half) of interleaved signals.",
      "param_docs": {
        "N": "size of the butterfly (N is int, even and as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\nbutterfly_test = (os.osc(250), os.osc(350), os.osc(450), os.osc(550)) : ro.butterfly(4);"
    },
    "ro.hadamard": {
      "prefix": "ro",
      "name": "hadamard",
      "full_name": "ro.hadamard",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Hadamard matrix function of size `N = 2^k`.",
      "param_docs": {
        "N": "`2^k`, size of the matrix (int, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\nhadamard_test = (os.osc(220), os.osc(330), os.osc(440), os.osc(550)) : ro.hadamard(4);"
    },
    "ro.recursivize": {
      "prefix": "ro",
      "name": "recursivize",
      "full_name": "ro.recursivize",
      "args": [
        "p",
        "q"
      ],
      "arg_count": 2,
      "inputs": 2,
      "outputs": 2,
      "description": "Create a recursion from two arbitrary processors `p` and `q`.",
      "param_docs": {
        "p": "the forward arbitrary processor",
        "q": "the feedback arbitrary processor"
      },
      "example": "ro = library(\"routes.lib\");\nos = library(\"oscillators.lib\");\nrecursivize_test = (os.osc(220), os.osc(330)) : ro.recursivize(*(0.5), *(0.3));"
    },
    "ro.bubbleSort": {
      "prefix": "ro",
      "name": "bubbleSort",
      "full_name": "ro.bubbleSort",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Sort a set of N parallel signals in ascending order on-the-fly through the Bubble Sort algorithm.",
      "param_docs": {
        "N": "the number of signals to be sorted (must be an int >= 0, as a constant numerical expression)"
      },
      "example": "ro = library(\"routes.lib\");\nbubbleSort_test = (\nhslider(\"bubbleSort:x0\", 0.3, -1, 1, 0.01),\nhslider(\"bubbleSort:x1\", -0.2, -1, 1, 0.01),\nhslider(\"bubbleSort:x2\", 0.8, -1, 1, 0.01),\nhslider(\"bubbleSort:x3\", -0.5, -1, 1, 0.01)\n) : ro.bubbleSort(4);"
    },
    "si.bus": {
      "prefix": "si",
      "name": "bus",
      "full_name": "si.bus",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Put N cables in parallel. `bus` is a standard Faust function.",
      "param_docs": {
        "N": "is an integer known at compile time that indicates the number of parallel cables"
      },
      "example": "si = library(\"signals.lib\");\nbus_test = (\nhslider(\"bus:x0\", 0, -1, 1, 0.01),\nhslider(\"bus:x1\", 0, -1, 1, 0.01),\nhslider(\"bus:x2\", 0, -1, 1, 0.01)\n) : si.bus(3);"
    },
    "si.block": {
      "prefix": "si",
      "name": "block",
      "full_name": "si.block",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Block - terminate N signals. `block` is a standard Faust function.",
      "param_docs": {
        "N": "the number of signals to be blocked known at compile time"
      },
      "example": "si = library(\"signals.lib\");\nblock_test = (\nhslider(\"block:x0\", 0, -1, 1, 0.01),\nhslider(\"block:x1\", 0, -1, 1, 0.01)\n) : (si.block(1), _);"
    },
    "si.interpolate": {
      "prefix": "si",
      "name": "interpolate",
      "full_name": "si.interpolate",
      "args": [
        "i"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 1,
      "description": "Linear interpolation between two signals.",
      "param_docs": {
        "i": "interpolation control between 0 and 1 (0: first input; 1: second input)"
      },
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\ninterpolate_test = si.interpolate(\nhslider(\"interpolate:mix\", 0.5, 0, 1, 0.01),\nos.osc(220),\nos.osc(440)\n);"
    },
    "si.repeat": {
      "prefix": "si",
      "name": "repeat",
      "full_name": "si.repeat",
      "args": [
        "N",
        "FX"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Repeat an effect N time(s) and take the parallel sum of all intermediate buses.",
      "param_docs": {
        "N": "Number of repetitions, minimum of 1, a constant numerical expression",
        "FX": "an arbitrary effect (N inputs and N outputs) that will be repeated"
      },
      "example": "si = library(\"signals.lib\");\nrepeat_test = hslider(\"repeat:input\", 0, -1, 1, 0.01) : si.repeat(3, *(0.5));"
    },
    "si.smoo": {
      "prefix": "si",
      "name": "smoo",
      "full_name": "si.smoo",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Smoothing function based on `smooth` ideal to smooth UI signals (sliders, etc.) down. Approximately, this is a 7 Hz one-pole low-pass considering the coefficient calculation:",
      "param_docs": {},
      "example": "si = library(\"signals.lib\");\nsmoo_test = hslider(\"smoo:input\", 0, -1, 1, 0.01) : si.smoo;"
    },
    "si.polySmooth": {
      "prefix": "si",
      "name": "polySmooth",
      "full_name": "si.polySmooth",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "A smoothing function based on `smooth` that doesn't smooth when a trigger signal is given. This is very useful when making polyphonic synthesizer to make sure that the value of the parameter",
      "param_docs": {
        "g": "the gate/trigger signal used when making polyphonic synths",
        "s": "the smoothness (see `smooth`)",
        "d": "the number of samples to wait before the signal start being"
      },
      "example": "si = library(\"signals.lib\");\npolySmooth_test = hslider(\"polySmooth:input\", 0, -1, 1, 0.01)\n: si.polySmooth(button(\"polySmooth:gate\"), 0.999, 32);"
    },
    "si.smoothAndH": {
      "prefix": "si",
      "name": "smoothAndH",
      "full_name": "si.smoothAndH",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "A smoothing function based on `smooth` that holds its output signal when a trigger is sent to it. This feature is convenient when implementing polyphonic instruments to prevent some",
      "param_docs": {
        "g": "the hold signal (0 for hold, 1 for bypass)",
        "s": "the smoothness (see `smooth`)"
      },
      "example": "si = library(\"signals.lib\");\nsmoothAndH_test = hslider(\"smoothAndH:input\", 0, -1, 1, 0.01)\n: si.smoothAndH(button(\"smoothAndH:hold\"), 0.999);"
    },
    "si.bsmooth": {
      "prefix": "si",
      "name": "bsmooth",
      "full_name": "si.bsmooth",
      "args": [
        "..."
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Block smooth linear interpolation during a block of samples (given by the `ma.BS` value).",
      "param_docs": {},
      "example": "si = library(\"signals.lib\");\nbsmooth_test = hslider(\"bsmooth:input\", 0, -1, 1, 0.01) : si.bsmooth;"
    },
    "si.dot": {
      "prefix": "si",
      "name": "dot",
      "full_name": "si.dot",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Dot product for two vectors of size N.",
      "param_docs": {
        "N": "size of the vectors (int, must be known at compile time)"
      },
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\ndot_test = (\nos.osc(100), os.osc(200), os.osc(300),\nos.osc(400), os.osc(500), os.osc(600)\n) : si.dot(3);"
    },
    "si.smooth": {
      "prefix": "si",
      "name": "smooth",
      "full_name": "si.smooth",
      "args": [
        "s"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Exponential smoothing by a unity-dc-gain one-pole lowpass. `smooth` is a standard Faust function.",
      "param_docs": {
        "tau": "desired smoothing time constant in seconds, or",
        "s": "smoothness between 0 and 1. s=0 for no smoothing, s=0.999 is \"very smooth\","
      },
      "example": "si = library(\"signals.lib\");\nsmooth_test = hslider(\"smooth:input\", 0, -1, 1, 0.01) : si.smooth(0.9);"
    },
    "si.smoothq": {
      "prefix": "si",
      "name": "smoothq",
      "full_name": "si.smoothq",
      "args": [
        "time",
        "q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Smoothing with continuously variable curves from Exponential to Linear, with a constant time.",
      "param_docs": {
        "time": "seconds to reach target",
        "q": "curve shape (between 0..1, 0 is Exponential, 1 is Linear)"
      },
      "example": "si = library(\"signals.lib\");\nsmoothq_test = hslider(\"smoothq:input\", 0, -1, 1, 0.01) : si.smoothq(0.25, 0.5);"
    },
    "si.cbus": {
      "prefix": "si",
      "name": "cbus",
      "full_name": "si.cbus",
      "args": [
        "N"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "N parallel cables for complex signals. `cbus` is a standard Faust function.",
      "param_docs": {
        "N": "is an integer known at compile time that indicates the number of parallel cables."
      },
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\ncbus_test = (\nos.osc(100), os.osc(150),\nos.osc(200), os.osc(250)\n) : si.cbus(2);"
    },
    "si.cmul": {
      "prefix": "si",
      "name": "cmul",
      "full_name": "si.cmul",
      "args": [
        "r2",
        "i2"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 2,
      "description": "Multiply two complex signals pointwise. `cmul` is a standard Faust function.",
      "param_docs": {},
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\ncmul_test = si.cmul(\nos.osc(110), os.osc(220),\nos.osc(330), os.osc(440)\n);"
    },
    "si.cconj": {
      "prefix": "si",
      "name": "cconj",
      "full_name": "si.cconj",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 2,
      "description": "Complex conjugation of a (complex) signal. `cconj` is a standard Faust function.",
      "param_docs": {},
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\ncconj_test = (os.osc(210), os.osc(310)) : si.cconj;"
    },
    "si.onePoleSwitching": {
      "prefix": "si",
      "name": "onePoleSwitching",
      "full_name": "si.onePoleSwitching",
      "args": [
        "att",
        "rel"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "One pole filter with independent attack and release times.",
      "param_docs": {
        "att": "the attack tau time constant in second",
        "rel": "the release tau time constant in second"
      },
      "example": "si = library(\"signals.lib\");\nonePoleSwitching_test = hslider(\"onePoleSwitching:input\", 0, -1, 1, 0.01)\n: si.onePoleSwitching(0.05, 0.2);"
    },
    "si.rev": {
      "prefix": "si",
      "name": "rev",
      "full_name": "si.rev",
      "args": [
        "n"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Reverse the input signal by blocks of n>0 samples. `rev(1)` is the indentity function. `rev(n)` has a latency of `n-1` samples.",
      "param_docs": {
        "n": "the block size in samples"
      },
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\nrev_test = os.osc(440) : si.rev(32);"
    },
    "si.vecOp": {
      "prefix": "si",
      "name": "vecOp",
      "full_name": "si.vecOp",
      "args": [
        "vectorsList",
        "op"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "This function is a generalisation of Faust's iterators such as `prod` and `sum`, and it allows to perform operations on an arbitrary number of vectors, provided that they all have the same length. Unl",
      "param_docs": {},
      "example": "si = library(\"signals.lib\");\nvecOp_test = si.vecOp((v0, v1), +)\nwith {\nv0 = (hslider(\"vecOp:v0_0\", 0.1, -1, 1, 0.01), hslider(\"vecOp:v0_1\", 0.2, -1, 1, 0.01));\nv1 = (hslider(\"vecOp:v1_0\", 0.3, -1, 1, 0.01), hslider(\"vecOp:v1_1\", 0.4, -1, 1, 0.01));\n};"
    },
    "si.bpar": {
      "prefix": "si",
      "name": "bpar",
      "full_name": "si.bpar",
      "args": [
        "N",
        "f"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Balanced `par` where the repeated expression doesn't depend on a variable. The built-in `par` is implemented as an unbalanced tree, and also has to substitute the variable into the repeated expression",
      "param_docs": {
        "N": "number of repetitions, minimum 1, a constant numerical expression",
        "f": "an arbitrary expression"
      },
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\nbpar_test = (os.osc(120), os.osc(240), os.osc(360)) : si.bpar(3, *(0.5));"
    },
    "si.bsum": {
      "prefix": "si",
      "name": "bsum",
      "full_name": "si.bsum",
      "args": [
        "N",
        "f"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Balanced `sum`, see `si.bpar`.",
      "param_docs": {
        "N": "number of repetitions, minimum 1, a constant numerical expression",
        "f": "an arbitrary expression with 1 output."
      },
      "example": "si = library(\"signals.lib\");\nos = library(\"oscillators.lib\");\nbsum_test = (os.osc(100), os.osc(200), os.osc(300))\n: si.bsum(3, *(0.5));"
    },
    "si.bprod": {
      "prefix": "si",
      "name": "bprod",
      "full_name": "si.bprod",
      "args": [
        "N",
        "f"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Balanced `prod`, see `si.bpar`.",
      "param_docs": {
        "N": "number of repetitions, minimum 1, a constant numerical expression",
        "f": "an arbitrary expression with 1 output."
      },
      "example": "si = library(\"signals.lib\");\nbprod_test = (\nhslider(\"bprod:x0\", 0.5, 0, 2, 0.01),\nhslider(\"bprod:x1\", 0.8, 0, 2, 0.01)\n) : si.bprod(2, _);"
    },
    "so.loop": {
      "prefix": "so",
      "name": "loop",
      "full_name": "so.loop",
      "args": [
        "sf",
        "part"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Play a soundfile in a loop taking into account its sampling rate. `loop` is a standard Faust function.",
      "param_docs": {
        "sf": "the soundfile",
        "part": "the part in the soundfile list of sounds"
      },
      "example": "so = library(\"soundfiles.lib\");\nsf = soundfile(\"sound[url:{'tests/assets/silence.wav'}]\", 1);\nloop_test = so.loop(sf, 0);"
    },
    "so.loop_speed": {
      "prefix": "so",
      "name": "loop_speed",
      "full_name": "so.loop_speed",
      "args": [
        "sf",
        "part",
        "speed"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Play a soundfile in a loop taking into account its sampling rate, with speed control. `loop_speed` is a standard Faust function.",
      "param_docs": {
        "sf": "the soundfile",
        "part": "the part in the soundfile list of sounds",
        "speed": "the speed between 0 and n"
      },
      "example": "so = library(\"soundfiles.lib\");\nsf = soundfile(\"sound[url:{'tests/assets/silence.wav'}]\", 1);\nloop_speed_test = so.loop_speed(sf, 0, hslider(\"loop_speed:speed\", 1, 0, 2, 0.01));"
    },
    "so.loop_speed_level": {
      "prefix": "so",
      "name": "loop_speed_level",
      "full_name": "so.loop_speed_level",
      "args": [
        "sf",
        "part",
        "speed",
        "level"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Play a soundfile in a loop taking into account its sampling rate, with speed and level controls. `loop_speed_level` is a standard Faust function.",
      "param_docs": {
        "sf": "the soundfile",
        "part": "the part in the soundfile list of sounds",
        "speed": "the speed between 0 and n",
        "level": "the volume between 0 and n"
      },
      "example": "so = library(\"soundfiles.lib\");\nsf = soundfile(\"sound[url:{'tests/assets/silence.wav'}]\", 1);\nloop_speed_level_test = so.loop_speed_level(\nsf,\n0,\nhslider(\"loop_speed_level:speed\", 1, 0, 2, 0.01),\nhslider(\"loop_speed_level:level\", 0.5, 0, 1, 0.01)\n);"
    },
    "so.super.length": {
      "prefix": "so",
      "name": "super.length",
      "full_name": "so.super.length",
      "args": [
        "sf",
        "part"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "super length filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.srate": {
      "prefix": "so",
      "name": "super.srate",
      "full_name": "so.super.srate",
      "args": [
        "sf",
        "part"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "super srate filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.outs": {
      "prefix": "so",
      "name": "super.outs",
      "full_name": "so.super.outs",
      "args": [
        "sf",
        "level"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "super outs filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.player": {
      "prefix": "so",
      "name": "super.player",
      "full_name": "so.super.player",
      "args": [
        "sf",
        "part",
        "reader",
        "level"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "super player filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.player_interp": {
      "prefix": "so",
      "name": "super.player_interp",
      "full_name": "so.super.player_interp",
      "args": [
        "sf",
        "part",
        "reader",
        "level",
        "selector"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "super player_interp filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.gen": {
      "prefix": "so",
      "name": "super.gen",
      "full_name": "so.super.gen",
      "args": [
        "idx"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "super gen filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.play_interp": {
      "prefix": "so",
      "name": "super.play_interp",
      "full_name": "so.super.play_interp",
      "args": [
        "sf",
        "part",
        "ref",
        "freq",
        "level",
        "gate",
        "selector"
      ],
      "arg_count": 7,
      "inputs": 1,
      "outputs": 1,
      "description": "super play_interp filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.loop_speed_level": {
      "prefix": "so",
      "name": "super.loop_speed_level",
      "full_name": "so.super.loop_speed_level",
      "args": [
        "sf",
        "part",
        "speed",
        "level"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "super loop_speed_level filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.loop_speed": {
      "prefix": "so",
      "name": "super.loop_speed",
      "full_name": "so.super.loop_speed",
      "args": [
        "sf",
        "part",
        "speed"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "super loop_speed filter",
      "param_docs": {},
      "example": ""
    },
    "so.super.loop": {
      "prefix": "so",
      "name": "super.loop",
      "full_name": "so.super.loop",
      "args": [
        "sf",
        "part"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "super loop filter",
      "param_docs": {},
      "example": ""
    },
    "sp.panner": {
      "prefix": "sp",
      "name": "panner",
      "full_name": "sp.panner",
      "args": [
        "g"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 2,
      "description": "A simple linear stereo panner. `panner` is a standard Faust function.",
      "param_docs": {
        "g": "the panning (0-1)"
      },
      "example": "sp = library(\"spats.lib\");\nos = library(\"oscillators.lib\");\npanner_test = os.osc(220) : sp.panner(hslider(\"panner:pan\", 0.3, 0, 1, 0.01));"
    },
    "sp.constantPowerPan": {
      "prefix": "sp",
      "name": "constantPowerPan",
      "full_name": "sp.constantPowerPan",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Apply the constant power pan rule to a stereo signal. The channels are not respatialized. Their gains are simply adjusted. A pan of 0 preserves the left channel and silences",
      "param_docs": {
        "p": "the panning (0-1)"
      },
      "example": "sp = library(\"spats.lib\");\nos = library(\"oscillators.lib\");\nconstantPowerPan_test = (os.osc(110), os.osc(220))\n: sp.constantPowerPan(hslider(\"constantPowerPan:pan\", 0.4, 0, 1, 0.01));"
    },
    "sp.spat": {
      "prefix": "sp",
      "name": "spat",
      "full_name": "sp.spat",
      "args": [
        "N",
        "r",
        "d"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "GMEM SPAT: n-outputs spatializer. `spat` is a standard Faust function.",
      "param_docs": {
        "N": "number of outputs (a constant numerical expression)",
        "r": "rotation (between 0 et 1)",
        "d": "distance of the source (between 0 et 1)"
      },
      "example": "sp = library(\"spats.lib\");\nos = library(\"oscillators.lib\");\nspat_test = os.osc(330)\n: sp.spat(4,\nhslider(\"spat:rotation\", 0.25, 0, 1, 0.01),\nhslider(\"spat:distance\", 0.5, 0, 1, 0.01));"
    },
    "sp.wfs": {
      "prefix": "sp",
      "name": "wfs",
      "full_name": "sp.wfs",
      "args": [
        "xref",
        "yref",
        "zref",
        "speakersDist",
        "nSources",
        "nSpeakers",
        "inProc",
        "xs",
        "ys",
        "zs"
      ],
      "arg_count": 10,
      "inputs": 0,
      "outputs": 1,
      "description": "Wave Field Synthesis algorithm for multiple sound sources. Implementation generalized starting from Pierre Lecomte version.",
      "param_docs": {
        "xref": "x-coordinate of the reference listening point in meters",
        "yref": "y-coordinate of the reference listening point in meters",
        "zref": "z-coordinate of the reference listening point in meters",
        "speakersDist": "distance between speakers in meters",
        "nSources": "number of sound sources",
        "nSpeakers": "number of speakers",
        "inProc": "per-source processor function, as a function of the source index",
        "xs": "x-coordinate of the sound source in meters, as a function of the source index",
        "ys": "y-coordinate of the sound source in meters, as a function of the source index",
        "zs": "z-coordinate of the sound source in meters, as a function of the source index"
      },
      "example": "sp = library(\"spats.lib\");\nos = library(\"oscillators.lib\");\nwfs_proc(i) = *(0.5); // Simple gain processor\nwfs_xs(i) = 0.0;\nwfs_ys(i) = 1.0;\nwfs_zs(i) = 0.0;\nwfs_test = os.osc(440)\n: sp.wfs(0, 1, 0, 0.5, 1, 2, wfs_inGain, wfs_proc, wfs_xs, wfs_ys, wfs_zs);"
    },
    "sp.wfs_ui": {
      "prefix": "sp",
      "name": "wfs_ui",
      "full_name": "sp.wfs_ui",
      "args": [
        "xref",
        "yref",
        "zref",
        "speakersDist",
        "nSources",
        "nSpeaker"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Wave Field Synthesis algorithm for multiple sound sources with a built-in UI.",
      "param_docs": {
        "xref": "x-coordinate of the reference listening point in meters",
        "yref": "y-coordinate of the reference listening point in meters",
        "zref": "z-coordinate of the reference listening point in meters",
        "speakersDist": "distance between speakers in meters",
        "nSources": "number of sound sources",
        "nSpeakers": "number of speakers"
      },
      "example": "sp = library(\"spats.lib\");\nos = library(\"oscillators.lib\");\nwfs_ui_test = os.osc(550)\n: sp.wfs_ui(0, 1, 0, 0.5, 1, 2);"
    },
    "sp.stereoize": {
      "prefix": "sp",
      "name": "stereoize",
      "full_name": "sp.stereoize",
      "args": [
        "p"
      ],
      "arg_count": 1,
      "inputs": 2,
      "outputs": 2,
      "description": "Transform an arbitrary processor `p` into a stereo processor with 2 inputs and 2 outputs.",
      "param_docs": {
        "p": "the arbitrary processor"
      },
      "example": "sp = library(\"spats.lib\");\nos = library(\"oscillators.lib\");\nstereoize_test = (os.osc(660), os.osc(770))\n: sp.stereoize(+);"
    },
    "sy.popFilterDrum": {
      "prefix": "sy",
      "name": "popFilterDrum",
      "full_name": "sy.popFilterDrum",
      "args": [
        "freq",
        "q",
        "gate"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple percussion instrument based on a \"popped\" resonant bandpass filter. `popFilterDrum` is a standard Faust function.",
      "param_docs": {
        "freq": "the resonance frequency of the instrument in Hz",
        "q": "the q of the res filter (typically, 5 is a good value)",
        "gate": "the trigger signal (0 or 1)"
      },
      "example": "sy = library(\"synths.lib\");\npopFilterDrum_test = sy.popFilterDrum(\nhslider(\"popFilterDrum:freq\", 200, 50, 1000, 1),\nhslider(\"popFilterDrum:q\", 5, 1, 20, 0.1),\nbutton(\"popFilterDrum:gate\")\n);"
    },
    "sy.dubDub": {
      "prefix": "sy",
      "name": "dubDub",
      "full_name": "sy.dubDub",
      "args": [
        "freq",
        "ctFreq",
        "q",
        "gate"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple synth based on a sawtooth wave filtered by a resonant lowpass. `dubDub` is a standard Faust function.",
      "param_docs": {
        "freq": "frequency of the sawtooth in Hz",
        "ctFreq": "cutoff frequency of the filter",
        "q": "Q of the filter",
        "gate": "the trigger signal (0 or 1)"
      },
      "example": "sy = library(\"synths.lib\");\ndubDub_test = sy.dubDub(\nhslider(\"dubDub:freq\", 220, 50, 1000, 1),\nhslider(\"dubDub:cutoff\", 800, 100, 6000, 1),\nhslider(\"dubDub:q\", 2, 0.2, 10, 0.1),\nbutton(\"dubDub:gate\")\n);"
    },
    "sy.sawTrombone": {
      "prefix": "sy",
      "name": "sawTrombone",
      "full_name": "sy.sawTrombone",
      "args": [
        "freq",
        "gain",
        "gate"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple trombone based on a lowpassed sawtooth wave. `sawTrombone` is a standard Faust function.",
      "param_docs": {
        "freq": "the frequency in Hz",
        "gain": "the gain (0-1)",
        "gate": "the gate (0 or 1)"
      },
      "example": "sy = library(\"synths.lib\");\nsawTrombone_test = sy.sawTrombone(\nhslider(\"sawTrombone:freq\", 196, 50, 600, 1),\nhslider(\"sawTrombone:gain\", 0.6, 0, 1, 0.01),\nbutton(\"sawTrombone:gate\")\n);"
    },
    "sy.combString": {
      "prefix": "sy",
      "name": "combString",
      "full_name": "sy.combString",
      "args": [
        "freq",
        "res",
        "gate"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Simplest string physical model ever based on a comb filter. `combString` is a standard Faust function.",
      "param_docs": {
        "freq": "the frequency of the string in Hz",
        "res": "string T60 (resonance time) in second",
        "gate": "trigger signal (0 or 1)"
      },
      "example": "sy = library(\"synths.lib\");\ncombString_test = sy.combString(\nhslider(\"combString:freq\", 220, 55, 880, 1),\nhslider(\"combString:res\", 4, 0.1, 10, 0.01),\nbutton(\"combString:gate\")\n);"
    },
    "sy.additiveDrum": {
      "prefix": "sy",
      "name": "additiveDrum",
      "full_name": "sy.additiveDrum",
      "args": [
        "freq",
        "freqRatio",
        "gain",
        "harmDec",
        "att",
        "rel",
        "gate"
      ],
      "arg_count": 7,
      "inputs": 0,
      "outputs": 1,
      "description": "A simple drum using additive synthesis. `additiveDrum` is a standard Faust function.",
      "param_docs": {
        "freq": "the resonance frequency of the drum in Hz",
        "freqRatio": "a list of ratio to choose the frequency of the mode in",
        "gain": "the gain of each mode as a list (1 0.9 0.8 ...). The first element",
        "harmDec": "harmonic decay ratio (0-1): configure the speed at which",
        "att": "attack duration in second",
        "rel": "release duration in second",
        "gate": "trigger signal (0 or 1)"
      },
      "example": "sy = library(\"synths.lib\");\nadditiveDrum_test = sy.additiveDrum(\nhslider(\"additiveDrum:freq\", 180, 60, 600, 1),\n(1, 1.3, 2.4, 3.2),\n(1, 0.8, 0.6, 0.4),\nhslider(\"additiveDrum:harmDec\", 0.4, 0, 1, 0.01),\n0.01,\n0.4,\nbutton(\"additiveDrum:gate\")\n);"
    },
    "sy.fm": {
      "prefix": "sy",
      "name": "fm",
      "full_name": "sy.fm",
      "args": [
        "freqs",
        "indices"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "An FM synthesizer with an arbitrary number of modulators connected as a sequence. `fm` is a standard Faust function.",
      "param_docs": {
        "freqs": "a list of frequencies where the first one is the frequency of the carrier",
        "indices": "the indices of modulation (Nfreqs-1)"
      },
      "example": "sy = library(\"synths.lib\");\nfm_test = sy.fm((220, 440, 660), (1.5, 0.8));"
    },
    "sy.kick": {
      "prefix": "sy",
      "name": "kick",
      "full_name": "sy.kick",
      "args": [
        "pitch",
        "click",
        "attack",
        "decay",
        "drive",
        "gate"
      ],
      "arg_count": 6,
      "inputs": 0,
      "outputs": 1,
      "description": "Kick drum synthesis via a pitched sine sweep.",
      "param_docs": {
        "pitch": "the base frequency of the kick drum in Hz",
        "click": "the speed of the pitch envelope, tuned for [0.005s, 1s]",
        "attack": "attack time in seconds, tuned for [0.005s, 0.4s]",
        "decay": "decay time in seconds, tuned for [0.005s, 4.0s]",
        "drive": "a gain multiplier going into the saturator. Tuned for [1, 10]",
        "gate": "the gate which triggers the amp envelope"
      },
      "example": "sy = library(\"synths.lib\");\nkick_test = sy.kick(\nhslider(\"kick:pitch\", 60, 30, 120, 0.1),\nhslider(\"kick:click\", 0.2, 0.005, 1, 0.001),\n0.01,\n0.5,\nhslider(\"kick:drive\", 3, 1, 10, 0.1),\nbutton(\"kick:gate\")\n);"
    },
    "sy.clap": {
      "prefix": "sy",
      "name": "clap",
      "full_name": "sy.clap",
      "args": [
        "tone",
        "attack",
        "decay",
        "gate"
      ],
      "arg_count": 4,
      "inputs": 0,
      "outputs": 1,
      "description": "Clap synthesis via filtered white noise.",
      "param_docs": {
        "tone": "bandpass filter cutoff frequency, tuned for [400Hz, 3500Hz]",
        "attack": "attack time in seconds, tuned for [0s, 0.2s]",
        "decay": "decay time in seconds, tuned for [0s, 4.0s]",
        "gate": "the gate which triggers the amp envelope"
      },
      "example": "sy = library(\"synths.lib\");\nclap_test = sy.clap(\nhslider(\"clap:tone\", 1200, 400, 3500, 10),\n0.01,\n0.6,\nbutton(\"clap:gate\")\n);"
    },
    "sy.hat": {
      "prefix": "sy",
      "name": "hat",
      "full_name": "sy.hat",
      "args": [
        "pitch",
        "tone",
        "attack",
        "decay",
        "gate"
      ],
      "arg_count": 5,
      "inputs": 0,
      "outputs": 1,
      "description": "Hi hat drum synthesis via phase modulation.",
      "param_docs": {
        "pitch": "base frequency in the range [317Hz, 3170Hz]",
        "tone": "bandpass filter cutoff frequency, tuned for [800Hz, 18kHz]",
        "attack": "attack time in seconds, tuned for [0.005s, 0.2s]",
        "decay": "decay time in seconds, tuned for [0.005s, 4.0s]",
        "gate": "the gate which triggers the amp envelope"
      },
      "example": "sy = library(\"synths.lib\");\nhat_test = sy.hat(\nhslider(\"hat:pitch\", 800, 317, 3170, 1),\nhslider(\"hat:tone\", 5000, 800, 18000, 10),\n0.005,\n0.3,\nbutton(\"hat:gate\")\n);"
    },
    "ve.moog_vcf": {
      "prefix": "ve",
      "name": "moog_vcf",
      "full_name": "ve.moog_vcf",
      "args": [
        "res",
        "fr"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Moog \"Voltage Controlled Filter\" (VCF) as two biquads. Implementation of the ideal Moog VCF transfer function factored into second-order sections. As a result, it is more accurate than `moog_vcf` abov",
      "param_docs": {
        "res": "normalized amount of corner-resonance between 0 and 1",
        "fr": "corner-resonance frequency in Hz"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nmoog_vcf_2b_test = os.osc(330)\n: ve.moog_vcf_2b(\nhslider(\"moog_vcf_2b:res\", 0.4, 0, 1, 0.01),\nhslider(\"moog_vcf_2b:freq\", 1200, 50, 6000, 1)\n);\nmoog_vcf_2bn_test = os.osc(330)\n: ve.moog_vcf_2bn(\nhslider(\"moog_vcf_2bn:res\", 0.4, 0, 1, 0.01),\nhslider(\"moog_vcf_2bn:freq\", 1200, 50, 6000, 1)\n);"
    },
    "ve.moogLadder": {
      "prefix": "ve",
      "name": "moogLadder",
      "full_name": "ve.moogLadder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog model of the 4th-order Moog Ladder (without any nonlinearities), which is arguably the most well-known ladder filter in analog synthesizers. Several 1st-order filters are cascaded in se",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "quality factor between .707 (0 feedback coefficient) to 25 (feedback = 4, which is the self-oscillating threshold)."
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nmoogLadder_test = os.osc(220)\n: ve.moogLadder(\nhslider(\"moogLadder:normFreq\", 0.3, 0, 1, 0.001),\nhslider(\"moogLadder:Q\", 4, 0.7, 20, 0.1)\n);"
    },
    "ve.lowpassLadder4": {
      "prefix": "ve",
      "name": "lowpassLadder4",
      "full_name": "ve.lowpassLadder4",
      "args": [
        "k",
        "CF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Topology-preserving transform implementation of a four-pole ladder lowpass. This is essentially the same filter as the moogLadder above except for the parameters, which will be expressed in Hz, for th",
      "param_docs": {
        "k": "feedback coefficient between 0 and 4, which is the stability threshold.",
        "CF": "the filter's cutoff in Hz."
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nlowpassLadder4_test = os.osc(110)\n: ve.lowpassLadder4(\nhslider(\"lowpassLadder4:k\", 2.0, 0, 4, 0.1),\nhslider(\"lowpassLadder4:freq\", 800, 50, 5000, 1)\n);"
    },
    "ve.moogHalfLadder": {
      "prefix": "ve",
      "name": "moogHalfLadder",
      "full_name": "ve.moogHalfLadder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog model of the 2nd-order Moog Half Ladder (simplified version of `(ve.)moogLadder`). Several 1st-order filters are cascaded in series. Feedback is then used, in part, to control the cut-o",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nmoogHalfLadder_test = os.osc(220)\n: ve.moogHalfLadder(\nhslider(\"moogHalfLadder:normFreq\", 0.3, 0, 1, 0.001),\nhslider(\"moogHalfLadder:Q\", 4, 0.7, 20, 0.1)\n);"
    },
    "ve.diodeLadder": {
      "prefix": "ve",
      "name": "diodeLadder",
      "full_name": "ve.diodeLadder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "4th order virtual analog diode ladder filter. In addition to the individual states used within each independent 1st-order filter, there are also additional feedback paths found in the block diagram. T",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\ndiodeLadder_test = os.osc(220)\n: ve.diodeLadder(\nhslider(\"diodeLadder:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"diodeLadder:Q\", 4, 0.7, 20, 0.1)\n);"
    },
    "ve.korg35LPF": {
      "prefix": "ve",
      "name": "korg35LPF",
      "full_name": "ve.korg35LPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog models of the Korg 35 low-pass filter found in the MS-10 and MS-20 synthesizers.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nkorg35LPF_test = os.osc(220)\n: ve.korg35LPF(\nhslider(\"korg35LPF:normFreq\", 0.35, 0, 1, 0.001),\nhslider(\"korg35LPF:Q\", 3.5, 0.7, 10, 0.1)\n);"
    },
    "ve.korg35HPF": {
      "prefix": "ve",
      "name": "korg35HPF",
      "full_name": "ve.korg35HPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Virtual analog models of the Korg 35 high-pass filter found in the MS-10 and MS-20 synthesizers.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nkorg35HPF_test = os.osc(330)\n: ve.korg35HPF(\nhslider(\"korg35HPF:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"korg35HPF:Q\", 3.5, 0.7, 10, 0.1)\n);"
    },
    "ve.oberheim": {
      "prefix": "ve",
      "name": "oberheim",
      "full_name": "ve.oberheim",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 4,
      "description": "Generic multi-outputs Oberheim filter that produces the BSF, BPF, HPF and LPF outputs (see description above).",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\noberheim_test = os.osc(220)\n: ve.oberheim(\nhslider(\"oberheim:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"oberheim:Q\", 1.5, 0.5, 10, 0.1)\n);"
    },
    "ve.oberheimBSF": {
      "prefix": "ve",
      "name": "oberheimBSF",
      "full_name": "ve.oberheimBSF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Band-Stop Oberheim filter (see description above). Specialize the generic implementation: keep the first BSF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\noberheimBSF_test = os.osc(220)\n: ve.oberheimBSF(\nhslider(\"oberheimBSF:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"oberheimBSF:Q\", 1.5, 0.5, 10, 0.1)\n);"
    },
    "ve.oberheimBPF": {
      "prefix": "ve",
      "name": "oberheimBPF",
      "full_name": "ve.oberheimBPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Band-Pass Oberheim filter (see description above). Specialize the generic implementation: keep the second BPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\noberheimBPF_test = os.osc(220)\n: ve.oberheimBPF(\nhslider(\"oberheimBPF:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"oberheimBPF:Q\", 1.5, 0.5, 10, 0.1)\n);"
    },
    "ve.oberheimHPF": {
      "prefix": "ve",
      "name": "oberheimHPF",
      "full_name": "ve.oberheimHPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "High-Pass Oberheim filter (see description above). Specialize the generic implementation: keep the third HPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\noberheimHPF_test = os.osc(220)\n: ve.oberheimHPF(\nhslider(\"oberheimHPF:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"oberheimHPF:Q\", 1.5, 0.5, 10, 0.1)\n);"
    },
    "ve.oberheimLPF": {
      "prefix": "ve",
      "name": "oberheimLPF",
      "full_name": "ve.oberheimLPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Low-Pass Oberheim filter (see description above). Specialize the generic implementation: keep the fourth LPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "q"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\noberheimLPF_test = os.osc(220)\n: ve.oberheimLPF(\nhslider(\"oberheimLPF:normFreq\", 0.4, 0, 1, 0.001),\nhslider(\"oberheimLPF:Q\", 1.5, 0.5, 10, 0.1)\n);"
    },
    "ve.sallenKeyOnePole": {
      "prefix": "ve",
      "name": "sallenKeyOnePole",
      "full_name": "ve.sallenKeyOnePole",
      "args": [
        "normFreq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 2,
      "description": "Sallen-Key generic One Pole filter that produces the LPF and HPF outputs (see description above).",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKeyOnePole_test = os.osc(440)\n: ve.sallenKeyOnePole(\nhslider(\"sallenKeyOnePole:normFreq\", 0.25, 0, 1, 0.001)\n);"
    },
    "ve.sallenKeyOnePoleLPF": {
      "prefix": "ve",
      "name": "sallenKeyOnePoleLPF",
      "full_name": "ve.sallenKeyOnePoleLPF",
      "args": [
        "normFreq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key One Pole lowpass filter (see description above). Specialize the generic implementation: keep the first LPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKeyOnePoleLPF_test = os.osc(440)\n: ve.sallenKeyOnePoleLPF(\nhslider(\"sallenKeyOnePoleLPF:normFreq\", 0.25, 0, 1, 0.001)\n);"
    },
    "ve.sallenKeyOnePoleHPF": {
      "prefix": "ve",
      "name": "sallenKeyOnePoleHPF",
      "full_name": "ve.sallenKeyOnePoleHPF",
      "args": [
        "normFreq"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key One Pole Highpass filter (see description above). The dry input signal is routed in parallel to the output. The LPF'd signal is subtracted from the input so that the HPF remains.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKeyOnePoleHPF_test = os.osc(440)\n: ve.sallenKeyOnePoleHPF(\nhslider(\"sallenKeyOnePoleHPF:normFreq\", 0.25, 0, 1, 0.001)\n);"
    },
    "ve.sallenKey2ndOrder": {
      "prefix": "ve",
      "name": "sallenKey2ndOrder",
      "full_name": "ve.sallenKey2ndOrder",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 3,
      "description": "Sallen-Key generic 2nd order filter that produces the LPF, BPF and HPF outputs.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "quality factor controlling the sharpness/resonance of the filter around the center frequency (CF). For bandpass filters, higher Q increases the gain at the center frequency. Must be in the range `[ma.EPSILON, ma.MAX]`"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKey2ndOrder_test = os.osc(330)\n: ve.sallenKey2ndOrder(\nhslider(\"sallenKey2ndOrder:normFreq\", 0.3, 0, 1, 0.001),\nhslider(\"sallenKey2ndOrder:Q\", 1.0, 0.1, 10, 0.1)\n);"
    },
    "ve.sallenKey2ndOrderLPF": {
      "prefix": "ve",
      "name": "sallenKey2ndOrderLPF",
      "full_name": "ve.sallenKey2ndOrderLPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key 2nd order lowpass filter (see description above). Specialize the generic implementation: keep the first LPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "quality factor controlling the sharpness/resonance of the filter around the center frequency (CF). For bandpass filters, higher Q increases the gain at the center frequency. Must be in the range `[ma.EPSILON, ma.MAX]`"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKey2ndOrderLPF_test = os.osc(330)\n: ve.sallenKey2ndOrderLPF(\nhslider(\"sallenKey2ndOrderLPF:normFreq\", 0.3, 0, 1, 0.001),\nhslider(\"sallenKey2ndOrderLPF:Q\", 0.8, 0.1, 10, 0.1)\n);"
    },
    "ve.sallenKey2ndOrderBPF": {
      "prefix": "ve",
      "name": "sallenKey2ndOrderBPF",
      "full_name": "ve.sallenKey2ndOrderBPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key 2nd order bandpass filter (see description above). Specialize the generic implementation: keep the second BPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "quality factor controlling the sharpness/resonance of the filter around the center frequency (CF). For bandpass filters, higher Q increases the gain at the center frequency. Must be in the range `[ma.EPSILON, ma.MAX]`"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKey2ndOrderBPF_test = os.osc(330)\n: ve.sallenKey2ndOrderBPF(\nhslider(\"sallenKey2ndOrderBPF:normFreq\", 0.3, 0, 1, 0.001),\nhslider(\"sallenKey2ndOrderBPF:Q\", 1.5, 0.1, 10, 0.1)\n);"
    },
    "ve.sallenKey2ndOrderHPF": {
      "prefix": "ve",
      "name": "sallenKey2ndOrderHPF",
      "full_name": "ve.sallenKey2ndOrderHPF",
      "args": [
        "normFreq",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Sallen-Key 2nd order highpass filter (see description above). Specialize the generic implementation: keep the third HPF output, the compiler will only generate the needed code.",
      "param_docs": {
        "normFreq": "normalized frequency (0-1)",
        "Q": "quality factor controlling the sharpness/resonance of the filter around the center frequency (CF). For bandpass filters, higher Q increases the gain at the center frequency. Must be in the range `[ma.EPSILON, ma.MAX]`"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nsallenKey2ndOrderHPF_test = os.osc(330)\n: ve.sallenKey2ndOrderHPF(\nhslider(\"sallenKey2ndOrderHPF:normFreq\", 0.3, 0, 1, 0.001),\nhslider(\"sallenKey2ndOrderHPF:Q\", 0.8, 0.1, 10, 0.1)\n);"
    },
    "ve.biquad": {
      "prefix": "ve",
      "name": "biquad",
      "full_name": "ve.biquad",
      "args": [
        "b0",
        "b1",
        "b2",
        "a1",
        "a2"
      ],
      "arg_count": 5,
      "inputs": 1,
      "outputs": 1,
      "description": "Basic biquad section implementing the difference equation: `y[n] = b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] - a1 * y[n-1] - a2 * y[n-2]`",
      "param_docs": {},
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nbiquad_test = os.osc(440)\n: ve.biquad(0.5, 0.3, 0.2, -0.3, 0.2);"
    },
    "ve.lowpass2Matched": {
      "prefix": "ve",
      "name": "lowpass2Matched",
      "full_name": "ve.lowpass2Matched",
      "args": [
        "CF",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant lowpass filter.",
      "param_docs": {
        "CF": "cutoff frequency in Hz",
        "Q": "resonance linear amplitude"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nlowpass2Matched_test = os.osc(440)\n: ve.lowpass2Matched(\nhslider(\"lowpass2Matched:CF\", 1000, 50, 5000, 1),\nhslider(\"lowpass2Matched:Q\", 0.707, 0.1, 5, 0.01)\n);"
    },
    "ve.highpass2Matched": {
      "prefix": "ve",
      "name": "highpass2Matched",
      "full_name": "ve.highpass2Matched",
      "args": [
        "CF",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant highpass filter.",
      "param_docs": {
        "CF": "cutoff frequency in Hz",
        "Q": "resonance linear amplitude"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nhighpass2Matched_test = os.osc(440)\n: ve.highpass2Matched(\nhslider(\"highpass2Matched:CF\", 500, 50, 5000, 1),\nhslider(\"highpass2Matched:Q\", 0.707, 0.1, 5, 0.01)\n);"
    },
    "ve.bandpass2Matched": {
      "prefix": "ve",
      "name": "bandpass2Matched",
      "full_name": "ve.bandpass2Matched",
      "args": [
        "CF",
        "Q"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant bandpass filter.",
      "param_docs": {
        "CF": "cutoff frequency in Hz",
        "Q": "peak width"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nbandpass2Matched_test = os.osc(440)\n: ve.bandpass2Matched(\nhslider(\"bandpass2Matched:CF\", 1200, 50, 5000, 1),\nhslider(\"bandpass2Matched:Q\", 2.0, 0.1, 10, 0.01)\n);"
    },
    "ve.peaking2Matched": {
      "prefix": "ve",
      "name": "peaking2Matched",
      "full_name": "ve.peaking2Matched",
      "args": [
        "G",
        "CF",
        "Q"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order resonant bandpass filter.",
      "param_docs": {
        "G": "peak linear amplitude",
        "CF": "cutoff frequency in Hz",
        "Q": "peak width"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\npeaking2Matched_test = os.osc(440)\n: ve.peaking2Matched(\nhslider(\"peaking2Matched:G\", 1.5, 0.1, 4, 0.01),\nhslider(\"peaking2Matched:CF\", 1000, 50, 5000, 1),\nhslider(\"peaking2Matched:Q\", 2.0, 0.1, 10, 0.01)\n);"
    },
    "ve.lowshelf2Matched": {
      "prefix": "ve",
      "name": "lowshelf2Matched",
      "full_name": "ve.lowshelf2Matched",
      "args": [
        "G",
        "CF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order Butterworth lowshelf filter.",
      "param_docs": {
        "G": "shelf linear amplitude",
        "CF": "cutoff frequency in Hz"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nlowshelf2Matched_test = os.osc(330)\n: ve.lowshelf2Matched(\nhslider(\"lowshelf2Matched:G\", 1.5, 0.5, 4, 0.01),\nhslider(\"lowshelf2Matched:CF\", 500, 50, 5000, 1)\n);"
    },
    "ve.highshelf2Matched": {
      "prefix": "ve",
      "name": "highshelf2Matched",
      "full_name": "ve.highshelf2Matched",
      "args": [
        "G",
        "CF"
      ],
      "arg_count": 2,
      "inputs": 1,
      "outputs": 1,
      "description": "Vicanek's decramped second-order Butterworth highshelf filter.",
      "param_docs": {
        "G": "shelf linear amplitude",
        "CF": "cutoff frequency in Hz"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nhighshelf2Matched_test = os.osc(330)\n: ve.highshelf2Matched(\nhslider(\"highshelf2Matched:G\", 1.5, 0.5, 4, 0.01),\nhslider(\"highshelf2Matched:CF\", 1500, 50, 10000, 1)\n);"
    },
    "ve.wah4": {
      "prefix": "ve",
      "name": "wah4",
      "full_name": "ve.wah4",
      "args": [
        "fr"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Wah effect, 4th order. `wah4` is a standard Faust function.",
      "param_docs": {
        "fr": "resonance frequency in Hz"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nwah4_test = os.osc(220)\n: ve.wah4(\nhslider(\"wah4:freq\", 800, 200, 2000, 1)\n);"
    },
    "ve.autowah": {
      "prefix": "ve",
      "name": "autowah",
      "full_name": "ve.autowah",
      "args": [
        "level"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Auto-wah effect. `autowah` is a standard Faust function.",
      "param_docs": {
        "level": "amount of effect desired (0 to 1)."
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\nautowah_test = os.osc(220)\n: ve.autowah(\nhslider(\"autowah:level\", 0.7, 0, 1, 0.01)\n);"
    },
    "ve.crybaby": {
      "prefix": "ve",
      "name": "crybaby",
      "full_name": "ve.crybaby",
      "args": [
        "wah"
      ],
      "arg_count": 1,
      "inputs": 1,
      "outputs": 1,
      "description": "Digitized CryBaby wah pedal. `crybaby` is a standard Faust function.",
      "param_docs": {
        "wah": "\"pedal angle\" from 0 to 1"
      },
      "example": "ve = library(\"vaeffects.lib\");\nos = library(\"oscillators.lib\");\ncrybaby_test = os.osc(220)\n: ve.crybaby(\nhslider(\"crybaby:wah\", 0.3, 0, 1, 0.01)\n);"
    },
    "ve.vocoder": {
      "prefix": "ve",
      "name": "vocoder",
      "full_name": "ve.vocoder",
      "args": [
        "nBands",
        "att",
        "rel",
        "BWRatio",
        "source",
        "excitation"
      ],
      "arg_count": 6,
      "inputs": 1,
      "outputs": 1,
      "description": "A very simple vocoder where the spectrum of the modulation signal is analyzed using a filter bank. `vocoder` is a standard Faust function.",
      "param_docs": {
        "nBands": "Number of vocoder bands",
        "att": "Attack time in seconds",
        "rel": "Release time in seconds",
        "BWRatio": "Coefficient to adjust the bandwidth of each band (0.1 - 2)",
        "source": "Modulation signal",
        "excitation": "Excitation/Carrier signal"
      },
      "example": "ve = library(\"vaeffects.lib\");\nno = library(\"noises.lib\");\nos = library(\"oscillators.lib\");\nvocoder_test = (no.noise, os.osc(220))\n: ve.vocoder(\n8,\nhslider(\"vocoder:att\", 0.01, 0.001, 0.1, 0.001),\nhslider(\"vocoder:rel\", 0.1, 0.01, 0.5, 0.01),\nhslider(\"vocoder:BWRatio\", 1.0, 0.5, 1.5, 0.01)\n);"
    },
    "vl.version": {
      "prefix": "vl",
      "name": "version",
      "full_name": "vl.version",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 3,
      "description": "Return the version number of the Faust standard libraries as a MAJOR, MINOR, PATCH versioning triplet.",
      "param_docs": {},
      "example": ""
    },
    "wd.resistor": {
      "prefix": "wd",
      "name": "resistor",
      "full_name": "wd.resistor",
      "args": [
        "A : r1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistor.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "R": "Resistance/Impedance of the resistor being modeled in Ohms."
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(220);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\nres_leaf(i) = wd.resistor(i, 1000);\nprobe(i) = wd.resistor_Vout(i, 1000);\nresistor_test = wd.buildtree(vsrc : (series_node : (res_leaf, probe)));"
    },
    "wd.resistor_Vout": {
      "prefix": "wd",
      "name": "resistor_Vout",
      "full_name": "wd.resistor_Vout",
      "args": [
        "A : rout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistor + voltage Out.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "R": "Resistance/Impedance of the resistor being modeled in Ohms."
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(220);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\nres_probe(i) = wd.resistor_Vout(i, 820);\nres_load(i) = wd.resistor(i, 1800);\nresistor_Vout_test = wd.buildtree(vsrc : (series_node : (res_probe, res_load)));"
    },
    "wd.resistor_Iout": {
      "prefix": "wd",
      "name": "resistor_Iout",
      "full_name": "wd.resistor_Iout",
      "args": [
        "A : rout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Resistor + current Out.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "R": "Resistance/Impedance of the resistor being modeled in Ohms."
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(220);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\ncurrent_probe(i) = wd.resistor_Iout(i, 1000);\nload(i) = wd.resistor_Vout(i, 1500);\nresistor_Iout_test = wd.buildtree(vsrc : (series_node : (current_probe, load)));"
    },
    "wd.u_voltage": {
      "prefix": "wd",
      "name": "u_voltage",
      "full_name": "wd.u_voltage",
      "args": [
        "v1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Voltage Source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "ein": "Voltage/Potential across ideal voltage source in Volts"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(330);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\nbranch_a(i) = wd.resistor(i, 1200);\nbranch_b(i) = wd.resistor_Vout(i, 2200);\nu_voltage_test = wd.buildtree(vsrc : (series_node : (branch_a, branch_b)));"
    },
    "wd.u_current": {
      "prefix": "wd",
      "name": "u_current",
      "full_name": "wd.u_current",
      "args": [
        "i1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Current Source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "jin": "Current through the ideal current source in Amps"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(110);\nisrc(i) = wd.u_current(i, drive);\nparallel_node(i) = wd.parallel(i);\nbranch_a(i) = wd.resistor(i, 560);\nbranch_b(i) = wd.resistor_Vout(i, 2200);\nu_current_test = wd.buildtree(isrc : (parallel_node : (branch_a, branch_b)));"
    },
    "wd.resVoltage": {
      "prefix": "wd",
      "name": "resVoltage",
      "full_name": "wd.resVoltage",
      "args": [
        "A : v1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistive Voltage Source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "R": "Resistance/Impedance of the series resistor in Ohms",
        "ein": "Voltage/Potential of the ideal voltage source in Volts"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(440);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\nbranch_source(i) = wd.resVoltage(i, 1000, 0.5);\nprobe(i) = wd.resistor_Vout(i, 1800);\nresVoltage_test = wd.buildtree(vsrc : (series_node : (branch_source, probe)));"
    },
    "wd.resVoltage_Vout": {
      "prefix": "wd",
      "name": "resVoltage_Vout",
      "full_name": "wd.resVoltage_Vout",
      "args": [
        "A : vout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistive Voltage Source + voltage output.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "R": "Resistance/Impedance of the series resistor in Ohms",
        "ein": "Voltage/Potential across ideal voltage source in Volts"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(330);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\nbranch_source(i) = wd.resVoltage_Vout(i, 1500, 0.3);\nload(i) = wd.resistor(i, 2200);\nresVoltage_Vout_test = wd.buildtree(vsrc : (series_node : (branch_source, load)));"
    },
    "wd.u_resVoltage": {
      "prefix": "wd",
      "name": "u_resVoltage",
      "full_name": "wd.u_resVoltage",
      "args": [
        "v1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Resistive Voltage Source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "R": "Resistance/Impedance of the series resistor in Ohms",
        "ein": "Voltage/Potential across ideal voltage source in Volts"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(220);\nroot(i) = wd.u_resVoltage(i, 1800, drive);\nseries_node(i) = wd.series(i);\nbranch_a(i) = wd.resistor(i, 1500);\nbranch_b(i) = wd.resistor_Vout(i, 2200);\nu_resVoltage_test = wd.buildtree(root : (series_node : (branch_a, branch_b)));"
    },
    "wd.resCurrent": {
      "prefix": "wd",
      "name": "resCurrent",
      "full_name": "wd.resCurrent",
      "args": [
        "A : i1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Resistive Current Source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "R": "Resistance/Impedance of the parallel resistor in Ohms",
        "jin": "Current through the ideal current source in Amps"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(110);\nroot(i) = wd.u_current(i, drive);\nparallel_node(i) = wd.parallel(i);\nsource_branch(i) = wd.resCurrent(i, 2200, 0.15);\nprobe(i) = wd.resistor_Vout(i, 1500);\nresCurrent_test = wd.buildtree(root : (parallel_node : (source_branch, probe)));"
    },
    "wd.u_resCurrent": {
      "prefix": "wd",
      "name": "u_resCurrent",
      "full_name": "wd.u_resCurrent",
      "args": [
        "i1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Resistive Current Source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "R": "Resistance/Impedance of the series resistor in Ohms",
        "jin": "Current through the ideal current source in Amps"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(150);\nroot(i) = wd.u_resCurrent(i, 2000, drive);\nparallel_node(i) = wd.parallel(i);\nbranch_a(i) = wd.resistor(i, 1200);\nbranch_b(i) = wd.resistor_Vout(i, 1800);\nu_resCurrent_test = wd.buildtree(root : (parallel_node : (branch_a, branch_b)));"
    },
    "wd.u_switch": {
      "prefix": "wd",
      "name": "u_switch",
      "full_name": "wd.u_switch",
      "args": [
        "s1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Switch.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "lambda": "switch state control. -1 for closed switch, 1 for open switch."
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(330);\nlambda = hslider(\"u_switch:lambda\", -1, -1, 1, 0.01);\nroot(i) = wd.u_switch(i, lambda);\nseries_node(i) = wd.series(i);\nbranch_a(i) = wd.resistor(i, 1000);\nbranch_b(i) = wd.resistor_Vout(i, 2200);\nu_switch_test = wd.buildtree(root : (series_node : (branch_a, branch_b)));"
    },
    "wd.capacitor": {
      "prefix": "wd",
      "name": "capacitor",
      "full_name": "wd.capacitor",
      "args": [
        "A : c1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Capacitor.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared.",
        "R": "Capacitance/Impedance of the capacitor being modeled in Farads."
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(440);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\ncap_branch(i) = wd.capacitor(i, 1e-7);\nprobe(i) = wd.resistor_Vout(i, 1800);\ncapacitor_test = wd.buildtree(vsrc : (series_node : (cap_branch, probe)));"
    },
    "wd.capacitor_Vout": {
      "prefix": "wd",
      "name": "capacitor_Vout",
      "full_name": "wd.capacitor_Vout",
      "args": [
        "A : cout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted Capacitor + voltage out.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "R": "Capacitance/Impedence of the capacitor being modeled in Farads"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(330);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\ncap_branch(i) = wd.capacitor_Vout(i, 2e-7);\nload(i) = wd.resistor(i, 1500);\ncapacitor_Vout_test = wd.buildtree(vsrc : (series_node : (cap_branch, load)));"
    },
    "wd.inductor": {
      "prefix": "wd",
      "name": "inductor",
      "full_name": "wd.inductor",
      "args": [
        "A : l1"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Inductor.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "R": "Inductance/Impedance of the inductor being modeled in Henries"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(260);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\ninductive_branch(i) = wd.inductor(i, 0.01);\nprobe(i) = wd.resistor_Vout(i, 2200);\ninductor_test = wd.buildtree(vsrc : (series_node : (inductive_branch, probe)));"
    },
    "wd.inductor_Vout": {
      "prefix": "wd",
      "name": "inductor_Vout",
      "full_name": "wd.inductor_Vout",
      "args": [
        "A : lout"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Inductor + Voltage out.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "R": "Inductance/Impedance of the inductor being modeled in Henries"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndrive = os.osc(280);\nvsrc(i) = wd.u_voltage(i, drive);\nseries_node(i) = wd.series(i);\ninductive_branch(i) = wd.inductor_Vout(i, 0.02);\nload(i) = wd.resistor(i, 1500);\ninductor_Vout_test = wd.buildtree(vsrc : (series_node : (inductive_branch, load)));"
    },
    "wd.u_idealDiode": {
      "prefix": "wd",
      "name": "u_idealDiode",
      "full_name": "wd.u_idealDiode",
      "args": [
        "u_idealDiode : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Ideal Diode.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\ndiode(i) = wd.u_idealDiode(i);\nseries_node(i) = wd.series(i);\nbranch_a(i) = wd.resistor(i, 1200);\nbranch_b(i) = wd.resistor_Vout(i, 1800);\nu_idealDiode_test = wd.buildtree(diode : (series_node : (branch_a, branch_b)));"
    },
    "wd.u_chua": {
      "prefix": "wd",
      "name": "u_chua",
      "full_name": "wd.u_chua",
      "args": [
        "chua1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted Chua Diode.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "G1": "resistance parameter 1 of the chua diode",
        "G2": "resistance parameter 2 of the chua diode",
        "V0": "voltage parameter of the chua diode"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nchua_node(i) = wd.u_chua(i, 1e-3, 5e-4, 0.2);\nseries_node(i) = wd.series(i);\nbranch_a(i) = wd.resistor(i, 1500);\nbranch_b(i) = wd.resistor_Vout(i, 2200);\nu_chua_test = wd.buildtree(chua_node : (series_node : (branch_a, branch_b)));"
    },
    "wd.lambert": {
      "prefix": "wd",
      "name": "lambert",
      "full_name": "wd.lambert",
      "args": [
        "n",
        "itr"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "An implementation of the lambert function. It uses Halley's method of iteration to approximate the output. Included in the WD library for use in non-linear diode models.",
      "param_docs": {
        "n": "value at which the lambert function will be evaluated",
        "itr": "number of iterations before output"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nlambert_gain = wd.lambert(0.5, 6);\nlambert_test = os.osc(220) * lambert_gain;"
    },
    "wd.u_diodePair": {
      "prefix": "wd",
      "name": "u_diodePair",
      "full_name": "wd.u_diodePair",
      "args": [
        "d1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted pair of diodes facing in opposite directions.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "Is": "saturation current of the diodes",
        "Vt": "thermal resistances of the diodes"
      },
      "example": "wd = library(\"wdmodels.lib\");\nu_diodePair_test = wd.u_diodePair(2, 1e-12, 0.025);"
    },
    "wd.u_diodeSingle": {
      "prefix": "wd",
      "name": "u_diodeSingle",
      "full_name": "wd.u_diodeSingle",
      "args": [
        "d1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted single diode.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "Is": "saturation current of the diodes",
        "Vt": "thermal resistances of the diodes"
      },
      "example": "wd = library(\"wdmodels.lib\");\nu_diodeSingle_test = wd.u_diodeSingle(2, 8e-13, 0.026);"
    },
    "wd.u_diodeAntiparallel": {
      "prefix": "wd",
      "name": "u_diodeAntiparallel",
      "full_name": "wd.u_diodeAntiparallel",
      "args": [
        "d1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted set of antiparallel diodes with M diodes facing forwards and N diodes facing backwards.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "Is": "saturation current of the diodes",
        "Vt": "thermal resistances of the diodes"
      },
      "example": "wd = library(\"wdmodels.lib\");\nu_diodeAntiparallel_test = wd.u_diodeAntiparallel(2, 1e-12, 0.025, 2, 2);"
    },
    "wd.u_parallel2Port": {
      "prefix": "wd",
      "name": "u_parallel2Port",
      "full_name": "wd.u_parallel2Port",
      "args": [
        "u_parallel2Port : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted 2-port parallel connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nroot(i) = wd.u_parallel2Port(i);\nbranch_source(i) = wd.resVoltage_Vout(i, 1500, 0.2 * os.osc(220));\nbranch_load(i) = wd.resistor(i, 1800);\nu_parallel2Port_test = wd.buildtree(root : (branch_source, branch_load));"
    },
    "wd.parallel2Port": {
      "prefix": "wd",
      "name": "parallel2Port",
      "full_name": "wd.parallel2Port",
      "args": [
        "A : parallel2Port : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port parallel connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(260));\nconnector(i) = wd.parallel2Port(i);\nload(i) = wd.resistor_Vout(i, 1800);\nparallel2Port_test = wd.buildtree(vsrc : (connector : load));"
    },
    "wd.u_series2Port": {
      "prefix": "wd",
      "name": "u_series2Port",
      "full_name": "wd.u_series2Port",
      "args": [
        "u_series2Port : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted 2-port series connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nroot(i) = wd.u_series2Port(i);\nbranch_source(i) = wd.resVoltage_Vout(i, 1200, 0.25 * os.osc(180));\nbranch_load(i) = wd.resistor(i, 1800);\nu_series2Port_test = wd.buildtree(root : (branch_source, branch_load));"
    },
    "wd.series2Port": {
      "prefix": "wd",
      "name": "series2Port",
      "full_name": "wd.series2Port",
      "args": [
        "A : series2Port : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port series connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(200));\nconnector(i) = wd.series2Port(i);\nload(i) = wd.resistor_Vout(i, 2200);\nseries2Port_test = wd.buildtree(vsrc : (connector : load));"
    },
    "wd.parallelCurrent": {
      "prefix": "wd",
      "name": "parallelCurrent",
      "full_name": "wd.parallelCurrent",
      "args": [
        "A : i1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port parallel connection + ideal current source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "jin": "Current through the ideal current source in Amps"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(240));\nconnector(i) = wd.parallelCurrent(i, 0.1);\nload(i) = wd.resistor_Vout(i, 1500);\nparallelCurrent_test = wd.buildtree(vsrc : (connector : load));"
    },
    "wd.seriesVoltage": {
      "prefix": "wd",
      "name": "seriesVoltage",
      "full_name": "wd.seriesVoltage",
      "args": [
        "A : v1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 2-port series connection + ideal voltage source.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "vin": "voltage across the ideal current source in Volts"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(210));\nconnector(i) = wd.seriesVoltage(i, 0.3);\nload(i) = wd.resistor_Vout(i, 1500);\nseriesVoltage_test = wd.buildtree(vsrc : (connector : load));"
    },
    "wd.u_transformer": {
      "prefix": "wd",
      "name": "u_transformer",
      "full_name": "wd.u_transformer",
      "args": [
        "t1 : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted ideal transformer.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "tr": "the turn ratio between the windings on the primary and secondary coils"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nroot(i) = wd.u_transformer(i, 2.0);\nprimary(i) = wd.resVoltage_Vout(i, 1500, 0.2 * os.osc(220));\nsecondary(i) = wd.resistor_Vout(i, 2200);\nu_transformer_test = wd.buildtree(root : (primary, secondary));"
    },
    "wd.transformer": {
      "prefix": "wd",
      "name": "transformer",
      "full_name": "wd.transformer",
      "args": [
        "A : t1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted ideal transformer.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "tr": "the turn ratio between the windings on the primary and secondary coils"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(180));\nxfmr(i) = wd.transformer(i, 2.5);\nload(i) = wd.resistor_Vout(i, 2200);\ntransformer_test = wd.buildtree(vsrc : (xfmr : load));"
    },
    "wd.u_transformerActive": {
      "prefix": "wd",
      "name": "u_transformerActive",
      "full_name": "wd.u_transformerActive",
      "args": [
        "t1 : (A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted ideal active transformer.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "gamma1": "the turn ratio describing the voltage relationship between the primary and secondary coils",
        "gamma2": "the turn ratio describing the current relationship between the primary and secondary coils"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nroot(i) = wd.u_transformerActive(i, 0.9, 0.8);\nprimary(i) = wd.resVoltage_Vout(i, 1200, 0.18 * os.osc(190));\nsecondary(i) = wd.resistor_Vout(i, 2200);\nu_transformerActive_test = wd.buildtree(root : (primary, secondary));"
    },
    "wd.transformerActive": {
      "prefix": "wd",
      "name": "transformerActive",
      "full_name": "wd.transformerActive",
      "args": [
        "A : t1 : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted ideal active transformer.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "gamma1": "the turn ratio describing the voltage relationship between the primary and secondary coils",
        "gamma2": "the turn ratio describing the current relationship between the primary and secondary coils"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(175));\nxfmr(i) = wd.transformerActive(i, 0.9, 0.8);\nload(i) = wd.resistor_Vout(i, 2200);\ntransformerActive_test = wd.buildtree(vsrc : (xfmr : load));"
    },
    "wd.parallel": {
      "prefix": "wd",
      "name": "parallel",
      "full_name": "wd.parallel",
      "args": [
        "A : parallel : (B",
        "C"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 3-port parallel connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(220));\njunction(i) = wd.parallel(i);\nbranch_a(i) = wd.resistor(i, 1200);\nbranch_b(i) = wd.resistor_Vout(i, 1800);\nparallel_test = wd.buildtree(vsrc : (junction : (branch_a, branch_b)));"
    },
    "wd.series": {
      "prefix": "wd",
      "name": "series",
      "full_name": "wd.series",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Adapted 3-port series connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(260));\njunction(i) = wd.series(i);\nbranch_a(i) = wd.resistor(i, 1000);\nbranch_b(i) = wd.resistor_Vout(i, 2200);\nseries_test = wd.buildtree(vsrc : (junction : (branch_a, branch_b)));"
    },
    "wd.u_sixportPassive": {
      "prefix": "wd",
      "name": "u_sixportPassive",
      "full_name": "wd.u_sixportPassive",
      "args": [
        "0"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Unadapted six-port rigid connection.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nu_sixportPassive_test = (1000, 1200, 1400, 1600, 1800, 2000, os.osc(220), 0, 0, 0, 0, 0, 0)\n: wd.u_sixportPassive(0) : _, !, !, !, !;"
    },
    "wd.genericNode": {
      "prefix": "wd",
      "name": "genericNode",
      "full_name": "wd.genericNode",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating an adapted node from another faust function or scattering matrix.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "scatter": "the function which describes the the node's scattering behavior",
        "upRes": "the function which describes the node's upward-facing port-resistance"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nscatter(a) = -a * 0.3;\nupRes = 1400;\nnode_iout(i) = wd.genericNode_Iout(i, scatter, upRes);\nvsrc(i) = wd.u_voltage(i, os.osc(230));\nbranch(i) = wd.series(i);\nload(i) = wd.resistor(i, 1800);\ngenericNode_Iout_test = wd.buildtree(vsrc : (branch : (node_iout, load)));"
    },
    "wd.genericNode_Vout": {
      "prefix": "wd",
      "name": "genericNode_Vout",
      "full_name": "wd.genericNode_Vout",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating a terminating/leaf node which gives the voltage across itself as a model output.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "scatter": "the function which describes the the node's scattering behavior",
        "upRes": "the function which describes the node's upward-facing port-resistance"
      },
      "example": ""
    },
    "wd.genericNode_Iout": {
      "prefix": "wd",
      "name": "genericNode_Iout",
      "full_name": "wd.genericNode_Iout",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating a terminating/leaf node which gives the current through itself as a model output.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "scatter": "the function which describes the the node's scattering behavior",
        "upRes": "the function which describes the node's upward-facing port-resistance"
      },
      "example": ""
    },
    "wd.u_genericNode": {
      "prefix": "wd",
      "name": "u_genericNode",
      "full_name": "wd.u_genericNode",
      "args": [],
      "arg_count": 0,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for generating an unadapted node from another Faust function or scattering matrix.",
      "param_docs": {
        "i": "index used by model-building functions. Should never be user declared",
        "scatter": "the function which describes the the node's scattering behavior"
      },
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nscatter(a) = -a * 0.5;\nroot(i) = wd.u_genericNode(i, scatter);\nbranch(i) = wd.series(i);\nload_a(i) = wd.resistor(i, 1500);\nload_b(i) = wd.resistor_Vout(i, 2200);\nu_genericNode_test = wd.buildtree(root : (branch : (load_a, load_b)));"
    },
    "wd.builddown": {
      "prefix": "wd",
      "name": "builddown",
      "full_name": "wd.builddown",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for building the structure for calculating waves traveling down the WD connection tree.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(220));\nbranch(i) = wd.series(i);\nres_leaf(i) = wd.resistor(i, 1200);\nprobe(i) = wd.resistor_Vout(i, 1800);\ntree = vsrc : (branch : (res_leaf, probe));\nbuilddown_test = wd.builddown(tree) ~ wd.buildup(tree) : wd.buildout(tree);"
    },
    "wd.buildup": {
      "prefix": "wd",
      "name": "buildup",
      "full_name": "wd.buildup",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for building the structure for calculating waves traveling up the WD connection tree.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(220));\nbranch(i) = wd.series(i);\nres_leaf(i) = wd.resistor(i, 1200);\nprobe(i) = wd.resistor_Vout(i, 1800);\ntree = vsrc : (branch : (res_leaf, probe));\nbuildup_test = wd.builddown(tree) ~ wd.buildup(tree) : wd.buildout(tree);"
    },
    "wd.getres": {
      "prefix": "wd",
      "name": "getres",
      "full_name": "wd.getres",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for determining the upward-facing port resistance of a partial WD connection tree.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nbranch(i) = wd.series(i);\nres_leaf(i) = wd.resistor(i, 1200);\nprobe(i) = wd.resistor_Vout(i, 1800);\nsubtree = branch : (res_leaf, probe);\ngetres_value = wd.getres(subtree);\ngetres_test = os.osc(110) * (1.0/(1.0 + getres_value));"
    },
    "wd.parres": {
      "prefix": "wd",
      "name": "parres",
      "full_name": "wd.parres",
      "args": [
        "A",
        "B"
      ],
      "arg_count": 2,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for determining the upward-facing port resistance of a partial WD connection tree.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nbranchLeft(i) = wd.series(i);\nres_left(i) = wd.resistor(i, 1200);\nprobe_left(i) = wd.resistor(i, 1800);\nsubtree_left = branchLeft : (res_left, probe_left);\nbranchRight(i) = wd.parallel(i);\nres_right(i) = wd.resistor(i, 1500);\nprobe_right(i) = wd.resistor(i, 2200);\nsubtree_right = branchRight : (res_right, probe_right);\nparres_test = wd.parres((subtree_left, subtree_right)) : _, !;"
    },
    "wd.buildout": {
      "prefix": "wd",
      "name": "buildout",
      "full_name": "wd.buildout",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for creating the output matrix for a WD model from a WD connection tree.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(240));\nbranch(i) = wd.series(i);\nres_leaf(i) = wd.resistor(i, 1200);\nprobe(i) = wd.resistor_Vout(i, 1800);\ntree = vsrc : (branch : (res_leaf, probe));\nbuildout_matrix = wd.buildout(tree);\nbuildout_test = wd.builddown(tree) ~ wd.buildup(tree) : buildout_matrix;"
    },
    "wd.buildtree": {
      "prefix": "wd",
      "name": "buildtree",
      "full_name": "wd.buildtree",
      "args": [
        "A : B"
      ],
      "arg_count": 1,
      "inputs": 0,
      "outputs": 1,
      "description": "Function for building the DSP model from a WD connection tree structure.",
      "param_docs": {},
      "example": "wd = library(\"wdmodels.lib\");\nos = library(\"oscillators.lib\");\nvsrc(i) = wd.u_voltage(i, os.osc(220));\nbranch(i) = wd.series(i);\nres_leaf(i) = wd.resistor(i, 1200);\nprobe(i) = wd.resistor_Vout(i, 1800);\ntree = vsrc : (branch : (res_leaf, probe));\nbuildtree_test = wd.buildtree(tree);"
    },
    "wa.lowpass2": {
      "prefix": "wa",
      "name": "lowpass2",
      "full_name": "wa.lowpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order resonant lowpass filter with 12dB/octave rolloff. Frequencies below the cutoff pass through, frequencies above it are attenuated.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "Q": "the quality factor",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nlowpass2_test = os.osc(440) : wa.lowpass2(1000, 0.707, 0);"
    },
    "wa.highpass2": {
      "prefix": "wa",
      "name": "highpass2",
      "full_name": "wa.highpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order resonant highpass filter with 12dB/octave rolloff. Frequencies below the cutoff are attenuated, frequencies above it pass through.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "Q": "the quality factor",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nhighpass2_test = os.osc(440) : wa.highpass2(1000, 0.707, 0);"
    },
    "wa.bandpass2": {
      "prefix": "wa",
      "name": "bandpass2",
      "full_name": "wa.bandpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order bandpass filter. Frequencies outside the given range of frequencies are attenuated, the frequencies inside it pass through.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "Q": "the quality factor",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nbandpass2_test = os.osc(440) : wa.bandpass2(1000, 1, 0);"
    },
    "wa.notch2": {
      "prefix": "wa",
      "name": "notch2",
      "full_name": "wa.notch2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard notch filter, also called a band-stop or band-rejection filter. It is the opposite of a bandpass filter: frequencies outside the give range of frequencies pass through, frequencies inside it ",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "Q": "the quality factor",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nnotch2_test = os.osc(440) : wa.notch2(1000, 1, 0);"
    },
    "wa.allpass2": {
      "prefix": "wa",
      "name": "allpass2",
      "full_name": "wa.allpass2",
      "args": [
        "f0",
        "Q",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 1,
      "outputs": 1,
      "description": "Standard second-order allpass filter. It lets all frequencies through, but changes the phase-relationship between the various frequencies.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "Q": "the quality factor",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nallpass2_test = os.osc(440) : wa.allpass2(1000, 1, 0);"
    },
    "wa.peaking2": {
      "prefix": "wa",
      "name": "peaking2",
      "full_name": "wa.peaking2",
      "args": [
        "f0",
        "gain",
        "Q",
        "dtune"
      ],
      "arg_count": 4,
      "inputs": 1,
      "outputs": 1,
      "description": "Frequencies inside the range get a boost or an attenuation, frequencies outside it are unchanged.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "gain": "the gain in dB",
        "Q": "the quality factor",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\npeaking2_test = os.osc(440) : wa.peaking2(1000, 3, 1, 0);"
    },
    "wa.lowshelf2": {
      "prefix": "wa",
      "name": "lowshelf2",
      "full_name": "wa.lowshelf2",
      "args": [
        "f0",
        "gain",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard second-order lowshelf filter. Frequencies lower than the frequency get a boost, or an attenuation, frequencies over it are unchanged.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "gain": "the gain in dB",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nlowshelf2_test = os.osc(440) : wa.lowshelf2(500, 6, 0);"
    },
    "wa.highshelf2": {
      "prefix": "wa",
      "name": "highshelf2",
      "full_name": "wa.highshelf2",
      "args": [
        "f0",
        "gain",
        "dtune"
      ],
      "arg_count": 3,
      "inputs": 0,
      "outputs": 1,
      "description": "Standard second-order highshelf filter. Frequencies higher than the frequency get a boost or an attenuation, frequencies lower than it are unchanged.",
      "param_docs": {
        "f0": "cutoff frequency in Hz",
        "gain": "the gain in dB",
        "dtune": "detuning of the frequency in cents"
      },
      "example": "wa = library(\"webaudio.lib\");\nos = library(\"oscillators.lib\");\nhighshelf2_test = os.osc(440) : wa.highshelf2(2000, -6, 0);"
    }
  }
}